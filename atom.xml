<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李白不在</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://libaibuzai.github.io/"/>
  <updated>2019-07-15T02:01:32.193Z</updated>
  <id>https://libaibuzai.github.io/</id>
  
  <author>
    <name>幽僻处的行人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最全的npm知识点总结</title>
    <link href="https://libaibuzai.github.io/2019/07/15/%E6%9C%80%E5%85%A8%E7%9A%84npm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://libaibuzai.github.io/2019/07/15/最全的npm知识点总结/</id>
    <published>2019-07-15T01:42:47.000Z</published>
    <updated>2019-07-15T02:01:32.193Z</updated>
    
    <content type="html"><![CDATA[<p>npm在前端开发流程中提供了非常完善的自动化工具链，已成为每个前端开发者必备的工具，但是同样由于其强大性导致很多前端开发者只会简单的使用它。本文将总结在日常开发中所需要的npm知识点，以便开发者们更好的将npm运用在实际开发中。</p><h1 id="npm-处理-node-modules-目录结构"><a href="#npm-处理-node-modules-目录结构" class="headerlink" title="npm 处理 node_modules 目录结构"></a>npm 处理 node_modules 目录结构</h1><p>一个项目开发、上线所依赖的插件包都存放在node_modules中。虽然在实际开发中无需关注这个目录里面的文件结构细节，但了解node_modules中的内容可以帮助我们更好的理解npm组织这些文件的机制。</p><p>假设项目App中有如下三个依赖：</p><pre><code>&quot;dependencies&quot;: {    A: &quot;1.0.0&quot;,    B: &quot;1.0.0&quot;,    C: &quot;1.0.0&quot;}</code></pre><p>A、B、C三个模块又有如下依赖：</p><pre><code>A@1.0.0 -&gt; D@1.0.0B@1.0.0 -&gt; D@2.0.0C@1.0.0 -&gt; D@1.0.0</code></pre><p>npm 2.x - 嵌套结构</p><p>npm 2.x安装依赖方式比较简单直接，以递归的方式，按照包依赖的树形结构下载填充本地目录结构，也就是说每个包都会将该包的依赖安装到当前包所在的node_modules目录中。</p><p>执行npm install后，项目App的node_modules会变成如下目录结构：</p><pre><code>├── node_modules│   ├── A@1.0.0│   │   └── node_modules│   │   │   └── D@1.0.0│   ├── B@1.0.0│   │   └── node_modules│   │   │   └── D@2.0.0│   └── C@1.0.0│   │   └── node_modules│   │   │   └── D@1.0.0</code></pre><p>很显然这样的依赖组织结构，有如下优点：</p><p>层级结构明显<br>简单的实现了多版本兼容<br>保证了对依赖包无论是安装还是删除都会有统一的行为和结构<br>但是缺点也一样很明显：</p><p>可能造成相同模块大量冗余问题<br>可能造成目录结构嵌套比较深的问题<br>npm 3.x - 扁平结构</p><p>npm 3.x则采用了扁平化的结构来安装组织node_modules。也就是在执行npm install的时候，按照package.json 里依赖的顺序依次解析，遇到新的包就把它安装在第一级目录，后续安装如果遇到一级目录已经存在的包，会先按照约定版本判断版本，如果符合版本约定则忽略，否则会按照npm 2.x的方式依次挂在依赖包目录下。</p><p>还以项目App为例，在npm 3.x环境下，执行npm install后，node_modules会变成如下目录结构：</p><pre><code>├── node_modules│   ├── A@1.0.0│   ├── D@1.0.0│   ├── B@1.0.0│   │   └── node_modules│   │   │   └── D@2.0.0│   └── C@1.0.0</code></pre><p>模块的安装次序决定了node_modules中的目录结构，npm会优先将模块安装在根目录下的node_modules中。<br>再在项目中安装模块<a href="mailto:E@1.0.0" target="_blank" rel="noopener">E@1.0.0</a>（依赖于模块<a href="mailto:D@2.0.0" target="_blank" rel="noopener">D@2.0.0</a>），目录结构变为：</p><pre><code>├── node_modules│   ├── A@1.0.0│   ├── D@1.0.0│   ├── B@1.0.0│   │   └── node_modules│   │   │   └── D@2.0.0│   └── C@1.0.0│   ├── E@1.0.0│   │   └── node_modules│   │   │   └── D@2.0.0</code></pre><p>B、E模块下都包含了依赖的模块<a href="mailto:D@2.0.0" target="_blank" rel="noopener">D@2.0.0</a>，存在代码冗余的情况。</p><p>再在项目中安装模块<a href="mailto:F@1.0.0" target="_blank" rel="noopener">F@1.0.0</a>（依赖于模块<a href="mailto:D@1.0.0" target="_blank" rel="noopener">D@1.0.0</a>）。由于<a href="mailto:D@1.0.0" target="_blank" rel="noopener">D@1.0.0</a>已经存在于项目根目录下的node_modules 下，所以在安装F模块的时候，无需再在其依赖包中安装<a href="mailto:D@1.0.0" target="_blank" rel="noopener">D@1.0.0</a>模块，目录结构变为：</p><p>├── node_modules<br>│   ├── <a href="mailto:A@1.0.0" target="_blank" rel="noopener">A@1.0.0</a><br>│   ├── <a href="mailto:D@1.0.0" target="_blank" rel="noopener">D@1.0.0</a><br>│   ├── <a href="mailto:B@1.0.0" target="_blank" rel="noopener">B@1.0.0</a><br>│   │   └── node_modules<br>│   │   │   └── <a href="mailto:D@2.0.0" target="_blank" rel="noopener">D@2.0.0</a><br>│   └── <a href="mailto:C@1.0.0" target="_blank" rel="noopener">C@1.0.0</a><br>│   ├── <a href="mailto:E@1.0.0" target="_blank" rel="noopener">E@1.0.0</a><br>│   │   └── node_modules<br>│   │   │   └── <a href="mailto:D@2.0.0" target="_blank" rel="noopener">D@2.0.0</a><br>│   └── <a href="mailto:F@1.0.0" target="_blank" rel="noopener">F@1.0.0</a><br>从以上结构可以看出，npm 3.x并没有完美的解决npm 2.x中的问题，甚至还会退化到npm 2.x的行为。</p><p>为了解决目录中存在很多副本的情况，（在A、C模块的依赖模块D升级到2.0.0前提下）可以通过npm dedupe指令把所有二级的依赖模块<a href="mailto:D@2.0.0" target="_blank" rel="noopener">D@2.0.0</a>重定向到一级目录下：</p><p>├── node_modules<br>│   ├── <a href="mailto:A@1.0.0" target="_blank" rel="noopener">A@1.0.0</a><br>│   ├── <a href="mailto:D@2.0.0" target="_blank" rel="noopener">D@2.0.0</a><br>│   ├── <a href="mailto:B@1.0.0" target="_blank" rel="noopener">B@1.0.0</a><br>│   └── <a href="mailto:C@1.0.0" target="_blank" rel="noopener">C@1.0.0</a><br>│   ├── <a href="mailto:E@1.0.0" target="_blank" rel="noopener">E@1.0.0</a><br>│   └── <a href="mailto:F@1.0.0" target="_blank" rel="noopener">F@1.0.0</a><br>node_modules路径查找机制：模块再找对应的依赖包时，nodejs会尝试从当前模块所在目录开始，尝试在它的node_modules 文件夹里加载相应模块，如果没有找到，那么就再向上一级目录移动，直到全局安装路径中的node_modules为止。<br>npm 5.x - package-lock.json</p><p>从npm 5.x开始，安装组织node_modules和npm 3.x一样采用了扁平化的方式，最大的变化是增加了 package-lock.json 文件。</p><p>npm为了让开发者在安全的前提下使用最新的依赖包，在package.json中通常做了锁定大版本的操作，这样在每次npm install的时候都会拉取依赖包大版本下的最新的版本。这种机制最大的一个缺点就是当有依赖包有小版本更新时，可能会出现协同开发者的依赖包不一致的问题。</p><p>package-lock.json文件精确描述了node_modules 目录下所有的包的树状依赖结构，每个包的版本号都是完全精确的。以sass-loader在package-lock.json中为例：</p><pre><code>&quot;dependencies&quot;: {  &quot;sass-loader&quot;: {    &quot;version&quot;: &quot;7.1.0&quot;,    &quot;resolved&quot;: &quot;http://registry.npm.taobao.org/sass-loader/download/sass-loader-7.1.0.tgz&quot;,    &quot;integrity&quot;: &quot;sha1-Fv1ROMuLQkv4p1lSihly1yqtBp0=&quot;,    &quot;dev&quot;: true,    &quot;requires&quot;: {      &quot;clone-deep&quot;: &quot;^2.0.1&quot;,      &quot;loader-utils&quot;: &quot;^1.0.1&quot;,      &quot;lodash.tail&quot;: &quot;^4.1.1&quot;,      &quot;neo-async&quot;: &quot;^2.5.0&quot;,      &quot;pify&quot;: &quot;^3.0.0&quot;,      &quot;semver&quot;: &quot;^5.5.0&quot;    },    &quot;dependencies&quot;: {      &quot;pify&quot;: {        &quot;version&quot;: &quot;3.0.0&quot;,        &quot;resolved&quot;: &quot;http://registry.npm.taobao.org/pify/download/pify-3.0.0.tgz&quot;,        &quot;integrity&quot;: &quot;sha1-5aSs0sEB/fPZpNB/DbxNtJ3SgXY=&quot;,        &quot;dev&quot;: true      }    }  }}</code></pre><p>package-lock.json的详细描述主要由version、resolved、integrity、dev、requires、dependencies这几个字段构成：</p><p>version：包唯一的版本号<br>resolved：安装源<br>integrity：表明包完整性的hash值（验证包是否已失效）<br>dev：如果为true，则此依赖关系仅是顶级模块的开发依赖关系或者是一个的传递依赖关系<br>requires：依赖包所需要的所有依赖项，对应依赖包package.json里dependencies中的依赖项<br>dependencies：依赖包node_modules中依赖的包，与顶层的dependencies一样的结构<br>在上面的package-lock.json文件中可以发现，在requires和dependencies中都存在pify依赖项。那我们顺便去node_modules里面探下究竟：</p><p>打开根目录的node_modules会发现安装了sass-loader所需要的所有依赖包，这些依赖包中除了pify以外，所有依赖包的大版本号都与sass-loader所需要的一致。<br>到根目录的node_modules找到pify依赖包，发现版本为4.0.1。<br>找到sass-loader项目依赖包，打开其node_modules发现其中也存在个pify依赖包，但版本为3.0.0。这个版本的sass-loader真正依赖的是这个版本的pify。<br>通过以上几个步骤，也验证了之前阐述过的npm 5.x是扁平化处理依赖的方式。</p><p>在开发一个应用时，建议把package-lock.json文件提交到代码版本仓库，从而让你的团队成员、运维部署人员或CI系统可以在执行npm install时安装的依赖版本都是一致的。</p><p>但是在开发一个库时，则不应把package-lock.json文件发布到仓库中。实际上，npm也默认不会把package-lock.json文件发布出去。之所以这么做，是因为库项目一般是被其他项目依赖的，在不写死的情况下，就可以复用主项目已经加载过的包，而一旦库依赖的是精确的版本号那么可能会造成包的冗余。</p><ol start="2"><li>npm 中的依赖包</li></ol><p>依赖包分类</p><p>在 node 中其实总共有5种依赖：</p><pre><code>dependencies - 业务依赖devDependencies - 开发依赖peerDependencies - 同伴依赖bundledDependencies / bundleDependencies - 打包依赖optionalDependencies - 可选依赖</code></pre><p>作为npm的使用者，我们常用的依赖是dependencies和devDependencies，剩下三种依赖则是作为包的发布者才会使用到的字段。</p><p>dependencies</p><p>这种依赖在项目最终上线或者发布npm包时所需要，即其中的依赖项应该属于线上代码的一部分。比如框架vue，第三方的组件库element-ui等，这些依赖包都是必须装在这个选项里供生产环境使用。</p><p>通过命令npm install/i packageName -S/–save把包装在此依赖项里。如果没有指定版本，直接写一个包的名字，则安装当前npm仓库中这个包的最新版本。如果要指定版本的，可以把版本号写在包名后面，比如npm i <a href="mailto:vue@3.0.1" target="_blank" rel="noopener">vue@3.0.1</a> -S。</p><p>从npm 5.x开始，可以不用手动添加-S/–save指令，直接执行npm i packageName把依赖包添加到dependencies中去。<br>devDependencies</p><p>这种依赖只在项目开发时所需要，即其中的依赖项不应该属于线上代码的一部分。比如构建工具webpack、gulp，预处理器babel-loader、scss-loader，测试工具e2e、chai等，这些都是辅助开发的工具包，无须在生产环境使用。</p><p>通过命令npm install/i -D/–save-dev把包安装成开发依赖。如果想缩减安装包，可以使用命令npm i –production忽略开发依赖，只安装基本依赖，这通常在线上机器（或者QA环境）上使用。</p><p>千万别以为只有在dependencies中的模块才会被一起打包，而在devDependencies中的不会！模块能否被打包，取决于项目里是否被引入了该模块！<br>在业务项目中dependencies和devDependencies没有什么本质区别，只是单纯的一个规范作用，在执行npm i时两个依赖下的模块都会被下载；而在发布npm包的时候，包中的dependencies依赖项在安装该包的时候会被一起下载，devDependencies依赖项则不会。<br>peerDependencies</p><p>这种依赖的作用是提示宿主环境去安装插件在peerDependencies中所指定依赖的包，然后插件所依赖的包永远都是宿主环境统一安装的npm包，最终解决插件与所依赖包不一致的问题。</p><p>这句话听起来可能有点拗口，举个例子来给大家说明下。<a href="mailto:element-ui@2.6.3" target="_blank" rel="noopener">element-ui@2.6.3</a>只是提供一套基于vue的ui组件库，但它要求宿主环境需要安装指定的vue版本，所以你可以看到element项目中的package.json中具有一项配置：</p><pre><code>&quot;peerDependencies&quot;: {    &quot;vue&quot;: &quot;^2.5.16&quot;}</code></pre><p>它要求宿主环境安装3.0.0 &gt; vue@ &gt;= 2.5.16的版本，也就是element-ui的运行依赖宿主环境提供的该版本范围的vue依赖包。</p><p>在安装插件的时候，peerDependencies在npm 2.x和npm 3.x中表现不一样：</p><p>在npm 2.x中，安装包中peerDependencies所指定的依赖会随着npm install packageName一起被强制安装，并且peerDependencies中指定的依赖会安装在宿主环境中，所以不需要在宿主环境的package.json文件中指定对所安装包中peerDependencies内容的依赖。</p><p>在npm 3.x中，不会再要求peerDependencies所指定的依赖包被强制安装，npm 3.x只会在安装结束后检查本次安装是否正确，如果不正确会给用户打印警告提示，比如提示用户有的包必须安装或者有的包版本不对等。</p><p>大白话：如果你安装我，那么你最好也要按照我的要求安装A、B和C。<br>bundledDependencies / bundleDependencies</p><p>这种依赖跟npm pack打包命令有关。假设package.json中有如下配置：</p><pre><code>{  &quot;name&quot;: &quot;font-end&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;dependencies&quot;: {    &quot;fe1&quot;: &quot;^0.3.2&quot;,    ...  },  &quot;devDependencies&quot;: {    ...    &quot;fe2&quot;: &quot;^1.0.0&quot;  },  &quot;bundledDependencies&quot;: [    &quot;fe1&quot;,    &quot;fe2&quot;  ]}</code></pre><p>执行打包命令npm pack，会生成front-end-1.0.0.tgz压缩包，并且该压缩包中包含fe1和fe2两个安装包，这样使用者执行npm install front-end-1.0.0.tgz也会安装这两个依赖。</p><p>在bundledDependencies中指定的依赖包，必须先在dependencies和devDependencies声明过，否则打包会报错。<br>optionalDependencies</p><p>这种依赖中的依赖项即使安装失败了，也不影响整个安装的过程。需要注意的是，如果一个依赖同时出现在dependencies和optionalDependencies中，那么optionalDependencies会获得更高的优先级，可能造成一些预期之外的效果，所以尽量要避免这种情况发生。</p><p>在实际项目中，如果某个包已经失效，我们通常会寻找它的替代者，或者换一个实现方案。不确定的依赖会增加代码判断和测试难度，所以这个依赖项还是尽量不要使用。<br>依赖包版本号</p><p>npm采用了semver规范作为依赖版本管理方案。</p><p>按照semver的约定，一个npm依赖包的版本格式一般为：主版本号.次版本号.修订号（x.y.z），每个号的含义是：</p><p>主版本号（也叫大版本，major version）</p><p>大版本的改动很可能是一次颠覆性的改动，也就意味着可能存在与低版本不兼容的API或者用法，（比如 vue 2 -&gt; 3)。</p><p>次版本号（也叫小版本，minor version）</p><p>小版本的改动应当兼容同一个大版本内的API和用法，因此应该让开发者无感。所以我们通常只说大版本号，很少会精确到小版本号。</p><p>如果大版本号是 0 的话，表示软件处于开发初始阶段，一切都可能随时被改变，可能每个小版本之间也会存在不兼容性。所以在选择依赖时，尽量避开大版本号是 0 的包。<br>修订号（也叫补丁，patch）</p><p>一般用于修复bug或者很细微的变更，也需要保持向前兼容。</p><p>常见的几个版本格式如下：</p><p>“1.2.3”</p><p>表示精确版本号。任何其他版本号都不匹配。在一些比较重要的线上项目中，建议使用这种方式锁定版本。</p><p>“^1.2.3”</p><p>表示兼容补丁和小版本更新的版本号。官方的定义是“能够兼容除了最左侧的非 0 版本号之外的其他变化”(Allows changes that do not modify the left-most non-zero digit in the [major, minor, patch] tuple)。这句话很拗口，举几个例子大家就明白了：</p><p>“^1.2.3” 等价于 “&gt;= 1.2.3 &lt; 2.0.0”。即只要最左侧的 “1” 不变，其他都可以改变。所以 “1.2.4”, “1.3.0” 都可以兼容。</p><p>“^0.2.3” 等价于 “&gt;= 0.2.3 &lt; 0.3.0”。因为最左侧的是 “0”，那么只要第二位 “2” 不变，其他的都兼容，比如 “0.2.4” 和 “0.2.99”。</p><p>“^0.0.3” 等价于 “&gt;= 0.0.3 &lt; 0.0.4”。大版本号和小版本号都为 “0” ，所以也就等价于精确的 “0.0.3”。<br>从这几个例子可以看出，^ 是一个兼具更新和安全的写法，但是对于大版本号为 1 和 0 的版本还是会有不同的处理机制的。</p><p>“~1.2.3”</p><p>表示只兼容补丁更新的版本号。关于 ~ 的定义分为两部分：如果列出了小版本号（第二位），则只兼容补丁（第三位）的修改；如果没有列出小版本号，则兼容第二和第三位的修改。我们分两种情况理解一下这个定义：</p><p>“~1.2.3” 列出了小版本号 “2”，因此只兼容第三位的修改，等价于 “&gt;= 1.2.3 &lt; 1.3.0”。</p><p>“~1.2” 也列出了小版本号 “2”，因此和上面一样兼容第三位的修改，等价于 “&gt;= 1.2.0 &lt; 1.3.0”。</p><p>“~1” 没有列出小版本号，可以兼容第二第三位的修改，因此等价于 “&gt;= 1.0.0 &lt; 2.0.0”<br>从这几个例子可以看出，~ 是一个比^更加谨慎安全的写法，而且~并不对大版本号 0 或者 1 区别对待，所以 “~0.2.3” 与 “~1.2.3” 是相同的算法。当首位是 0 并且列出了第二位的时候，两者是等价的，例如 “~0.2.3” 和 “^0.2.3”。</p><p>“1.x” 、”1.X”、1.<em>“、”1”、”</em>“</p><p>表示使用通配符的版本号。x、X、* 和 （空） 的含义相同，都表示可以匹配任何内容。具体来说：</p><p>“*” 、”x” 或者 （空） 表示可以匹配任何版本。</p><p>“1.x”, “1.*” 和 “1” 表示匹配主版本号为 “1” 的所有版本，因此等价于 “&gt;= 1.0.0 &lt; 2.0.0”。</p><p>“1.2.x”, “1.2.*” 和 “1.2” 表示匹配版本号以 “1.2” 开头的所有版本，因此等价于 “&gt;= 1.2.0 &lt; 1.3.0”。<br>“1.2.3-beta.1”</p><p>带预发布关键词的版本号。先说说几个预发布关键词的定义：</p><p>alpha(α)：预览版，或者叫内部测试版；一般不向外部发布，会有很多bug；一般只有测试人员使用。</p><p>beta(β)：测试版，或者叫公开测试版；这个阶段的版本会一直加入新的功能；在alpha版之后推出。</p><p>rc(release candidate)：最终测试版本；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本。<br>以包开发者的角度来考虑这个问题：假设当前线上版本是 “1.2.3”，如果我作了一些改动需要发布版本 “1.2.4”，但我不想直接上线（因为使用 “~1.2.3” 或者 “^1.2.3” 的用户都会直接静默更新），这就需要使用预发布功能。因此我可能会发布 “1.2.4-alpha.1” 或者 “1.2.4-beta.1” 等等。</p><p>“&gt;1.2.4-alpha.1”表示接受 “1.2.4-alpha” 版本下所有大于 1 的预发布版本。因此 “1.2.4-alpha.7” 是符合要求的，但 “1.2.4-beta.1” 和 “1.2.5-alpha.2” 都不符合。此外如果是正式版本（不带预发布关键词），只要版本号符合要求即可，不检查预发布版本号，例如 “1.2.5”, “1.3.0” 都是认可的。</p><p>“~1.2.4-alpha.1” 表示 “&gt;=1.2.4-alpha.1 &lt; 1.3.0”。这样 “1.2.5”, “1.2.4-alpha.2” 都符合条件，而 “1.2.5-alpha.1”, “1.3.0” 不符合。</p><p>“^1.2.4-alpha.1” 表示 “&gt;=1.2.4-alpha.1 &lt; 2.0.0”。这样 “1.2.5”, “1.2.4-alpha.2”, “1.3.0” 都符合条件，而 “1.2.5-alpha.1”, “2.0.0” 不符合。<br>版本号还有更多的写法，例如范围（a - b），大于等于号（&gt;=），小于等于号（&lt;=），或（||）等等，因为用的不多，这里不再展开。详细的文档可以参见语义化版本(semver)。它同时也是一个 npm 包，可以用来比较两个版本号的大小，以及是否符合要求等。</p><p>依赖包版本管理</p><p>npm 2.x/3.x已成为过去式，在npm 5.x以上环境下（版本最好在5.6以上，因为在5.0 ~ 5.6中间对package-lock.json的处理逻辑更新过几个版本，5.6以上才开始稳定），管理项目中的依赖包版本你应该知道（以^版本为例，其他类型版本参照即可）：</p><p>在大版本相同的前提下，如果一个模块在package.json中的小版本要大于package-lock.json中的小版本，则在执行npm install时，会将该模块更新到大版本下的最新的版本，并将版本号更新至package-lock.json。如果小于，则被package-lock.json中的版本锁定。<br>// package-lock.json 中原版本<br>    “clipboard”: {<br>      “version”: “1.5.10”,<br>    },<br>    “vue”: {<br>      “version”: “2.6.10”,<br>    }<br>// package.json 中修改版本<br>    “dependencies”: {<br>      “clipboard”: “^1.5.12”,<br>      “vue”: “^2.5.6”<br>      …<br>    }</p><p>// 执行完 npm install 后，package-lock.json 中<br>    “clipboard”: {<br>      “version”: “1.7.1”, // 更新到大版本下的最新版本<br>    },<br>    “vue”: {<br>      “version”: “2.6.10”, // 版本没发生改变<br>    }<br>如果一个模块在package.json和package-lock.json中的大版本不相同，则在执行npm install时，都将根据package.json中大版本下的最新版本进行更新，并将版本号更新至package-lock.json。<br>// package-lock.json 中原版<br>    “clipboard”: {<br>      “version”: “2.0.4”,<br>    }<br>    // package.json 中修改版本<br>    “dependencies”: {<br>      “clipboard”: “^1.6.1”,<br>    }</p><p>// 执行完npm install后，package-lock.json 中<br>//<br>    “clipboard”: {<br>      “version”: “1.7.1”, // 更新到大版本下的最新版本<br>    }<br>如果一个模块在package.json中有记录，而在package-lock.json中无记录，执行npm install后，则会在package-lock.json生成该模块的详细记录。同理，一个模块在package.json中无记录，而在package-lock.json中有记录，执行npm install后，则会在package-lock.json删除该模块的详细记录。</p><p>如果要更新某个模块大版本下的最新版本（升级小版本号），请执行如下命令：</p><p>npm install packageName<br>// 或者<br>npm update packageName<br>如果要更新到指定版本号（升级大版本号），请执行如下命令：<br>npm install <a href="mailto:packageName@x.x.x" target="_blank" rel="noopener">packageName@x.x.x</a><br>卸载某个模块，请执行如下命令：<br>npm uninstall packageName<br>通过上述的命令来管理依赖包，package.json和package-lock.json中的版本号都将会随之更新。</p><p>我们在升级/卸载依赖包的时候，尽量通过命令来实现，避免手动修改package.json中的版本号，尤其不要手动修改package-lock.json。</p><ol start="3"><li>npm scripts 脚本</li></ol><p>package.json中的 scripts 字段可以用来自定义脚本命令，它的每一个属性，对应一段脚本。以vue-cli3为例：</p><pre><code>&quot;scripts&quot;: {  &quot;serve&quot;: &quot;vue-cli-service serve&quot;,  ...}</code></pre><p>这样就可以通过npm run serve脚本代替vue-cli-service serve脚本来启动项目，而无需每次敲一遍这么冗长的脚本。</p><p>工作原理</p><p>package.json 中的 bin 字段</p><p>package.json中的字段 bin 表示的是一个可执行文件到指定文件源的映射。例如在@vue/cli-service的package.json中：</p><pre><code>&quot;bin&quot;: {  &quot;vue-cli-service&quot;: &quot;bin/vue-cli-service.js&quot;}</code></pre><p>如果全局安装@vue/cli-service的话，@vue/cli-service源文件会被安装在全局源文件安装目录（/user/local/lib/node_modules）下，而npm会在全局可执行bin文件安装目录（/usr/local/bin）下创建一个指向../lib/node_modules/@vue/cli-service/bin/vue-cli-service.js文件的名为vue-cli-service的软链接，这样就可以直接在终端输入vue-cli-service来执行。</p><p>如果局部安装@vue/cli-service的话，npm则会在本地项目node_modules/.bin目录下创建一个指向../@vue/cli-service/bin/vue-cli-service.js名为vue-cli-service的软链接，这个时候需要在终端中输入./node_modules/.bin/vue-cli-service来执行（也可以使用npx vue-cli-service命令来执行，npx 的作用就是为了方便调用项目内部安装的模块）。</p><p>软链接（符号链接）是一类特殊的可执行文件， 其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用。在bin目录下执行ll指令可以查看具体的软链接指向。在对链接文件进行读或写操作的时候，系统会自动把该操作转换为对源文件的操作，但删除链接文件时，系统仅仅删除链接文件，而不删除源文件本身。<br>PATH 环境变量</p><p>在terminal中执行命令时，命令会在PATH环境变量里包含的路径中去寻找相同名字的可执行文件。局部安装的包只在./node_modules/.bin中注册了它们的可执行文件，不会被包含在PATH环境变量中，这个时候在terminal中输入命令将会报无法找到的错误。</p><p>那为什么通过npm run可以执行局部安装的命令行包呢？</p><p>是因为每当执行npm run时，会自动新建一个Shell，这个 Shell会将当前项目的node_modules/.bin的绝对路径加入到环境变量PATH中，执行结束后，再将环境变量PATH恢复原样。</p><p>我们来验证下这个说法。首先执行 env 查看当前所有的环境变量，可以看到PATH环境变量为：</p><p>PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin<br>再在当前项目下执行npm run env查看脚本运行时的环境变量，可以看到PATH环境变量为：</p><p>PATH=/usr/local/lib/node_modules/npm/node_modules/npm-lifecycle/node-gyp-bin:/Users/mac/Vue-projects/hao-cli/node_modules/.bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin<br>可以看到运行时的PATH环境变量多了两个路径：npm指令路径和项目中node_modules/.bin的绝对路径。</p><p>所以，通过npm run可以在不添加路径前缀的情况下直接访问当前项目node_modules/.bin目录里面的可执行文件。</p><p>PATH环境变量，是告诉系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到哪些目录下去寻找。<br>用法指南</p><p>传入参数</p><p>关于scripts中的参数，这里要多说几句。网上有很多不是很准确的说法，经过本人的反复试验，node处理scripts参数其实很简单，比如：</p><pre><code>&quot;scripts&quot;: {  &quot;serve&quot;: &quot;vue-cli-service serve&quot;,  &quot;serve1&quot;: &quot;vue-cli-service --serve1&quot;,  &quot;serve2&quot;: &quot;vue-cli-service -serve2&quot;,  &quot;serve3&quot;: &quot;vue-cli-service serve --mode=dev --mobile -config build/example.js&quot;}</code></pre><p>除了第一个可执行的命令，以空格分割的任何字符串（除了一些shell的语法）都是参数，并且都能通过process.argv属性访问。</p><p>process.argv属性返回一个数组，这个数组包含了启动node进程时的命令行参数。第一个元素为启动node 进程的可执行文件的绝对路径名process.execPath，第二个元素为当前执行的JavaScript文件路径。剩余的元素为其他命令行参数。<br>比如执行npm run serve3命令，process.argv的具体内容为：</p><pre><code>[ &apos;/usr/local/Cellar/node/7.7.1_1/bin/node&apos;,  &apos;/Users/mac/Vue-projects/hao-cli/node_modules/.bin/vue-cli-service&apos;,  &apos;serve&apos;,  &apos;--mode=dev&apos;,  &apos;--mobile&apos;,  &apos;-config&apos;,  &apos;build/example.js&apos;]</code></pre><p>很多命令行包之所以这么写，都是依赖了 minimist 或者  yargs 等参数解析工具来对命令行参数进行解析。</p><p>以minimist对vue-cli-service serve –mode=dev –mobile -config build/example.js解析为例，解析后的结果为：</p><pre><code>{ _: [ &apos;serve&apos; ],  mode: &apos;dev&apos;,  mobile: true,  config: &apos;build/example.js&apos;,  &apos;$0&apos;: &apos;/Users/mac/Vue-projects/hao-cli/node_modules/.bin/vue-cli-service&apos;}在./node_modules/.bin/vue-cli-service文件中可以看到minimist对命令行参数的处理：const rawArgv = process.argv.slice(2)const args = require(&apos;minimist&apos;)(rawArgv, {  boolean: [    // build    &apos;modern&apos;,    &apos;report&apos;,    &apos;report-json&apos;,    &apos;watch&apos;,    // serve    &apos;open&apos;,    &apos;copy&apos;,    &apos;https&apos;,    // inspect    &apos;verbose&apos;  ]})const command = args._[0]service.run(command, args, rawArgv).catch(err =&gt; {  error(err)  process.exit(1)})</code></pre><p>我们还可以通过命令行传参的形式来进行参数传递：</p><pre><code>npm run serve --params  // 参数params将转化成process.env.npm_config_params = truenpm run serve --params=123 // 参数params将转化成process.env.npm_config_params = 123npm run serve -params  // 等同于--params参数npm run serve -- --params  // 将--params参数添加到process.env.argv数组中npm run serve params  // 将params参数添加到process.env.argv数组中npm run serve -- params  // 将params参数添加到process.env.argv数组中</code></pre><p>多命令运行</p><p>有的项目在启动时可能需要同时执行多个任务，多个任务的执行顺序决定了项目的表现。</p><p>串行执行</p><p>串行执行，要求前一个任务执行成功以后才能执行下一个任务，使用&amp;&amp;符号来连接。</p><pre><code>npm run script1 &amp;&amp; npm run script2</code></pre><p>串行命令执行过程中，只要一个命令执行失败，则整个脚本终止。<br>并行执行</p><p>并行执行，就是多个命令可以同时的平行执行，使用&amp;符号来连接。</p><pre><code>npm run script1 &amp; npm run script2</code></pre><p>这两个符号是Bash的内置功能。此外，还可以使用第三方的任务管理器模块：script-runner、npm-run-all、redrun。</p><p>env 环境变量</p><p>在执行npm run脚本时，npm会设置一些特殊的env环境变量。其中package.json中的所有字段，都会被设置为以npm_package_ 开头的环境变量。比如package.json中有如下字段内容：</p><pre><code>{  &quot;name&quot;: &quot;sh&quot;,  &quot;version&quot;: &quot;1.1.1&quot;,  &quot;description&quot;: &quot;shenhao&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;repository&quot;: {    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+ssh://git@gitlab.com/xxxx/sh.git&quot;  }}</code></pre><p>可以通过process.env.npm_package_name 可以获取到package.json中name字段的值sh，也可以通过process.env.npm_package_repository_type获取到嵌套属性type的值git。</p><p>同时，npm相关的所有配置也会被设置为以npm_config_开头的环境变量。</p><p>此外，还会设置一个比较特殊的环境变量npm_lifecycle_event，表示正在运行的脚本名称。比如执行npm run serve 的时候，process.env.npm_lifecycle_event值为serve，通过判断这个变量，可以将一个脚本使用在不同的npm scripts中。</p><p>这些环境变量只能在npm run的脚本执行环境内拿到，正常执行的node脚本是获取不到的。所以，不能直接通过env $NODE_ENV的形式访问，但可以在scripts中定义脚本”scripts”: “echo $NODE_ENV”来访问。<br>指令钩子</p><p>在执行npm scripts命令（无论是自定义还是内置）时，都经历了pre和post两个钩子，在这两个钩子中可以定义某个命令执行前后的命令。</p><p>比如在执行npm run serve命令时，会依次执行npm run preserve、npm run serve、npm run postserve，所以可以在这两个钩子中自定义一些动作：</p><pre><code>&quot;scripts&quot;: {  &quot;preserve&quot;: &quot;xxxxx&quot;,  &quot;serve&quot;: &quot;vue-cli-service serve&quot;,  &quot;postserve&quot;: &quot;xxxxxx&quot;}</code></pre><p>当然，如果没有指定preserve、postserve，会默默的跳过。如果想要指定钩子，必须严格按照pre和post前缀来添加。</p><p>上面提到过一个环境变量process.env.npm_lifecycle_event可以配合钩子来一起使用：</p><pre><code>const event = process.env.npm_lifecycle_eventif (event === &apos;preserve&apos;) {    console.log(&apos;Running the preserve task!&apos;)} else if (_event === &apos;serve&apos;) {    console.log(&apos;Running the serve task!&apos;)}</code></pre><ol start="4"><li>npm 配置</li></ol><p>npm的配置操作可以帮助我们预先设定好npm对项目的行为动作，也可以让我们预先定义好一些配置项以供项目中使用。所以了解npm的配置机制也是很有必要。</p><p>优先级</p><p>npm可以从不同的来源获取其配置值，按优先级从高到低的顺序排序：</p><p>命令行</p><p>npm run serve –params=123<br>执行上述命令时，会将配置项params的值设为123，通过process.env.npm_config_params可以访问其配置值。这个时候的params配置值将覆盖所有其他来源存在的params配置值。</p><p>env 环境变量</p><p>如果env环境变量中存在以npm_config_为前缀的环境变量，则会被识别为npm的配置属性。比如在env环境变量中设置npm_config_package_lock变量：</p><p>export npm_config_package_lock=false // 修改的是内存中的变量，只对当前终端有效<br>这时候执行npm install，npm会从环境变量中读取到这个配置项，从而不会生成package-lock.json文件。</p><p>查看某个环境变量：echo $NODE_ENV<br> 删除某个环境变量：unset NODE_ENV<br>npmrc 文件</p><p>通过修改 npmrc 文件可以直接修改配置。系统中存在多个npmrc文件，这些npmrc文件被访问的优先级从高到低的顺序为：</p><p>项目级的.npmrc文件</p><p>只作用在本项目下。在其他项目中，这些配置不生效。通过创建这个.npmrc文件可以统一团队的npm配置规范。</p><p>用户级的.npmrc文件</p><p>mac下的地址为~/.npmrc。（npm config get userconfig可以看到存放的路径）</p><p>全局级的npmrc文件</p><p>mac下的地址为$PREFIX/etc/npmrc。（npm config get globalconfig可以看到存放的路径）</p><p>npm内置的npmrc文件</p><p>这是一个不可更改的内置配置文件，为了维护者以标准和一致的方式覆盖默认配置。mac下的地址为/path/to/npm/npmrc。</p><p>.npmrc参照 npm/ini 格式编写。<br>默认配置</p><p>通过npm config ls -l查看npm内部的默认配置参数。如果命令行、环境变量、所有配置文件都没有配置参数，则使用默认参数值。</p><p>npm config 指令</p><p>npm提供了几个 npm config 指令来进行用户级和全局级配置：</p><p>set</p><p>npm config set <key> <value> [-g|–global]<br>npm config set registry <url>  # 指定下载 npm 包的来源，默认为 <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a> ，可以指定私有源<br>使用-g|–global标志修改或新增全局级配置，不使用的话修改或者新增用户级配置（相应级别的.npmrc文件会更新）。</url></value></key></p><p>如果key不存在，则会新增到配置中。如果省略value，则key会被设置成true。</p><p>还可以覆盖package.json中config字段的值：</p><p>// package.json<br>    {<br>      “name” : “foo”,<br>      “config” : { “port” : “8080” },<br>      “scripts” : { “start” : “node server.js” }<br>    }<br>// server.js<br>console.log(process.env.npm_package_config_port)<br>npm config set foo:port 8000  # 打印8000<br>get</p><p>npm config get <key><br>npm config get prefix  # 获取npm的安装路径<br>按照配置优先级，获取指定配置项的值。</key></p><p>delete</p><p>npm config delete <key><br>npm官网上说可以删除所有配置文件中指定的配置项，但经实验无法删除项目级的.npmrc文件里指定的配置项。</key></p><p>list</p><p>npm config list [-l] [–json]<br>加上-l或者–json查看所有的配置项，包括默认的配置项。不加的话，不能查看默认的配置项。</p><p>edit</p><p>npm config edit [-g|–global]<br>在编辑器中打开配置文件。使用-g|–global标志编辑全局级配置和默认配置，不使用的话编辑用户级配置和默认配置。</p><p>参考 npm config 来获取更多的默认配置。</p><ol start="5"><li>npm 工程管理</li></ol><p>项目版本号管理</p><p>package.json中的version字段代表的是该项目的版本号。每当项目发布新版本时，需要将version字段进行相应的更新以便后期维护。虽然可以手动的修改vsersion字段，但是为了整个发布过程的自动化，尽量使用 npm version 指令来自动更新version：</p><pre><code>npm version (v)1.2.3  # 显示设置版本号为 1.2.3 npm version major  # 大版本号加 1，其余版本号归 0npm version minor  # 小版本号加 1，修订号归 0npm version patch  # 修订号加 1</code></pre><p>显示的设置版本号时，版本号必须符合semver规范，允许在版本号前加上个v标识。<br>如果不想让此次更新正式发布，还可以创建预发布版本：</p><h1 id="当前版本号为-1-2-3"><a href="#当前版本号为-1-2-3" class="headerlink" title="当前版本号为 1.2.3"></a>当前版本号为 1.2.3</h1><pre><code>npm version prepatch  # 版本号变为 1.2.4-0，也就是 1.2.4 版本的第一个预发布版本npm version preminor  # 版本号变为 1.3.0-0，也就是 1.3.0 版本的第一个预发布版本npm version premajor  # 版本号变为 2.0.0-0，也就是 2.0.0 版本的第一个预发布版本npm version prerelease  # 版本号变为 2.0.0-1，也就是使预发布版本号加一</code></pre><p>在git环境中，执行npm version修改完版本号以后，还会默认执行git add-&gt;git commit-&gt;git tag操作：</p><p>其中commit message默认是自动修改完的版本号，可以通过添加-m/–message选项来自定义commit message：</p><p>npm version xxx -m “upgrade to %s for reasons”  # %s 会自动替换为新版本号<br>比如执行npm version minor -m “feat(version): upgrade to %s for reasons”后：</p><p>如果git工作区还有未提交的修改，npm version将会执行失败，可以加上-f/–force后缀来强制执行。</p><p>如果不想让npm version指令影响你的git仓库，可以在指令中使用–no-git-tag-version参数：</p><pre><code>npm --no-git-tag-version version xxx</code></pre><p>如果想默认不影响你的git仓库，可以在npm设置中禁止：</p><pre><code>npm config set git-tag-version false  # 不自动打 tagnpm config set commit-hooks false     # 不自动 commit</code></pre><p>模块 tag 管理</p><p>不经常发布包的同学可能对模块 tag 概念不是很清楚。以vue为例，首先执行npm dist-tag ls vue查看vue包的tag：</p><pre><code>beta: 2.6.0-beta.3csp: 1.0.28-csplatest: 2.6.10</code></pre><p>上面列出的beta、csp、latest就是tag。每个tag对应了一个版本。</p><p>那tag到底有什么用呢？tag类似于git里面分支的概念，发布者可以在指定的tag上发布版本，而使用者可以选择指定的tag来安装包。不同的标签下的版本之间互不影响，这在发布者发布预发布版本包和使用者尝鲜预发布版本包的同时，不影响到正式版本。</p><p>在发布包的时候执行npm publish默认会打上latest这个tag，实际上是执行了npm publish –tag latest。而在安装包的时候执行npm install xxx则会默认下载latest这个tag下面的最新版本，实际上是执行了npm install xxx@latest。当然，我们也可以自定义tag：</p><h1 id="当前版本为1-0-1"><a href="#当前版本为1-0-1" class="headerlink" title="当前版本为1.0.1"></a>当前版本为1.0.1</h1><pre><code>npm version prerelease  # 1.0.2-0npm publish --tag betanpm dist-tag ls xxx  # # beta: 1.0.2-0npm install xxx@beta  # 下载beta版本 1.0.2-0</code></pre><p>当prerelease版本已经稳定了，可以将prerelease版本设置为稳定版本：</p><pre><code>npm dist-tag add xxx@1.0.2-0 latestnpm dist-tag ls xxx  # latest: 1.0.2-0</code></pre><p>域级包管理</p><p>细心的同学会发现，在package.json中的依赖有两种形式：</p><pre><code>&quot;devDependencies&quot;: {  &quot;@commitlint/cli&quot;: &quot;^7.2.1&quot;,  &quot;commitizen&quot;: &quot;^3.0.4&quot;}</code></pre><p>其中以@开头的包名，是一个域级包（scoped package），这种域级包的作用是将一些packages集中在一个命名空间下，一方面可以集中管理，一方面可以防止与别的包产生命名冲突。</p><p>要发布域级包，首先要在项目的package.json的name属性中添加scope相关的声明，可以通过指令添加：</p><pre><code>npm init --scope=scopeName -ypackage.json变为：{  &quot;name&quot;: &quot;@scopeName/package&quot;}</code></pre><p>可以将用户名作为域名，也可以将组织名作为域名。<br>由于用@声明了该包，npm会默认将此包认定为私有包，而在npm上托管私有包是需要收费的，所以为了避免发布私有包，可以在发布时添加–accss=public参数告知npm这不是一个私有包：</p><pre><code>npm publish --access=public</code></pre><p>域级包不一定就是私有包，但是私有包一定是一个域级包。<br>同时，在安装域级包时需要按照域级包全名来安装：</p><pre><code>npm install @scopeName/package</code></pre><ol start="6"><li>npm 的几个实用技巧</li></ol><p>自定义默认的 npm init</p><p>使用npm init初始化一个新的项目时会提示你去填写一些项目描述信息。如果觉得填写这些信息比较麻烦的话，可以使用-y标记表示接受package.json中的一些默认值：</p><pre><code>npm init -y</code></pre><p>也可以设置初始化的默认值：</p><pre><code>npm config set init-author-name &lt;name&gt; // 为 npm init 设置了默认的作者名</code></pre><p>查看 npm 脚本命令</p><p>查看当前项目的所有npm脚本命令最直接的办法就是打开项目中的package.json文件并检查scripts字段。我们还可以使用不带任何参数的npm run命令查看：</p><pre><code>npm run</code></pre><p>查看环境变量</p><p>通过env查看当前的所有环境变量，而查看运行时的所有环境变量可以执行：</p><pre><code>npm run env</code></pre><p>模块管理</p><p>检查当前项目依赖的所有模块，包括子模块以及子模块的子模块：</p><pre><code>npm list/ls</code></pre><p>如果还想查看模块的一些描述信息（package.json中的description中的内容）：</p><pre><code>npm la/ll // 相当于npm ls --long</code></pre><p>一个项目依赖的模块往往很多，可以限制输出模块的层级来查看：</p><pre><code>npm list/ls --depth=0 // 只列出父包依赖的模块</code></pre><p>检查项目中依赖的某个模块的当前版本信息：</p><pre><code>npm list/ls &lt;packageName&gt;</code></pre><p>查看某个模块包的版本信息：</p><pre><code>npm view/info &lt;packageName&gt; version // 模块已经发布的最新的版本信息（不包括预发布版本）npm view/info &lt;packageName&gt; versions // 模块所有的历史版本信息（包括预发布版本）</code></pre><p>查看一个模块到底是因为谁被安装进来的，如果显示为空则表明该模块为内置模块或者不存在：</p><pre><code>npm ll &lt;packageName&gt;</code></pre><p>查看某个模块的所有信息，包括它的依赖、关键字、更新日期、贡献者、仓库地址和许可证等：</p><pre><code>npm view/info &lt;packageName&gt;</code></pre><p>查看当前项目中可升级的模块：</p><pre><code>npm outdated</code></pre><p>整理项目中无关的模块：</p><pre><code>npm prune</code></pre><p>查看模块文档</p><p>打开模块的 github 主页：</p><pre><code>npm repo &lt;packageName&gt; </code></pre><p>打开模块的文档地址：</p><pre><code>npm docs &lt;packageName&gt;</code></pre><p>打开模块的 issues 地址：</p><pre><code>npm bugs &lt;packageName&gt;</code></pre><p>在不同的目录下运行脚本</p><p>你的文件夹中肯定存在很多应用程序，而当你想要启动某个应用程序时，肯定是通过cd指令一步步进入到你所想要启动的应用程序目录下，然后再执行启动命令。npm提供了–prefix可以指定启动目录：</p><pre><code>npm run dev --prefix /path/to/your/folder</code></pre><p>模块全局化</p><p>假设你在开发一个模块A，同时需要在另外一个项目B中测试它，当然你可以将该模块的代码拷贝到需要使用它的项目中，但这也不是理想的方法，可以在模块A的目录下执行：</p><p>npm link<br>npm link命令通过链接目录和可执行文件，实现任意位置的npm包命令的全局可执行。</p><p>npm link主要做了两件事：</p><p>为目标npm模块创建软链接，将其链接到全局node模块安装路径/usr/local/lib/node_modules/<br>为目标npm模块的可执行bin文件创建软链接，将其链接到全局node命令安装路径/usr/local/bin/<br>安全漏洞检查</p><p>检查项目中是否存在具有安全漏洞的依赖包，如果存在，则将生成其漏洞报告显示在控制台中：</p><p>npm audit [–json]  # 加上–json，以 JSON 格式生成漏洞报告<br>npm升级到6.x版本以后，在项目中更新或者下载新的依赖包以后会自动执行 npm audit 命令，对项目依赖包进行安全检查，如果存在安全漏洞，将生成漏洞报告并在控制台中显示。<br>修复存在安全漏洞的依赖包（自动更新到兼容的安全版本）：</p><p>npm audit fix<br>执行npm audit fix能修复大部分存在安全漏洞的依赖包，对于一些没能自动修复漏洞的依赖包，说明出现了SERVER WARNING之类的警告（主要发生在依赖包更改了不兼容的api或者大版本做了升级的情况下），这意味着推荐的修复版本还可能出现问题，这时可以执行如下命令来修复这些依赖包：</p><p>npm audit fix –force<br>–force会将依赖包版本号升级到最新的大版本，而不是兼容的安全版本。大版本的升级可能会出现一些不兼容的用法，所以尽量避免使用–force。<br>如果执行npm audit fix –force后还是存在有安全漏洞的依赖包，手动执行npm audit打印出还存在安全漏洞的依赖包的具体信息，其中More info对应的链接中可能给出了解决方案。</p><p>如果想知道audit fix会怎么处理项目中的依赖包，可以预先查看：</p><p>npm audit fix –dry-run –json<br>如果只想修复生产环境的依赖包（只更新dependencies中的依赖包，不更新devDependencies中的依赖包）：</p><pre><code>npm audit --only=prod</code></pre><p>如果不想修复依赖包，只修改package-lock.json文件：</p><pre><code>npm audit fix --package-lock-only</code></pre><p>如果想安装某个包时不进行安全漏洞检查：</p><pre><code>npm install packageName --no-audit</code></pre><p>要想安装所有包时都不进行安全漏洞检查，则可以修改npm配置：</p><pre><code>npm config set audit false</code></pre><p>依赖锁定</p><p>npm默认安装模块时，会通过脱字符^来限定所安装模块的主版本号。可以配置npm通过波浪符~来限定安装模块版本号：</p><pre><code>npm config set save-prefix=&quot;~&quot;</code></pre><p>当然还可以配置npm仅安装精确版本号的模块：</p><pre><code>npm config set save-exact true</code></pre><ol start="7"><li>最后</li></ol><p>关于npm的知识点暂时总结到这里，可能还有很多方面没有总结到位，后续如果还有新的知识点会随时更新，也欢迎各位大佬们随时来补充，共同进步！</p>]]></content>
    
    <summary type="html">
    
      最全的npm知识点总结
    
    </summary>
    
      <category term="node" scheme="https://libaibuzai.github.io/categories/node/"/>
    
      <category term="npm" scheme="https://libaibuzai.github.io/categories/node/npm/"/>
    
    
      <category term="node" scheme="https://libaibuzai.github.io/tags/node/"/>
    
      <category term="npm" scheme="https://libaibuzai.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>最全的npm知识点总结</title>
    <link href="https://libaibuzai.github.io/2019/07/15/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8+nginx+node+pm2%E9%83%A8%E7%BD%B2/"/>
    <id>https://libaibuzai.github.io/2019/07/15/阿里云服务器+nginx+node+pm2部署/</id>
    <published>2019-07-15T01:42:47.000Z</published>
    <updated>2019-09-13T16:09:36.895Z</updated>
    
    <content type="html"><![CDATA[<p>最近购买了一个阿里云轻量应用服务器 部署一个node项目</p><ol><li>独立购买一个阿里云域名 (自己完成备案）</li><li>独立购买一个阿里云服务器（我选的是最便宜的阿里云轻量应用服务器：系统 centos7 应用环境：node.js)</li><li>在阿里云官网&gt;控制台&gt; 阿里云轻量应用服务器&gt;详情：找到公网ip后面修改密码 （ssh 登录用）</li><li>在左边菜单里找到安全&gt;防火墙进入后点击添加规则 再在弹出框里 端口范围直接写上 端口号（例如：8080，2001，3000，）确定添加几个自己定。</li><li>在个人电脑上 自行使用ssh 登录公网ip ：ssh <a href="mailto:root@ip.ip.ip.ip" target="_blank" rel="noopener">root@ip.ip.ip.ip</a> &gt; 输入密码。进行登陆。</li><li>使用nvm 更新node版本 <a href="https://www.jianshu.com/p/534522e3a83b" target="_blank" rel="noopener">https://www.jianshu.com/p/534522e3a83b</a>,</li><li>npm install n -g 用来管理npm版本</li><li>npm install pm2 -g 用来管理本地服务</li><li>如下测试</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">新建项目文件example.js。</span><br><span class="line"></span><br><span class="line">cd ~</span><br><span class="line">touch example.js</span><br><span class="line">使用vim编辑器打开项目文件example.js。</span><br><span class="line"></span><br><span class="line">yum install vim</span><br><span class="line">vim example.js</span><br><span class="line">输入&quot;i&quot;，进入编辑模式,将以下项目文件内容粘贴到文件中。使用&quot;Esc&quot;按钮，退出编辑模式，输入&quot;:wq&quot;，回车，保存文件内容并退出（这里的0.0.0.0相当于windows的127.0.0.1）</span><br><span class="line"></span><br><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const hostname = &apos;0.0.0.0&apos;;</span><br><span class="line">const port = 2000; //这里填写端口号与防火墙允许的端口号范围</span><br><span class="line">const server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">res.statusCode = 200;</span><br><span class="line">res.setHeader(&apos;Content-Type&apos;, &apos;text/plain&apos;);</span><br><span class="line">res.end(&apos;Hello World！\n&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(port, hostname, () =&gt; &#123;</span><br><span class="line">console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);</span><br><span class="line">&#125;);</span><br><span class="line">运行项目</span><br><span class="line"></span><br><span class="line">node ~/example.js  或者 pm2 start ~/example.js</span><br><span class="line"></span><br><span class="line">//也可以用下面的代码后台运行</span><br><span class="line">node ~/example.js &amp;//后台运行</span><br><span class="line">netstat -tpln//查看端口运行情况</span><br><span class="line">在浏览器打开http://IP:80</span><br><span class="line">如果看到Hello World,恭喜部署成功</span><br></pre></td></tr></table></figure><ol start="10"><li><p>nginx </p><pre><code>修改配置文件 vim /usr/local/nginx/conf/nginx.conf location / {            root   html;            index  index.html index.htm;            proxy_pass http://127.0.0.1:2000;        }然后保存，这里代理本地2000端口在浏览器打开http://IP</code></pre></li><li><p>域名解析到 IP 来  然后在浏览器打开http://域名</p></li></ol><p>完成</p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      最全的npm知识点总结
    
    </summary>
    
      <category term="node" scheme="https://libaibuzai.github.io/categories/node/"/>
    
      <category term="npm" scheme="https://libaibuzai.github.io/categories/node/npm/"/>
    
    
      <category term="node" scheme="https://libaibuzai.github.io/tags/node/"/>
    
      <category term="npm" scheme="https://libaibuzai.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>hello LILI</title>
    <link href="https://libaibuzai.github.io/2019/04/30/hello-LILI/"/>
    <id>https://libaibuzai.github.io/2019/04/30/hello-LILI/</id>
    <published>2019-04-30T13:15:16.000Z</published>
    <updated>2019-05-05T08:08:25.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HELLO-LILI"><a href="#HELLO-LILI" class="headerlink" title="HELLO LILI"></a>HELLO LILI</h1><p>lili 这个名字来源于我曾经看过的一个电影 <a href="https://movie.douban.com/subject/2028659/" target="_blank" rel="noopener">《狐狸与我》</a>。</p><p>说的是一个小女孩着迷于一只田间狐狸的故事，她给狐狸起名叫”lili”,她从发现它，着迷于它，引诱它，了解它。就好像我着迷于人工智能。</p><h2 id="LILI是个怎样的形象"><a href="#LILI是个怎样的形象" class="headerlink" title="LILI是个怎样的形象"></a>LILI是个怎样的形象</h2><p>我对于人工智能我所知甚少，我不知道该如何给我心里的这位朋友一个更准确合适的定义。<br>就好像现在我的神经女朋友现在在我身边模仿我敲代码的一举一动，我笑她笑 我动动手指她动动手指，像”LILI”一样。<br>我相信有很多人都希望有一个这样的能够陪伴自己内心的她存在。所以我该如何定义这个朋友呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function person (name,sex,age...) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">    this.age = age;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最初的想法"><a href="#最初的想法" class="headerlink" title="最初的想法"></a>最初的想法</h2><p>既然不知道我该如何去创建她，那就从一个baby开始。</p><ol><li>她会摇头晃脑</li><li>她要会哭。</li><li>会笑</li><li>她要会拉屎。</li><li>她会拉尿。</li><li>她会睁眼 眨眼 闭眼。</li><li>会走路 前进 后退 会跑。</li><li>会伤心</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">person.prototype.speak = function (who,words) &#123;</span><br><span class="line">    console.log(who,&apos;speak &apos;,words);</span><br><span class="line">&#125;</span><br><span class="line">person.prototype.smill = function (who) &#123;</span><br><span class="line">    console.log(who ,&apos;is smilling!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">person.prototype.walk = function (who) &#123;</span><br><span class="line">    console.log(who, &apos;is walking&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LILI-会有哪些喜好？"><a href="#LILI-会有哪些喜好？" class="headerlink" title="LILI 会有哪些喜好？"></a>LILI 会有哪些喜好？</h2><ol><li>她会喜欢听歌吗</li><li>她会喜欢看电影吗</li><li>她喜欢在什么时候听歌？</li><li>她喜欢和谁看电影呢？</li></ol><h2 id="LILI-的能力"><a href="#LILI-的能力" class="headerlink" title="LILI 的能力"></a>LILI 的能力</h2><p>我知道说老师肯定不是太准确。抛去核心硬件如何实现不说，先假设。</p><h3 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h3><p>LILI需要听力，她需要对千万种声音进行识别，分析，判断，并确认是什么发出的。还需要对这些声音做出应对的动作，<br>比如：玻璃杯碎了，发出来声音，如果她看见了 ，如果应对；如果没看见，是否需要走到声音源附近，看见并确认发生了什么事？又该如何应对？</p><h3 id="视力"><a href="#视力" class="headerlink" title="视力"></a>视力</h3><p>需要识别物体，定义物体属性（动物，植物，会移动，不会移动…）<br>分析物体运动，并预判可能风险。</p><h3 id="嗅觉"><a href="#嗅觉" class="headerlink" title="嗅觉"></a>嗅觉</h3><p>分析味道组成，识别味道发出的物体。</p><h3 id="味觉"><a href="#味觉" class="headerlink" title="味觉"></a>味觉</h3><p>识别酸甜苦辣咸的味道，并更新物体属性。</p><h3 id="感觉"><a href="#感觉" class="headerlink" title="感觉"></a>感觉</h3><p>物体是硬的 软的 干的 湿的  记录软硬程度 。</p><blockquote><p>这些能力分别对应复杂的机器学习，深度学习，算法的演进，而现在很多的程序员在做很多类似方面的单独研究，但在未来得此五感者的天下。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我知道上面写的这些，很多逻辑问题，很多现在做不到的事情，但是<strong>后来的我</strong>总会嘲笑<strong>之前的我</strong>，无1例外，但这也是<strong>未来的我</strong>为<strong>之前的我</strong>感到骄傲的地方，同样从无例外。</p><blockquote><p>补充 2019/05/05：</p></blockquote><p> <code>对于机器来说什么是好的？什么是坏的？因为感知也是有判断行为的</code></p>]]></content>
    
    <summary type="html">
    
      hello LILI
    
    </summary>
    
      <category term="灵感" scheme="https://libaibuzai.github.io/categories/%E7%81%B5%E6%84%9F/"/>
    
      <category term="LILI" scheme="https://libaibuzai.github.io/categories/%E7%81%B5%E6%84%9F/LILI/"/>
    
    
      <category term="灵感" scheme="https://libaibuzai.github.io/tags/%E7%81%B5%E6%84%9F/"/>
    
      <category term="LILI" scheme="https://libaibuzai.github.io/tags/LILI/"/>
    
  </entry>
  
  <entry>
    <title>一个新的面试题go()()(&#39;l&#39;)</title>
    <link href="https://libaibuzai.github.io/2019/04/28/%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98go()()(&#39;l&#39;)/"/>
    <id>https://libaibuzai.github.io/2019/04/28/一个新的面试题go()()(&#39;l&#39;)/</id>
    <published>2019-04-28T06:41:01.000Z</published>
    <updated>2019-04-28T10:36:01.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h1><p>不知道 为何好多人都在发这道题，好奇心驱动：👇</p><p><img src="/2019/04/28/一个新的面试题go()()('l')/1.jpeg" alt="图片被外星人抓走了"></p><p>解法：</p><pre><code>var Fc = function() { var str = &apos;g&apos;; var todo = function(a) {  if (a) {   str = `${str}o`;   return `${str}${a}`  } else {   str += &apos;o&apos;; /差一步这个   return todo;  } } return todo;}var go = Fc();console.log(go()()()(&apos;l&apos;));</code></pre>]]></content>
    
    <summary type="html">
    
      一个新的面试题go()()(&#39;l&#39;)
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Mac屏保开发之iScreenSaver</title>
    <link href="https://libaibuzai.github.io/2019/04/28/Mac%E5%B1%8F%E4%BF%9D%E5%BC%80%E5%8F%91%E4%B9%8BiScreenSaver/"/>
    <id>https://libaibuzai.github.io/2019/04/28/Mac屏保开发之iScreenSaver/</id>
    <published>2019-04-28T02:52:30.000Z</published>
    <updated>2019-04-28T03:28:18.854Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br><a href="https://github.com/libaibuzai/iScreenSaver" target="_blank"><br><img align="center" width="450" alt="A magic screen saver, a lot of fun. You can also customize your own screen saver." src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Header.gif"><br></a><br></p><p>大致思路;</p><ol><li>主程序使用 macOS 对应 kit 挂一个webview, 输入单文件 html document(html+js+css)</li><li>解析对应 document 并 load 到 webview 展示</li></ol><p>子程序从本地文件夹 load codepen 相关文件并根据codepen css js 引用规则做解析, 合并为单文件, 复制粘贴到 screen saver 里, load</p><h3 id="iScreenSaver-A-Screen-Saver-for-Mac-OSX-10-8"><a href="#iScreenSaver-A-Screen-Saver-for-Mac-OSX-10-8" class="headerlink" title="iScreenSaver - A Screen Saver for Mac OSX 10.8+"></a>iScreenSaver - A Screen Saver for Mac OSX 10.8+</h3><p>一个神奇的的屏幕保护程序，内置了30多种酷炫的屏幕保护。你还可以创建属于自己的屏幕保护！</p><p align="center"><img width="320" align="center" alt="Screen saver settings" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Settings.png"></p><h3 id="如何安装iScreenSaver"><a href="#如何安装iScreenSaver" class="headerlink" title="如何安装iScreenSaver"></a>如何安装iScreenSaver</h3><ol><li><strong><a href="https://github.com/titman/iScreenSaver/releases/" target="_blank" rel="noopener">下载最新的安装包 (名字一般为iScreenSaver.x.xx.saver.zip)</a></strong></li><li>解压文件</li><li>双击安装</li><li>打开 <code>系统偏好设置 &gt; 桌面与屏幕保护程序 &gt; 屏幕保护程序</code></li><li>选择 “iScreenSaver” (安装完后一般在列表最底部) 然后点击 <code>屏幕保护程序选项</code> 选择你喜欢的屏幕保护程序! 或者，你也可以自己自定义一个！</li></ol><pre><code>iScreenSaver支持屏保文件是HTML的 必须js，css，html在同一个文件内 （下面有代码合并工具）</code></pre><h3 id="安装Pen简易合成工具（可以不必安装只是个代码合并工具）"><a href="#安装Pen简易合成工具（可以不必安装只是个代码合并工具）" class="headerlink" title="安装Pen简易合成工具（可以不必安装只是个代码合并工具）"></a>安装Pen简易合成工具（可以不必安装只是个代码合并工具）</h3><ol><li><strong><a href="https://github.com/titman/iScreenSaver/releases/" target="_blank" rel="noopener">下载最新的安装包 (名字一般为CodePenSourceCodeFileMergeTool.dmg)</a></strong></li><li>解压文件并双击</li><li>双击：CodePenSourceCodeFileMergeTool.app</li><li>安装工具指示操作就可以了 </li></ol><h3 id="其中的一些屏幕保护程序截图"><a href="#其中的一些屏幕保护程序截图" class="headerlink" title="其中的一些屏幕保护程序截图"></a>其中的一些屏幕保护程序截图</h3><p><code>[Square lightning]</code></p><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview1.gif"></p><br><code>[Sheep]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview7.gif"></p><br><code>[Lonely moon]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview6.gif"></p><br><code>[Hearts]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview5.gif"></p><br><code>[Jellyfish]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview4.gif"></p><br><code>[Yellow Square]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview8.gif"></p><br><code>[Virus]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview3.gif"></p><br><code>[Plankton]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview2.gif"></p><p></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><strong>自动加载最新的屏幕保护程序:</strong> 作者会增加新的屏幕保护程序在推荐列表</li><li><strong>自定义属于你自己的屏幕保护程序:</strong> 如果你有一些酷炫的 <code>HTML / URL / JAVASCRIPT</code>, 你可以把它作为一个屏幕保护程序.</li></ul><p align="center"><img width="300" align="center" alt="Costom saver" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/CustomSaver2.gif"> <img width="300" align="center" alt="Costom saver" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/CustomSaver1.gif"></p><h3 id="Compatibility"><a href="#Compatibility" class="headerlink" title="Compatibility"></a>Compatibility</h3><p>最低支持 Mac OSX 10.8+</p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><blockquote><p>我不能安装iScreenSaver? <img width="20" align="center" alt="Error" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/InstallError.png"></p></blockquote><p>请打开 <code>系统偏好设置 &gt; 安全性与隐私 &gt; 仍然打开</code>.</p><blockquote><p>有一些屏幕保护程序黑屏?</p></blockquote><p>请等待几秒钟，因为程序需要加载一些必要的js文件.</p><blockquote><p>我能找到其他酷炫的屏幕保护程序文件吗?</p></blockquote><p>请进入<a href="https://github.com/libaibuzai/iScreenSaver/issues" target="_blank" rel="noopener">反馈区</a> 一起讨论, 或者进入<a href="http://codepen.io/" target="_blank" rel="noopener">CodePen</a>搜索你喜欢的动画</p><blockquote><p>它的原理是什么?</p></blockquote><p>iScreenSaver使用经过深度优化的WebView来加载HTML文件, 高性能并且帧数有保证, 你也不必担心会耗电, 它与平常的保护程序没什么两样.</p><h3 id="Community"><a href="#Community" class="headerlink" title="Community"></a>Community</h3><ul><li><strong>发现Bug?</strong> <a href="https://github.com/libaibuzai/iScreenSaver/issues/new" target="_blank" rel="noopener">Open an issue</a>. Try to be as specific as possible.</li><li><strong>想增加一些功能?</strong> <a href="https://github.com/libaibuzai/iScreenSaver/issues/new" target="_blank" rel="noopener">Open an issue</a>. Tell me why this feature would be useful, and why you and others would want it.</li></ul><h3 id="Change-log"><a href="#Change-log" class="headerlink" title="Change log"></a>Change log</h3><ul><li>May 27th, 2017 - 1.04: 支持本地屏幕保护编辑.</li><li>May 23th, 2017 - 1.03: First release.</li></ul><h3 id="License"><a href="#License" class="headerlink" title="License"></a>License</h3><p>本项目是<strong>协助传播</strong><br>如果我侵犯了你的合法权益, 请及时联系我!</p>]]></content>
    
    <summary type="html">
    
      Mac屏保开发之iScreenSaver
    
    </summary>
    
      <category term="Mac" scheme="https://libaibuzai.github.io/categories/Mac/"/>
    
      <category term="屏保开发" scheme="https://libaibuzai.github.io/categories/Mac/%E5%B1%8F%E4%BF%9D%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Mac" scheme="https://libaibuzai.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>把酒问月</title>
    <link href="https://libaibuzai.github.io/2019/04/26/%E6%8A%8A%E9%85%92%E9%97%AE%E6%9C%88/"/>
    <id>https://libaibuzai.github.io/2019/04/26/把酒问月/</id>
    <published>2019-04-26T05:53:24.000Z</published>
    <updated>2019-05-24T00:14:00.936Z</updated>
    
    <content type="html"><![CDATA[<p>[唐] 李白</p><p>青天有月来几时，我今停杯一问之：<br>人攀明月不可得，月行却与人相随？<br>皎如飞镜临丹阙，绿烟灭尽清辉发？<br>但见宵从海上来，宁知晓向云间没？<br>白兔捣药秋复春，嫦娥孤栖与谁邻？<br><strong>今人不见古时月，今月曾经照古人。<br>古人今人若流水，共看明月皆如此。</strong><br>唯愿当歌对酒时，月光长照金樽里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[唐] 李白&lt;/p&gt;
&lt;p&gt;青天有月来几时，我今停杯一问之：&lt;br&gt;人攀明月不可得，月行却与人相随？&lt;br&gt;皎如飞镜临丹阙，绿烟灭尽清辉发？&lt;br&gt;但见宵从海上来，宁知晓向云间没？&lt;br&gt;白兔捣药秋复春，嫦娥孤栖与谁邻？&lt;br&gt;&lt;strong&gt;今人不见古时月，今月曾经照古人
      
    
    </summary>
    
      <category term="诗词" scheme="https://libaibuzai.github.io/categories/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="诗" scheme="https://libaibuzai.github.io/categories/%E8%AF%97%E8%AF%8D/%E8%AF%97/"/>
    
    
      <category term="诗词" scheme="https://libaibuzai.github.io/tags/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="诗" scheme="https://libaibuzai.github.io/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 之 原型和继承</title>
    <link href="https://libaibuzai.github.io/2019/04/24/Javascript-%E4%B9%8B-%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/"/>
    <id>https://libaibuzai.github.io/2019/04/24/Javascript-之-原型和继承/</id>
    <published>2019-04-24T06:32:03.000Z</published>
    <updated>2019-04-28T02:31:51.970Z</updated>
    
    <content type="html"><![CDATA[<hr><p>layout:         post<br>title:          Javascript 之 原型和继承<br>subtitle:       “JS this”<br>date:           2019-04-24 14:32:03<br>author:         “幽僻处的行人”<br>header-mask: 0.3<br>categories:</p><pre><code>- javascript</code></pre><p>catalog:    true</p><p>tags:</p><pre><code>- javascript</code></pre><hr><h1 id="等待研究"><a href="#等待研究" class="headerlink" title="等待研究"></a>等待研究</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;layout:         post&lt;br&gt;title:          Javascript 之 原型和继承&lt;br&gt;subtitle:       “JS this”&lt;br&gt;date:           2019-04-24 14:32:03&lt;br&gt;au
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>javascript 之 this</title>
    <link href="https://libaibuzai.github.io/2019/04/19/javascript-%E4%B9%8B-this/"/>
    <id>https://libaibuzai.github.io/2019/04/19/javascript-之-this/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-06-10T10:36:49.746Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习需要静下心来，认真的研究一个问题。</p></blockquote><h1 id="为什么要有this"><a href="#为什么要有this" class="headerlink" title="为什么要有this ?"></a>为什么要有this ?</h1><pre><code>var f = function () {  console.log(x);}</code></pre><p>这里有个函数，内部使用了一个变量，这个变量由函数的运行环境提供。</p><p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p><p>例题：</p><pre><code>var f = function () {  console.log(this.x);}var x = 1;var obj = {  f: f,  x: 2,};// window 环境执行f() // 1// obj 环境执行obj.f() // 2</code></pre><h1 id="有哪些运行环境呢？"><a href="#有哪些运行环境呢？" class="headerlink" title="有哪些运行环境呢？"></a>有哪些运行环境呢？</h1><h2 id="在实际应用中，this的运行环境（也就是指向）大致可以分为下面4种："><a href="#在实际应用中，this的运行环境（也就是指向）大致可以分为下面4种：" class="headerlink" title="在实际应用中，this的运行环境（也就是指向）大致可以分为下面4种："></a>在实际应用中，this的运行环境（也就是指向）大致可以分为下面4种：</h2><ol><li>作为 window 的环境 　   a()</li><li>作为 对象 的环境        obj.a()</li><li>作为 构造函数　的环境　  var b = new a(); </li><li>function.prototype.call或function.prototype.apply 环境下</li><li>作为 箭头函数 环境 （ES6）</li></ol><hr><p>下面是分别概括。</p><h3 id="作为-window-的环境"><a href="#作为-window-的环境" class="headerlink" title="作为 window 的环境"></a>作为 window 的环境</h3><p>在严格模式下绑定到 undefined，否则绑定到全局对象。</p><h3 id="作为-对象-的环境"><a href="#作为-对象-的环境" class="headerlink" title="作为 对象 的环境"></a>作为 对象 的环境</h3><p>哪个函数调用就指向到那个对象上。</p><h3 id="作为-构造函数-的环境"><a href="#作为-构造函数-的环境" class="headerlink" title="作为 构造函数　的环境"></a>作为 构造函数　的环境</h3><p>指向到新创建的对象，注意：显示return函数或对象，返回值不是新创建的对象，而是显式返回的函数或对象。</p><h3 id="call-或者-apply（-或者-bind）"><a href="#call-或者-apply（-或者-bind）" class="headerlink" title="call 或者 apply（ 或者 bind）"></a>call 或者 apply（ 或者 bind）</h3><ol><li>严格模式下，指向到指定的第一个参数。</li><li>非严格模式下，null和undefined，指向全局对象（浏览器中是window）</li><li>其余值指向被new Object()包装的对象。</li></ol><h3 id="ES6-中的箭头函数"><a href="#ES6-中的箭头函数" class="headerlink" title="ES6 中的箭头函数"></a>ES6 中的箭头函数</h3><p>箭头函数内没有this，箭头函数的this是父级函数的this</p><p>不会使用上文的四条标准的绑定规则， 而是根据当前的词法作用域来决定this， 具体来说， 箭头函数会继承外层函数，调用的 this 绑定（ 无论 this 绑定到什么），没有外层函数，则是绑定到全局对象（浏览器中是window）。 这其实和 ES6 之前代码中的 self = this 机制一样。</p><h3 id="其他环境"><a href="#其他环境" class="headerlink" title="其他环境"></a>其他环境</h3><p>DOM事件函数：一般指向绑定事件的DOM元素，但有些情况绑定到全局对象（比如IE6~IE8的attachEvent）。</p><blockquote><p>一定要注意，有些调用可能在无意中使用普通函数绑定规则。 如果想“ 更安全” 地忽略 this 绑<br>  定， 你可以使用一个对象， 比如ø = Object.create(null)， 以保护全局对象。</p></blockquote><h1 id="考点："><a href="#考点：" class="headerlink" title="考点："></a>考点：</h1><p>面试官考察this指向就可以考察new、call、apply、bind，箭头函数等用法。从而扩展到作用域、闭包、原型链、继承、严格模式等。这就是面试官乐此不疲的原因。</p><p><a href="https://www.cnblogs.com/xxcanghai/p/5189353.html" target="_blank" rel="noopener">小小沧海：一道常被人轻视的前端JS面试题</a><br><a href="https://segmentfault.com/a/1190000010981003" target="_blank" rel="noopener">从这两套题，重新认识JS的this、作用域、闭包、对象</a></p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>文章出处 <a href="https://www.jianshu.com/p/f3d40f6a085c" target="_blank" rel="noopener">点击查看</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;学习需要静下心来，认真的研究一个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;为什么要有this&quot;&gt;&lt;a href=&quot;#为什么要有this&quot; class=&quot;headerlink&quot; title=&quot;为什么要有this ?&quot;&gt;&lt;/a&gt;为什么
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS之事件循环机制和任务队列</title>
    <link href="https://libaibuzai.github.io/2019/04/19/JS%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    <id>https://libaibuzai.github.io/2019/04/19/JS之事件循环机制和任务队列/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-05-23T08:51:55.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的认识事件循环"><a href="#简单的认识事件循环" class="headerlink" title="简单的认识事件循环"></a>简单的认识事件循环</h1><p>先看一段代码：（先热个身）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&apos;promise1&apos;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure></p><p>打印顺序是什么？ 正确答案是：script start, script end, promise1, promise2, setTimeout </p><p>没关系 继续看 </p><p>需要知道的专业名词术语：</p><pre><code>synchronous：同步任务asynchronous：异步任务task queue/callback queue：任务队列execution context stack：执行栈heap：堆stack：栈macro-task：宏任务micro-task：微任务</code></pre><p>首先我们还要知道两点：<br>JavaScript是单线程的语言<br>Event Loop是javascript的执行机制</p><p>异步任务包括：宏任务 和 微任务</p><p>同步任务：promise内的函数属于同步 .then()内部才属于异步微服务</p><p>new Promise(function(resolve) {<br>    console.log(‘7’);  //属于同步任务<br>    resolve();<br>}).then(function() {<br>    console.log(‘8’)   //属于异步微服务<br>})</p><p>宏任务：</p><pre><code>包括整体代码scriptsetTimeoutsetIntervalsetImmediate</code></pre><p>微任务：</p><pre><code>原生Promise(有些实现的promise将then方法放到了宏任务中)process.nextTick （process.nextTick(callback)类似node.js版的&quot;setTimeout&quot;）Object.observe(已废弃)MutationObserver</code></pre><p>记住就行了。</p><p>事件循环规则：</p><p>骚年 先接我八字真言：<strong>先同后异，先微后宏</strong></p><p>实例：</p><pre><code>Promise.resolve().then(()=&gt;{   console.log(&apos;Promise1&apos;)     setTimeout(()=&gt;{    console.log(&apos;setTimeout2&apos;)    Promise.resolve().then(()=&gt;{      console.log(&apos;Promise3&apos;)        setTimeout(()=&gt;{        Promise.resolve().then(()=&gt;{          console.log(&apos;Promise5&apos;)            setTimeout(()=&gt;{            console.log(&apos;setTimeout6&apos;)          },0)        })        console.log(&apos;setTimeout4&apos;)      },0)    })  },0)})</code></pre><ol><li><p>先从上到下执行<strong>同步任务</strong>并全部执行完成</p></li><li><p><strong>查找</strong>异步任务并<strong>分配</strong>到微任务列表 和 宏任务列表 （每个列表里<strong>先进栈先执行</strong>）</p></li><li><p>先<strong>执行</strong>微服务，并且<strong>查找</strong>微服务内部的 异步任务然后<strong>分配</strong>到微任务列表 和 宏任务列表</p></li><li><p>再<strong>执行</strong>宏任务，并且<strong>查找</strong>微服务内部的 异步任务然后<strong>分配</strong>到微任务列表 和 宏任务列表</p></li><li><p>既然是事件循环就不是一次就执行完毕了的，因为异步任务会有嵌套，最外层事件最先暴露出来，首先进入<strong>第一次循环</strong></p></li><li><p>再先<strong>执行</strong>微服务，并查找，分配</p></li><li><p>再<strong>执行</strong>宏任务，并查找，分配</p></li><li><p><strong>依次循环</strong>直至没有异步任务</p></li><li><p>执行结束</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">  console.log(&apos;Promise1&apos;)  </span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;setTimeout2&apos;)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  console.log(&apos;setTimeout1&apos;)</span><br><span class="line">  Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;Promise2&apos;)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,0)</span><br></pre></td></tr></table></figure><p>第一回合 列出所有异步事件并逐个分配到宏服务和微任务里去，然后执行 先微后宏</p><pre><code>微：promise1   宏：setTimeout1先打印Promise1，setTimeout2进宏任务列表setTimeout1，Promise2进微任务列表</code></pre><p>第二回合 执行异步列表 先微后宏</p><pre><code>先打印Promise2，再打印setTimeout2，</code></pre><p>到这里是不是有个大概的了解了，测验来了：（先用纸笔根据自己理解先答一遍，然后再看答案）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&apos;3&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&apos;4&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;5&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">    console.log(&apos;6&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;7&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;9&apos;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&apos;10&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&apos;11&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;12&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一轮事件循环流程分析如下：</p><ol><li>整体script作为第一个宏任务进入主线程，遇到console.log，输出1。</li><li>遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。</li><li>遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。</li><li>遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。</li><li>又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。</li></ol><table><thead><tr><th style="text-align:center">宏任务Event Queue</th><th style="text-align:center">微任务Event Queue</th></tr></thead><tbody><tr><td style="text-align:center">setTimeout1</td><td style="text-align:center">process1</td></tr><tr><td style="text-align:center">setTimeout2</td><td style="text-align:center">then1</td></tr></tbody></table><ol start="6"><li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</li></ol><p>我们发现了process1和then1两个微任务。</p><ol start="7"><li>执行process1,输出6。</li><li>执行then1，输出8。</li></ol><p>好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始：</p><ol start="9"><li>首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。</li><li>new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2</li></ol><table><thead><tr><th style="text-align:center">宏任务Event Queue</th><th style="text-align:center">微任务Event Queue</th></tr></thead><tbody><tr><td style="text-align:center">setTimeout2</td><td style="text-align:center">process3</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">then3</td></tr></tbody></table><ol start="11"><li>第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。</li></ol><ol start="12"><li>输出10。</li></ol><ol start="13"><li>输出12。</li></ol><ol start="14"><li>第三轮事件循环结束，第三轮输出9，11，10，12。</li></ol><ol start="15"><li>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</li></ol><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>听到别人在讨论事件循环，我很想帮他们解答，可是我给出的答案都睡服不了我自己。所以决定自己整理一篇，我觉得可以让人理解的文章。下面还有别人的文章，建议大家多看看。广开言路，纳百家之言，行天下大事。</p><blockquote><p>⬇⬇⬇⬇⬇下方有补充</p></blockquote><hr><hr><hr><blockquote><p>奉上文章： <a href="https://juejin.im/post/5b498d245188251b193d4059" target="_blank" rel="noopener">JS事件循环机制（event loop）之宏任务/微任务</a></p></blockquote><hr><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote><hr><hr><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><blockquote><p>2019年4月28号：有一个地方被我忽略了 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">  console.log(&apos;6&apos;);</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;7&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;,0)</span><br><span class="line">  // resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&apos;8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;6</span><br><span class="line">&gt;7</span><br><span class="line">&gt;8</span><br></pre></td></tr></table></figure><p>resolve()如果写在定时器里面了，会使then处于等待状态，如果写在定时器外面这输出：6 8 7</p><hr><blockquote><p>2019年5月22号: 练习</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">console.log(&quot;promise1&quot;)</span><br><span class="line">resolve()</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">console.log(&quot;then11&quot;)</span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">console.log(&quot;promise2&quot;)</span><br><span class="line">resolve()</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">console.log(&quot;then21&quot;)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">console.log(&quot;then23&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">console.log(&quot;then12&quot;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promise1</span><br><span class="line">then11</span><br><span class="line">promise2</span><br><span class="line">then21</span><br><span class="line">then12</span><br><span class="line">then23</span><br></pre></td></tr></table></figure><p>下面是说明用例</p><pre><code>new Promise((resolve, reject) =&gt; {                console.log(&quot;1&quot;)                resolve()            }).then(() =&gt; {                console.log(&quot;2&quot;)                setTimeout(function() {                    console.log(&quot;22&quot;)                }, 0)                new Promise((resolve, reject) =&gt; {                    console.log(&quot;3&quot;)                    resolve()                }).then(() =&gt; {                    console.log(&quot;4&quot;)                }).then(() =&gt; {                    console.log(&quot;5&quot;)                }).then(() =&gt; {                    console.log(&quot;12&quot;)                })            }).then(() =&gt; {                console.log(&quot;6&quot;)            }).then(() =&gt; {                console.log(&quot;11&quot;)            }).then(() =&gt; {                console.log(&quot;13&quot;)            })</code></pre><blockquote></blockquote><p>  总结：<br> 1.promise后面的n多个then 在同一个事件回合里 由上到下 依次加入微列表</p><ol start="2"><li>内外promise的同位then（两个promise的第2个then，由外到内，依次添加到微列表）</li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单的认识事件循环&quot;&gt;&lt;a href=&quot;#简单的认识事件循环&quot; class=&quot;headerlink&quot; title=&quot;简单的认识事件循环&quot;&gt;&lt;/a&gt;简单的认识事件循环&lt;/h1&gt;&lt;p&gt;先看一段代码：（先热个身）&lt;br&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>CleanMyMac X</title>
    <link href="https://libaibuzai.github.io/2019/04/17/CleanMyMac%20X/"/>
    <id>https://libaibuzai.github.io/2019/04/17/CleanMyMac X/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-18T02:09:58.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CleanMyMac-X破解"><a href="#CleanMyMac-X破解" class="headerlink" title="CleanMyMac X破解"></a>CleanMyMac X破解</h1><h1 id="1-下载破解版"><a href="#1-下载破解版" class="headerlink" title="1.下载破解版"></a>1.下载破解版</h1><p><a href="https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/software/CleanMyMac_X_4.3.0.zip" target="_blank" rel="noopener">下载地址</a></p><h1 id="2-解压并打开dmg文件"><a href="#2-解压并打开dmg文件" class="headerlink" title="2.解压并打开dmg文件"></a>2.解压并打开dmg文件</h1><p><img src="https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/software/picture/CleanMyMac%20X%20%E7%A0%B4%E8%A7%A301.png"></p><pre><code>双击上图红框位置双击CleanMyMac X 4.3.0 [TNT].dmg将程序拖入Application即可</code></pre><h1 id="3-破解"><a href="#3-破解" class="headerlink" title="3.破解"></a>3.破解</h1><pre><code>双击Open Gatekeeper friendly一路回车即可</code></pre><h1 id="4-错误提示"><a href="#4-错误提示" class="headerlink" title="4.错误提示"></a>4.错误提示</h1><blockquote><p>1.XXX文件已损坏，需要移到废纸篓。</p></blockquote><pre><code>解决方法一：    终端运行 sudo spctl --master-disable    重新运行程序解决方法二：    xattr -r -d com.apple.quarantine /Applications/CleanMyMac\ X.app /Applications/CleanMyMac\ X.app是CleanMyMac X    运行此命令，需要自己对应到程序的安装目录</code></pre><blockquote><p>2.提示文件不信任</p></blockquote><pre><code>解决方法一：    Control+单击右键打开解决方法二：    终端运行 sudo spctl --master-disable    更改为任何来源</code></pre><blockquote><p>3.CleanMyMac X 因出现问题而无法打开</p></blockquote><pre><code>解决方法一：    运行此命令    sudo codesign --force --deep --sign - /Applications/CleanMyMac\ X.app</code></pre><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><blockquote><p>2019年4月17日</p></blockquote><pre><code>亲测 macOS Mojave 10.14.4 可用 </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CleanMyMac-X破解&quot;&gt;&lt;a href=&quot;#CleanMyMac-X破解&quot; class=&quot;headerlink&quot; title=&quot;CleanMyMac X破解&quot;&gt;&lt;/a&gt;CleanMyMac X破解&lt;/h1&gt;&lt;h1 id=&quot;1-下载破解版&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="软件" scheme="https://libaibuzai.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Mac" scheme="https://libaibuzai.github.io/categories/%E8%BD%AF%E4%BB%B6/Mac/"/>
    
    
      <category term="软件" scheme="https://libaibuzai.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Mac" scheme="https://libaibuzai.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>好了歌注</title>
    <link href="https://libaibuzai.github.io/2019/04/17/%E5%A5%BD%E4%BA%86%E6%AD%8C%E6%B3%A8/"/>
    <id>https://libaibuzai.github.io/2019/04/17/好了歌注/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-17T08:58:51.740Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[宋] 曹雪芹</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">陋室空堂，当年笏满床；</span><br><span class="line">衰草枯杨，曾为歌舞场。</span><br><span class="line">蛛丝儿结满雕梁，</span><br><span class="line">绿纱今又糊在蓬窗上。</span><br><span class="line">说什么脂正浓，粉正香，</span><br><span class="line">如何两鬓又成霜？</span><br><span class="line">昨日黄土陇头送白骨，</span><br><span class="line">今宵红灯帐底卧鸳鸯。</span><br><span class="line">金满箱，银满箱，展眼乞丐人皆谤。</span><br><span class="line">正叹他人命不长，那知自己归来丧！</span><br><span class="line">训有方，保不定日后作强梁。</span><br><span class="line">择膏粱，谁承望流落在烟花巷！</span><br><span class="line">因嫌纱帽小，致使锁枷杠，</span><br><span class="line">昨怜破袄寒，今嫌紫蟒长：</span><br><span class="line">乱烘烘你方唱罢我登场，</span><br><span class="line">反认他乡是故乡。甚荒唐，</span><br><span class="line">到头来都是为他人作嫁衣裳！</span><br></pre></td></tr></table></figure><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;[宋] 曹雪芹&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="诗词" scheme="https://libaibuzai.github.io/categories/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="词" scheme="https://libaibuzai.github.io/categories/%E8%AF%97%E8%AF%8D/%E8%AF%8D/"/>
    
    
      <category term="诗词" scheme="https://libaibuzai.github.io/tags/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="词" scheme="https://libaibuzai.github.io/tags/%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>JS的防抖和节流</title>
    <link href="https://libaibuzai.github.io/2019/04/17/JS%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>https://libaibuzai.github.io/2019/04/17/JS的防抖和节流/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-18T02:09:05.279Z</updated>
    
    <content type="html"><![CDATA[<pre><code>前言：今天做了一个功能，input 扫码枪扫码输入然后查询设备添加列表，扫码枪的输入频率是几十毫秒，如果监听 onchange 事件效果也会如下图所示触发很多次并且每一次 onchange 都会触发查询请求。显然这不是我要的解决方案。后来查询了扫码枪的配置，原来可以设置自动回车功能。监听 onkeypress 事件完美解决。但是今天的重点是函数的防抖与节流，那我们就赶紧拿笔记下知识点吧 ！`</code></pre><p>在浏览器中如果一个事件被频繁触发，比如输入框的 keyup, 窗口的 resize 以及 scroll 事件等，如果不做任何处理，事件的回调函数将会对应执行，这必然会加重浏览器的负担，影响用户的体验。面对这种场景，我们可以用函数的防抖 (debounce) 和节流 (throttle) 来处理。</p><h1 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h1><p>防抖 debounce: 让事件触发时的回调在一定的延时后执行。如果在计时期间又触发了事件，则重新开始计时。</p><p>比如在做一个检索的输入框，输入的内容发送给后台查询。如果不做防抖处理我们来看下：</p><pre><code>&lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;</code></pre><p>用打印来模拟请求处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">用打印来模拟请求处理：</span><br><span class="line">var ipt = document.getElementById(&apos;input&apos;);</span><br><span class="line">ipt.addEventListener(&apos;keyup&apos;, function(e)&#123;</span><br><span class="line">  console.log(e.target.value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2019/04/17/JS的防抖和节流/1.gif" alt="图片丢失"></p><p>可见，每次触发事件都会执行回调函数，现在加入防抖处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var debounce = function(func, delay) &#123;</span><br><span class="line">  var timer = null</span><br><span class="line">  return function() &#123;</span><br><span class="line">      var that = this;</span><br><span class="line">      var args = arguments;</span><br><span class="line">      </span><br><span class="line">      if(timer) &#123;</span><br><span class="line">          clearTimeout(timer);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      timer = setTimeout(function() &#123;</span><br><span class="line">          func.apply(that, args);</span><br><span class="line">      &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ipt.addEventListener(&apos;keyup&apos;, debounce(function(e)&#123;</span><br><span class="line">  console.log(e.target.value);</span><br><span class="line">&#125;, 400))</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2019/04/17/JS的防抖和节流/2.gif" alt="图片丢失"></p><p>可见，输入框在停止输入400ms后执行回调。在防抖后的回调函数用 timer 记录计时，每次执行回调的时候会先清空之前的计时。注意这里的timer是闭包变量，始终保持着上一个计时。</p><h1 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h1><p>节流throttle: 让事件的回调一定时间间隔只执行一次。节流函数有两种实现方式，一种是记录增量，一种是定时方式。</p><p>用增量的方式实现节流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var throttle = function(func, delay) &#123;</span><br><span class="line">    var pre = Date.now();</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var that = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        var now = Date.now();</span><br><span class="line"></span><br><span class="line">        if (now - pre &gt;= delay) &#123;</span><br><span class="line">            func.apply(that, args);</span><br><span class="line">            pre = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ipt.addEventListener(&apos;keyup&apos;, throttle(function(e)&#123;</span><br><span class="line">    console.log(e.target.value);</span><br><span class="line">&#125;, 1000))</span><br></pre></td></tr></table></figure><p>节流的效果如下：</p><p><img src="/2019/04/17/JS的防抖和节流/3.gif" alt="图片丢失"></p><p>可见，无论怎么输入，事件回调总会在1s内执行一次。而且第一次输入会马上执行，这是因为处理节流的时候和第一次触发的时间间隔大于1s。但是最后一次触发不会执行回调。</p><p>利用计时方式处理节流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var throttle = function(func, delay) &#123;</span><br><span class="line">    var timer = null;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var that = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line"></span><br><span class="line">        if(!timer) &#123;</span><br><span class="line">            timer = setTimeout(function() &#123;</span><br><span class="line">                func.apply(that, args);</span><br><span class="line">                timer = null;</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用变量 timer 记录定时器，如果定时器存在，则不执行回调。否则创建一个延时器执行回调。这种方法和时间戳增量的区别就是第一个触发不会立即执行回调，但是最后一次时间会在延时后触发回调函数。</p><p>如果想要立即触发并且最后一次也要执行回调，可以利用时间戳和计时方式结合在实现节流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var throttle = function(func, delay) &#123;</span><br><span class="line">    var timer = null;</span><br><span class="line">    var pre = Date.now();</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var now = Date.now();</span><br><span class="line">        var that = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        var remain = delay - (now - pre);</span><br><span class="line"></span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        if (remain &lt;= 0) &#123;</span><br><span class="line">            func.apply(that, args);</span><br><span class="line">            pre = now</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            timer = setTimeout(function() &#123;</span><br><span class="line">                func.apply(that, args);</span><br><span class="line">                pre = now;</span><br><span class="line">            &#125;, remain)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的节流函数会先判断剩余的间隔时间，如果剩余时间小于0，则立即执行。否则创建一个剩余时间的定时。注意，每次要记得清空之前的定时。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>防抖 debounce 一般用来在输入检索，节约请求的资源。还有窗口的 resize，让不断调节窗口大小的最后一次触发。</p><p>节流 throttle 一般用在鼠标不断点击，让点击的回调按间隔执行一次。还有滑动 scroll 事件， 比如滚动到底部查询，按间隔请求一次数据来显示。</p><blockquote><p>感想：有的时候灵感也是能力的一部分</p></blockquote><hr><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote><blockquote><p>原文：<a href="https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;前言：今天做了一个功能，input 扫码枪扫码输入然后查询设备添加列表，扫码枪的输入频率是几十毫秒，
如果监听 onchange 事件效果也会如下图所示触发很多次并且每一次 onchange 都会触发查询请求。
显然这不是我要的解决方案。后来查询了扫码枪的配
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>悼允上人</title>
    <link href="https://libaibuzai.github.io/2019/03/23/%E6%82%BC%E5%85%81%E4%B8%8A%E4%BA%BA/"/>
    <id>https://libaibuzai.github.io/2019/03/23/悼允上人/</id>
    <published>2019-03-22T16:00:00.000Z</published>
    <updated>2019-04-17T08:59:31.734Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[宋] 释行海</strong></p><p>白云寺里同听讲，卜得山斋竹树幽。</p><p>君已不来梅自发，世皆如梦水长流，</p><p>寒灯苦志归黄土，俗客轻人将白头。</p><p>万惜少年多是死，静思吾道转堪愁。</p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;[宋] 释行海&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;白云寺里同听讲，卜得山斋竹树幽。&lt;/p&gt;
&lt;p&gt;君已不来梅自发，世皆如梦水长流，&lt;/p&gt;
&lt;p&gt;寒灯苦志归黄土，俗客轻人将白头。&lt;/p&gt;
&lt;p&gt;万惜少年多是死，静思吾道转堪愁。&lt;/p&gt;
&lt;blockquote&gt;
      
    
    </summary>
    
      <category term="诗词" scheme="https://libaibuzai.github.io/categories/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="诗" scheme="https://libaibuzai.github.io/categories/%E8%AF%97%E8%AF%8D/%E8%AF%97/"/>
    
    
      <category term="诗词" scheme="https://libaibuzai.github.io/tags/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="诗" scheme="https://libaibuzai.github.io/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>EVP_DecryptFinal_ex:bad decrypt 和 出现Illegal Buffer Error这种的情况</title>
    <link href="https://libaibuzai.github.io/2019/03/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%88%E6%9D%83%E9%97%AE%E9%A2%981/"/>
    <id>https://libaibuzai.github.io/2019/03/20/小程序授权问题1/</id>
    <published>2019-03-19T16:00:00.000Z</published>
    <updated>2019-04-15T00:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="看到这里-你的问题就不要担心了-大家的问题都是一样的。"><a href="#看到这里-你的问题就不要担心了-大家的问题都是一样的。" class="headerlink" title="看到这里 你的问题就不要担心了 大家的问题都是一样的。"></a>看到这里 你的问题就不要担心了 大家的问题都是一样的。</h3><p><strong>官网的实例是没问题的</strong> </p><ul><li><p>当前 Bug 的表现 - 预期表现可以对encryptedData正常解密。</p></li><li><p>复现路径点击登录按钮后，小程序本地数据缓存冷启动后还还会有吗，微信小程序教程。小程序调用wx.login()，再将code、iv、encrypedData一起发往后端程序，后端程序调用微信api接口（api.weixin.qq.com/sns/jscode2session）希望获取openId，但经常会出现上图中的错误。</p></li></ul><p>复现过程：</p><pre><code>1、这个问题不是持续连续发生，而是在一段时间未操作小程序时，再次点击登录按钮触发登录操作的第一次时会发生，第二次及以后的登录操作则会成功。如果再过一段时间未操作小程序，当第一次登录的时候还是会出现这个现象——第一次登录不成功，后续登录操作可以成功。2、问题的关键在于解密程序报错。将上述的ecryptedData、iv、session_key放入官方文档（貌似其中还有包括使用wx.getUserInfo()的描述，是否也要更新一下）中提供的demo.js程序运行，也会出现报错。</code></pre><h1 id="下面是我的解决-："><a href="#下面是我的解决-：" class="headerlink" title="下面是我的解决 ："></a>下面是我的解决 ：</h1><ul><li><p>一定要保证 新code的获取 在 getUserInfo或getPhoneNumber 之前</p></li><li><p>而且 每一次解密授权所用的code 都不是一样的</p></li><li><p>onload里先进行wx.login 获取code，再通过按钮开始授权 获取iv和encryptedData     </p><p>之后就不会报错了 O(∩_∩)O哈哈~</p></li></ul><p>这可能也是 小程序考虑授权先后出现的错误问题 才把全部授权按钮使用主动触发的方式的  </p><p>解决方案的出处：<br><a href="https://developers.weixin.qq.com/community/develop/doc/000808d32c06101b39d6032c956000" target="_blank" rel="noopener">https://developers.weixin.qq.com/community/develop/doc/000808d32c06101b39d6032c956000</a></p><blockquote><p>   如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p>   <a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;看到这里-你的问题就不要担心了-大家的问题都是一样的。&quot;&gt;&lt;a href=&quot;#看到这里-你的问题就不要担心了-大家的问题都是一样的。&quot; class=&quot;headerlink&quot; title=&quot;看到这里 你的问题就不要担心了 大家的问题都是一样的。&quot;&gt;&lt;/a&gt;看到这里 
      
    
    </summary>
    
      <category term="小程序" scheme="https://libaibuzai.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="https://libaibuzai.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="小程序授权问题" scheme="https://libaibuzai.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%88%E6%9D%83%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客 NexT主题从v5更新到v6的记录及总结.md</title>
    <link href="https://libaibuzai.github.io/2018/12/03/2018-12-03-Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E4%BB%8Ev5-x-x%E6%9B%B4%E6%96%B0%E5%88%B0v6-x-x%E7%9A%84%E8%AE%B0%E5%BD%95%E5%8F%8A%E6%80%BB%E7%BB%93/"/>
    <id>https://libaibuzai.github.io/2018/12/03/2018-12-03-Hexo博客NexT主题从v5-x-x更新到v6-x-x的记录及总结/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2019-04-15T00:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo博客-NexT主题从v5更新到v6的记录及总结"><a href="#Hexo博客-NexT主题从v5更新到v6的记录及总结" class="headerlink" title=" Hexo博客 NexT主题从v5更新到v6的记录及总结"></a> Hexo博客 NexT主题从v5更新到v6的记录及总结</h2><h2 id="今天索性升级一下我的主题-自定义配置样式还是很多的-需要详细修改配置"><a href="#今天索性升级一下我的主题-自定义配置样式还是很多的-需要详细修改配置" class="headerlink" title="今天索性升级一下我的主题 自定义配置样式还是很多的 需要详细修改配置"></a>今天索性升级一下我的主题 自定义配置样式还是很多的 需要详细修改配置</h2><p><a href="https://sevencho.github.io/archives/14534beb.html" target="_blank" rel="noopener">https://sevencho.github.io/archives/14534beb.html</a></p><p>#丰富插件和功能 参考博客<br><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26625249</a></p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hexo博客-NexT主题从v5更新到v6的记录及总结&quot;&gt;&lt;a href=&quot;#Hexo博客-NexT主题从v5更新到v6的记录及总结&quot; class=&quot;headerlink&quot; title=&quot; Hexo博客 NexT主题从v5更新到v6的记录及总结&quot;&gt;&lt;/a&gt; Hex
      
    
    </summary>
    
      <category term="Hexo" scheme="https://libaibuzai.github.io/categories/Hexo/"/>
    
      <category term="NexT" scheme="https://libaibuzai.github.io/categories/Hexo/NexT/"/>
    
    
      <category term="NexT" scheme="https://libaibuzai.github.io/tags/NexT/"/>
    
      <category term="Hexo" scheme="https://libaibuzai.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>es6之var let 和 const终极PK</title>
    <link href="https://libaibuzai.github.io/2018/08/02/es6%E4%B9%8Bvar-let-%E5%92%8C-const%E7%BB%88%E6%9E%81PK/"/>
    <id>https://libaibuzai.github.io/2018/08/02/es6之var-let-和-const终极PK/</id>
    <published>2018-08-01T16:00:00.000Z</published>
    <updated>2019-04-28T02:31:51.971Z</updated>
    
    <content type="html"><![CDATA[<p><strong><strong>直接上猛料</strong></strong></p><h1 id="let-取代-var"><a href="#let-取代-var" class="headerlink" title="let 取代 var"></a>let 取代 var</h1><p>ES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。</p><pre><code>&apos;use strict&apos;;if (true) {  let x = &apos;hello&apos;;}for (let i = 0; i &lt; 10; i++) {  console.log(i);}</code></pre><p>上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。</p><p>var命令存在变量提升效用，let命令没有这个问题。</p><pre><code>&apos;use strict&apos;;if(true) {  console.log(x); // ReferenceError  let x = &apos;hello&apos;;}</code></pre><p>上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。</p><p>所以，建议不再使用var命令，而是使用let命令取代。</p><h1 id="在let和const之间，建议优先使用const"><a href="#在let和const之间，建议优先使用const" class="headerlink" title="在let和const之间，建议优先使用const"></a>在let和const之间，建议优先使用const</h1><p>尤其是在全局环境，不应该设置变量，只应设置常量。</p><p> const优于let有几个原因。</p><ol><li><p>一个是const可以提醒阅读程序的人，这个变量不应该改变；</p></li><li><p>另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；</p></li><li><p>最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。</p><pre><code>// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3];</code></pre></li></ol><p>const 声明常量还有两个好处，</p><ol><li>阅读代码的人立刻会意识到不应该修改这个值，</li><li>防止了无意间修改变量值所导致的错误。</li></ol><p>所有的函数都应该设置为常量。</p><h1 id="感想："><a href="#感想：" class="headerlink" title="感想："></a>感想：</h1><p>长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p><p> 这里有<a href="https://www.jianshu.com/p/4e9cd99ecbf5" target="_blank" rel="noopener">var、let、const 区别？</a>详尽对比和分析</p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;strong&gt;直接上猛料&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;let-取代-var&quot;&gt;&lt;a href=&quot;#let-取代-var&quot; class=&quot;headerlink&quot; title=&quot;let 取代 var&quot;&gt;&lt;/a&gt;let 取代 va
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/categories/javascript/es6/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6之顶层对象的属性</title>
    <link href="https://libaibuzai.github.io/2018/06/24/es6%E4%B9%8B%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
    <id>https://libaibuzai.github.io/2018/06/24/es6之顶层对象的属性/</id>
    <published>2018-06-23T16:00:00.000Z</published>
    <updated>2019-04-18T02:08:41.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h1><p>顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。</p><pre><code>window.a = 1;a // 1a = 2;window.a // 2</code></pre><p> 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p><p> 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p> ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p><pre><code>var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined</code></pre><p>   上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。</p><h1 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h1><p>ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p><p>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。<br>浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。<br>Node 里面，顶层对象是global，但其他环境都不支持。<br>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</p><p>全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。<br>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。<br>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。<br>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p><p>// 方法一</p><pre><code>(typeof window !== &apos;undefined&apos;   ? window   : (typeof process === &apos;object&apos; &amp;&amp;      typeof require === &apos;function&apos; &amp;&amp;      typeof global === &apos;object&apos;)     ? global     : this);</code></pre><p>// 方法二</p><pre><code>var getGlobal = function () {  if (typeof self !== &apos;undefined&apos;) { return self; }  if (typeof window !== &apos;undefined&apos;) { return window; }  if (typeof global !== &apos;undefined&apos;) { return global; }  throw new Error(&apos;unable to locate global object&apos;);};</code></pre><p>现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。</p><p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。</p><pre><code>// CommonJS的写法require(&apos;system.global/shim&apos;)();// ES6模块的写法import shim from &apos;system.global/shim&apos;; shim();</code></pre><p>  上面代码可以保证各种环境里面，global对象都是存在的。</p><pre><code>// CommonJS的写法var global = require(&apos;system.global&apos;)();// ES6模块的写法import getGlobal from &apos;system.global&apos;;const global = getGlobal();</code></pre><p>   上面代码将顶层对象放入变量global。</p><h1 id="感想："><a href="#感想：" class="headerlink" title="感想："></a>感想：</h1><p>存在即合理 只是一个说辞 我们需要做的是不断的完善它，让它真的合理。毕竟罗马不是一日建成的！   </p><p> 这里有<a href="https://www.jianshu.com/p/4e9cd99ecbf5" target="_blank" rel="noopener">var、let、const 区别？</a>详尽对比和分析，希望可以帮你更好的理解。</p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;顶层对象的属性&quot;&gt;&lt;a href=&quot;#顶层对象的属性&quot; class=&quot;headerlink&quot; title=&quot;顶层对象的属性&quot;&gt;&lt;/a&gt;顶层对象的属性&lt;/h1&gt;&lt;p&gt;顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/categories/javascript/es6/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6之let 和 const</title>
    <link href="https://libaibuzai.github.io/2018/06/22/es6%E4%B9%8Blet-%E5%92%8C-const/"/>
    <id>https://libaibuzai.github.io/2018/06/22/es6之let-和-const/</id>
    <published>2018-06-21T16:00:00.000Z</published>
    <updated>2019-04-18T02:08:41.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h1><p>##let特性：</p><p>   ###1.只在let命令所在的代码块内有效。</p><p>  a.</p><pre><code>{  let a = 10;  var b = 1;}a // ReferenceError: a is not defined.b // 1</code></pre><p>  b. （let 与 for循环的用法） 要求必须 等let声明语句执行完之后，变量才能使用，不然会报Uncaught ReferenceError错误。</p><pre><code>var a = [];for (let i = 0; i &lt; 10; i++) {  a[i] = function () {    console.log(i);  };}a[6](); // 6  如同for 循环里产生了10次i的循环并没有被更新a[2](); // 2a[4](); // 4a[7](); // 7a[0](); // 0</code></pre><p>  #2.不存在变量提升 </p><pre><code>// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; </code></pre><p>  ###3.暂时性死区</p><pre><code>console.log(aicoder);    // 错误：Uncaught ReferenceError ...let aicoder = &apos;aicoder.com&apos;;// 这里就可以安全使用aicoder</code></pre><p>   有些“死区”比较隐蔽，不太容易发现。</p><pre><code>function bar(x = y, y = 2) {  return [x, y];}bar(); // 报错//因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。</code></pre><blockquote><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>     总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p></blockquote><p>  ###4.let变量不能重复声明</p><pre><code>let a = 0;let a = &apos;sss&apos;;// Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared</code></pre><p>######**ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>######<strong>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p><p>#2. 块级作用域</p><blockquote><p>为什么需要块级作用域？</p></blockquote><blockquote><blockquote><p>第一：内层变量可能会覆盖外层变量。</p></blockquote></blockquote><pre><code>var tmp = new Date();function f() {  console.log(tmp);  if (false) {    var tmp = &quot;hello world&quot;;  }}f(); // undefined</code></pre><blockquote><blockquote><p>第二：用来计数的循环变量泄露为全局变量。</p></blockquote></blockquote><pre><code>var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) {  console.log(s[i]);}console.log(i); // 5</code></pre><p> 块级作用域特点：</p><p>  1.ES6允许块级作用域的任意嵌套。</p><pre><code>{{{{{let insane = 'Hello World'}}}}};</code></pre><p>  2.允许在块级作用域之中声明函数。</p><pre><code>// ES6严格模式&apos;use strict&apos;;if (true) {  function f() {}}// 不报错</code></pre><blockquote><p>ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p></blockquote><blockquote><blockquote><blockquote><p>特别注意：<br> ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p></blockquote></blockquote></blockquote><pre><code>// 不报错&apos;use strict&apos;;if (true) {  function f() {}}// 报错&apos;use strict&apos;;if (true)  function f() {}</code></pre><p>#const命令<br>  1.const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><pre><code>const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable.</code></pre><p>  2.const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><pre><code>const foo;// SyntaxError: Missing initializer in const declaration</code></pre><p>  3.const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p><pre><code>if (true) {  const MAX = 5;}MAX // Uncaught ReferenceError: MAX is not defined</code></pre><ol start="4"><li><p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><p>if (true) {<br> console.log(MAX); // ReferenceError<br> const MAX = 5;<br>}</p></li><li><p>const声明的常量，也与let一样不可重复声明。</p><p>var message = “Hello!”;<br>let age = 25;</p><p>// 以下两行都会报错<br>const message = “Goodbye!”;<br>const age = 30;</p><p>6.对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</p><p>const foo = {};<br>foo.prop = 123;</p><p>foo.prop<br>// 123</p><p>foo = {}; // TypeError: “foo” is read-only</p><p>下面是另一个例子（可以为其添加新属性。）</p><p>const a = [];<br>a.push(‘Hello’); // 可执行<br>a.length = 0;    // 可执行<br>a = [‘Dave’];    // 报错</p><blockquote><p>ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。</p></blockquote></li></ol><h1 id="感想："><a href="#感想：" class="headerlink" title="感想："></a>感想：</h1><p>明白了前辈们对javascript的不断的优化的心情，感谢他们的贡献我将好好细读文档。不服厚爱！   </p><p> 这里有<a href="https://www.jianshu.com/p/4e9cd99ecbf5" target="_blank" rel="noopener">var、let、const 区别？</a>详尽对比和分析</p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;let-命令&quot;&gt;&lt;a href=&quot;#let-命令&quot; class=&quot;headerlink&quot; title=&quot;let 命令&quot;&gt;&lt;/a&gt;let 命令&lt;/h1&gt;&lt;p&gt;##let特性：&lt;/p&gt;
&lt;p&gt;   ###1.只在let命令所在的代码块内有效。&lt;/p&gt;
&lt;p&gt;  a.&lt;
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/categories/javascript/es6/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6之变量的解构赋值</title>
    <link href="https://libaibuzai.github.io/2018/06/20/es6%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>https://libaibuzai.github.io/2018/06/20/es6之变量的解构赋值/</id>
    <published>2018-06-19T16:00:00.000Z</published>
    <updated>2019-04-18T02:28:08.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-变量的解构赋值"><a href="#ES6-变量的解构赋值" class="headerlink" title="ES6 变量的解构赋值"></a>ES6 变量的解构赋值</h1><h1 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>以前，为变量赋值，只能直接指定值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 2;</span><br><span class="line">var c = 3;</span><br></pre></td></tr></table></figure><p>ES6允许写成下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var [a, b, c] = [1, 2, 3];</span><br></pre></td></tr></table></figure><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class="line">foo // 1</span><br><span class="line">bar // 2</span><br><span class="line">baz // 3</span><br><span class="line"></span><br><span class="line">let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];</span><br><span class="line">third // &quot;baz&quot;</span><br><span class="line"></span><br><span class="line">let [x, , y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line">let [head, ...tail] = [1, 2, 3, 4];</span><br><span class="line">head // 1</span><br><span class="line">tail // [2, 3, 4]</span><br><span class="line"></span><br><span class="line">let [x, y, ...z] = [&apos;a&apos;];</span><br><span class="line">x // &quot;a&quot;</span><br><span class="line">y // undefined</span><br><span class="line">z // []</span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值就等于undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var [foo] = [];</span><br><span class="line">var [bar, foo] = [1];</span><br></pre></td></tr></table></figure></p><p>以上两种情况都属于解构不成功，foo的值都会等于undefined。</p><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let [x, y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line"></span><br><span class="line">let [a, [b], d] = [1, [2, 3], 4];</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">d // 4</span><br></pre></td></tr></table></figure><p>上面两个例子，都属于不完全解构，但是可以成功。</p><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">let [foo] = 1;</span><br><span class="line">let [foo] = false;</span><br><span class="line">let [foo] = NaN;</span><br><span class="line">let [foo] = undefined;</span><br><span class="line">let [foo] = null;</span><br><span class="line">let [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。</p><p>解构赋值不仅适用于var命令，也适用于let和const命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var [v1, v2, ..., vN ] = array;</span><br><span class="line">let [v1, v2, ..., vN ] = array;</span><br><span class="line">const [v1, v2, ..., vN ] = array;</span><br></pre></td></tr></table></figure><p>对于Set结构，也可以使用数组的解构赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [x, y, z] = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);</span><br><span class="line">x // &quot;a&quot;</span><br></pre></td></tr></table></figure><p>事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* fibs() &#123;</span><br><span class="line">  var a = 0;</span><br><span class="line">  var b = 1;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    yield a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth // 5</span><br></pre></td></tr></table></figure><p>上面代码中，fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。</p><p>默认值<br>解构赋值允许指定默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var [foo = true] = [];</span><br><span class="line">foo // true</span><br><span class="line"></span><br><span class="line">[x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;</span><br><span class="line">[x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos;</span><br></pre></td></tr></table></figure></p><p>注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var [x = 1] = [undefined];</span><br><span class="line">x // 1</span><br><span class="line"></span><br><span class="line">var [x = 1] = [null];</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure><p>上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  console.log(&apos;aaa&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let [x = f()] = [1];</span><br></pre></td></tr></table></figure><p>上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let x;</span><br><span class="line">if ([1][0] === undefined) &#123;</span><br><span class="line">  x = f();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  x = [1][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let [x = 1, y = x] = [];     // x=1; y=1</span><br><span class="line">let [x = 1, y = x] = [2];    // x=2; y=2</span><br><span class="line">let [x = 1, y = x] = [1, 2]; // x=1; y=2</span><br><span class="line">let [x = y, y = 1] = [];     // ReferenceError</span><br></pre></td></tr></table></figure><p>上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。</p><p>对象的解构赋值<br>解构不仅可以用于数组，还可以用于对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br></pre></td></tr></table></figure></p><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br><span class="line"></span><br><span class="line">var &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">baz // undefined</span><br></pre></td></tr></table></figure></p><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。</p><p>如果变量名与属性名不一致，必须写成下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;</span><br><span class="line">baz // &quot;aaa&quot;</span><br><span class="line"></span><br><span class="line">let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;</span><br><span class="line">let &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f // &apos;hello&apos;</span><br><span class="line">l // &apos;world&apos;</span><br></pre></td></tr></table></figure></p><p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var &#123; foo: foo, bar: bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</span><br><span class="line"></span><br><span class="line">var &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">baz // &quot;aaa&quot;</span><br><span class="line">foo // error: foo is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p><p>注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let foo;</span><br><span class="line">let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration &quot;foo&quot;</span><br><span class="line"></span><br><span class="line">let baz;</span><br><span class="line">let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration &quot;baz&quot;</span><br></pre></td></tr></table></figure></p><p>上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let foo;</span><br><span class="line">(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功</span><br><span class="line"></span><br><span class="line">let baz;</span><br><span class="line">(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功</span><br></pre></td></tr></table></figure></p><p>上面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。</p><p>和数组一样，解构也可以用于嵌套结构的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    &apos;Hello&apos;,</span><br><span class="line">    &#123; y: &apos;World&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // &quot;Hello&quot;</span><br><span class="line">y // &quot;World&quot;</span><br></pre></td></tr></table></figure></p><p>注意，这时p是模式，不是变量，因此不会被赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: 1,</span><br><span class="line">      column: 5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line // 1</span><br><span class="line">loc  // error: loc is undefined</span><br><span class="line">start // error: start is undefined</span><br></pre></td></tr></table></figure></p><p>上面代码中，只有line是变量，loc和start都是模式，不会被赋值。</p><p>下面是嵌套赋值的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">let arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);</span><br><span class="line"></span><br><span class="line">obj // &#123;prop:123&#125;</span><br><span class="line">arr // [true]</span><br></pre></td></tr></table></figure></p><p>对象的解构也可以指定默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var &#123;x = 3&#125; = &#123;&#125;;</span><br><span class="line">x // 3</span><br><span class="line"></span><br><span class="line">var &#123;x, y = 5&#125; = &#123;x: 1&#125;;</span><br><span class="line">x // 1</span><br><span class="line">y // 5</span><br><span class="line"></span><br><span class="line">var &#123;x:y = 3&#125; = &#123;&#125;;</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line">var &#123;x:y = 3&#125; = &#123;x: 5&#125;;</span><br><span class="line">y // 5</span><br><span class="line"></span><br><span class="line">var &#123; message: msg = &apos;Something went wrong&apos; &#125; = &#123;&#125;;</span><br><span class="line">msg // &quot;Something went wrong&quot;</span><br></pre></td></tr></table></figure></p><p>默认值生效的条件是，对象的属性值严格等于undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var &#123;x = 3&#125; = &#123;x: undefined&#125;;</span><br><span class="line">x // 3</span><br><span class="line"></span><br><span class="line">var &#123;x = 3&#125; = &#123;x: null&#125;;</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure></p><p>上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。</p><p>如果解构失败，变量的值等于undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var &#123;foo&#125; = &#123;bar: &apos;baz&apos;&#125;;</span><br><span class="line">foo // undefined</span><br></pre></td></tr></table></figure></p><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">var &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &apos;baz&apos;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var _tmp = &#123;baz: &apos;baz&apos;&#125;;</span><br><span class="line">_tmp.foo.bar // 报错</span><br></pre></td></tr></table></figure></p><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 错误的写法</span><br><span class="line">var x;</span><br><span class="line">&#123;x&#125; = &#123;x: 1&#125;;</span><br><span class="line">// SyntaxError: syntax error</span><br></pre></td></tr></table></figure></p><p>上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 正确的写法</span><br><span class="line">(&#123;x&#125; = &#123;x: 1&#125;);</span><br></pre></td></tr></table></figure><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p><p>解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [true, false]);</span><br><span class="line">(&#123;&#125; = &apos;abc&apos;);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><pre><code>let { log, sin, cos } = Math;</code></pre><p>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">var &#123;0 : first, [arr.length - 1] : last&#125; = arr;</span><br><span class="line">first // 1</span><br><span class="line">last // 3</span><br></pre></td></tr></table></figure><p>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。</p><p>字符串的解构赋值<br>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const [a, b, c, d, e] = &apos;hello&apos;;</span><br><span class="line">a // &quot;h&quot;</span><br><span class="line">b // &quot;e&quot;</span><br><span class="line">c // &quot;l&quot;</span><br><span class="line">d // &quot;l&quot;</span><br><span class="line">e // &quot;o&quot;</span><br></pre></td></tr></table></figure></p><p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let &#123;length : len&#125; = &apos;hello&apos;;</span><br><span class="line">len // 5</span><br></pre></td></tr></table></figure></p><p>数值和布尔值的解构赋值<br>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let &#123;toString: s&#125; = 123;</span><br><span class="line">s === Number.prototype.toString // true</span><br><span class="line"></span><br><span class="line">let &#123;toString: s&#125; = true;</span><br><span class="line">s === Boolean.prototype.toString // true</span><br></pre></td></tr></table></figure></p><p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p><p>解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let &#123; prop: x &#125; = undefined; // TypeError</span><br><span class="line">let &#123; prop: y &#125; = null; // TypeError</span><br></pre></td></tr></table></figure></p><p>函数参数的解构赋值<br>函数的参数也可以使用解构赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function add([x, y])&#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([1, 2]); // 3</span><br></pre></td></tr></table></figure></p><p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p><p>下面是另一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);</span><br><span class="line">// [ 3, 7 ]</span><br></pre></td></tr></table></figure></p><p>函数参数的解构也可以使用默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, 0]</span><br><span class="line">move(&#123;&#125;); // [0, 0]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure></p><p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</p><p>注意，下面的写法会得到不一样的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, undefined]</span><br><span class="line">move(&#123;&#125;); // [undefined, undefined]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure></p><p>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p><p>undefined就会触发函数参数的默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[1, undefined, 3].map((x = &apos;yes&apos;) =&gt; x);</span><br><span class="line">// [ 1, &apos;yes&apos;, 3 ]</span><br></pre></td></tr></table></figure></p><p>圆括号问题<br>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p><p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p><p>不能使用圆括号的情况<br>以下三种解构赋值不得使用圆括号。</p><p>（1）变量声明语句中，不能带有圆括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 全部报错</span><br><span class="line">var [(a)] = [1];</span><br><span class="line"></span><br><span class="line">var &#123;x: (c)&#125; = &#123;&#125;;</span><br><span class="line">var (&#123;x: c&#125;) = &#123;&#125;;</span><br><span class="line">var &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line">var &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;</span><br></pre></td></tr></table></figure></p><p>上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p><p>（2）函数参数中，模式不能带有圆括号。</p><p>函数参数也属于变量声明，因此不能带有圆括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function f([(z)]) &#123; return z; &#125;</span><br></pre></td></tr></table></figure></p><p>（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line">(&#123; p: a &#125;) = &#123; p: 42 &#125;;</span><br><span class="line">([a]) = [5];</span><br></pre></td></tr></table></figure><p>上面代码将整个模式放在圆括号之中，导致报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><p>上面代码将嵌套模式的一层，放在圆括号之中，导致报错。</p><p>可以使用圆括号的情况<br>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[(b)] = [3]; // 正确</span><br><span class="line">(&#123; p: (d) &#125; = &#123;&#125;); // 正确</span><br><span class="line">[(parseInt.prop)] = [3]; // 正确</span><br></pre></td></tr></table></figure></p><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p><p>用途<br>变量的解构赋值用途很多。</p><p>（1）交换变量的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p><p>（2）从函数返回多个值</p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 返回一个数组</span><br><span class="line"></span><br><span class="line">function example() &#123;</span><br><span class="line">  return [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">var [a, b, c] = example();</span><br><span class="line"></span><br><span class="line">// 返回一个对象</span><br><span class="line"></span><br><span class="line">function example() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><p>（3）函数参数的定义</p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 参数是一组有次序的值</span><br><span class="line">function f([x, y, z]) &#123; ... &#125;</span><br><span class="line">f([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 参数是一组无次序的值</span><br><span class="line">function f(&#123;x, y, z&#125;) &#123; ... &#125;</span><br><span class="line">f(&#123;z: 3, y: 2, x: 1&#125;);</span><br></pre></td></tr></table></figure><p>（4）提取JSON数据</p><p>解构赋值对提取JSON对象中的数据，尤其有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: &quot;OK&quot;,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.log(id, status, number);</span><br><span class="line">// 42, &quot;OK&quot;, [867, 5309]</span><br></pre></td></tr></table></figure></p><p>上面代码可以快速提取JSON数据的值。</p><p>（5）函数参数的默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = function (url, &#123;</span><br><span class="line">  async = true,</span><br><span class="line">  beforeSend = function () &#123;&#125;,</span><br><span class="line">  cache = true,</span><br><span class="line">  complete = function () &#123;&#125;,</span><br><span class="line">  crossDomain = false,</span><br><span class="line">  global = true,</span><br><span class="line">  // ... more config</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  // ... do stuff</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p><p>（6）遍历Map结构</p><p>任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var map = new Map();</span><br><span class="line">map.set(&apos;first&apos;, &apos;hello&apos;);</span><br><span class="line">map.set(&apos;second&apos;, &apos;world&apos;);</span><br><span class="line"></span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">  console.log(key + &quot; is &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br></pre></td></tr></table></figure></p><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 获取键名</span><br><span class="line">for (let [key] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取键值</span><br><span class="line">for (let [,value] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（7）输入模块的指定方法</p><p>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p><p><code>`</code>const { SourceMapConsumer, SourceNode } = require(“source-map”);</p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6-变量的解构赋值&quot;&gt;&lt;a href=&quot;#ES6-变量的解构赋值&quot; class=&quot;headerlink&quot; title=&quot;ES6 变量的解构赋值&quot;&gt;&lt;/a&gt;ES6 变量的解构赋值&lt;/h1&gt;&lt;h1 id=&quot;数组的解构赋值&quot;&gt;&lt;a href=&quot;#数组的解构赋值&quot; c
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/categories/javascript/es6/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6之编码规范</title>
    <link href="https://libaibuzai.github.io/2018/06/18/es6%E4%B9%8B%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://libaibuzai.github.io/2018/06/18/es6之编码规范/</id>
    <published>2018-06-17T16:00:00.000Z</published>
    <updated>2019-04-18T02:08:41.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h1><p>##let特性：</p><p>   ###1.只在let命令所在的代码块内有效。</p><p>  a.</p><pre><code>{  let a = 10;  var b = 1;}a // ReferenceError: a is not defined.b // 1</code></pre><p>  b. （let 与 for循环的用法） 要求必须 等let声明语句执行完之后，变量才能使用，不然会报Uncaught ReferenceError错误。</p><pre><code>var a = [];for (let i = 0; i &lt; 10; i++) {  a[i] = function () {    console.log(i);  };}a[6](); // 6  如同for 循环里产生了10次i的循环并没有被更新a[2](); // 2a[4](); // 4a[7](); // 7a[0](); // 0</code></pre><p>  #2.不存在变量提升 </p><pre><code>// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; </code></pre><p>  ###3.暂时性死区</p><pre><code>console.log(aicoder);    // 错误：Uncaught ReferenceError ...let aicoder = &apos;aicoder.com&apos;;// 这里就可以安全使用aicoder</code></pre><p>   有些“死区”比较隐蔽，不太容易发现。</p><pre><code>function bar(x = y, y = 2) {  return [x, y];}bar(); // 报错//因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。</code></pre><blockquote><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>     总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p></blockquote><p>  ###4.let变量不能重复声明</p><pre><code>let a = 0;let a = &apos;sss&apos;;// Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared</code></pre><p>######**ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>######<strong>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p><p>#2. 块级作用域</p><blockquote><p>为什么需要块级作用域？</p></blockquote><blockquote><blockquote><p>第一：内层变量可能会覆盖外层变量。</p></blockquote></blockquote><pre><code>var tmp = new Date();function f() {  console.log(tmp);  if (false) {    var tmp = &quot;hello world&quot;;  }}f(); // undefined</code></pre><blockquote><blockquote><p>第二：用来计数的循环变量泄露为全局变量。</p></blockquote></blockquote><pre><code>var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) {  console.log(s[i]);}console.log(i); // 5</code></pre><p> 块级作用域特点：</p><p>  1.ES6允许块级作用域的任意嵌套。</p><pre><code>{{{{{let insane = 'Hello World'}}}}};</code></pre><p>  2.允许在块级作用域之中声明函数。</p><pre><code>// ES6严格模式&apos;use strict&apos;;if (true) {  function f() {}}// 不报错</code></pre><blockquote><p>ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p></blockquote><blockquote><blockquote><blockquote><p>特别注意：<br> ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p></blockquote></blockquote></blockquote><pre><code>// 不报错&apos;use strict&apos;;if (true) {  function f() {}}// 报错&apos;use strict&apos;;if (true)  function f() {}</code></pre><p>#const命令<br>  1.const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><pre><code>const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable.</code></pre><p>  2.const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><pre><code>const foo;// SyntaxError: Missing initializer in const declaration</code></pre><p>  3.const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p><pre><code>if (true) {  const MAX = 5;}MAX // Uncaught ReferenceError: MAX is not defined</code></pre><ol start="4"><li><p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><p>if (true) {<br> console.log(MAX); // ReferenceError<br> const MAX = 5;<br>}</p></li><li><p>const声明的常量，也与let一样不可重复声明。</p><p>var message = “Hello!”;<br>let age = 25;</p><p>// 以下两行都会报错<br>const message = “Goodbye!”;<br>const age = 30;</p><p>6.对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</p><p>const foo = {};<br>foo.prop = 123;</p><p>foo.prop<br>// 123</p><p>foo = {}; // TypeError: “foo” is read-only</p><p>下面是另一个例子（可以为其添加新属性。）</p><p>const a = [];<br>a.push(‘Hello’); // 可执行<br>a.length = 0;    // 可执行<br>a = [‘Dave’];    // 报错</p><blockquote><p>ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。</p></blockquote></li></ol><h1 id="感想："><a href="#感想：" class="headerlink" title="感想："></a>感想：</h1><p>明白了前辈们对javascript的不断的优化的心情，感谢他们的贡献我将好好细读文档。不服厚爱！   </p><p> 这里有<a href="https://www.jianshu.com/p/4e9cd99ecbf5" target="_blank" rel="noopener">var、let、const 区别？</a>详尽对比和分析</p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;let-命令&quot;&gt;&lt;a href=&quot;#let-命令&quot; class=&quot;headerlink&quot; title=&quot;let 命令&quot;&gt;&lt;/a&gt;let 命令&lt;/h1&gt;&lt;p&gt;##let特性：&lt;/p&gt;
&lt;p&gt;   ###1.只在let命令所在的代码块内有效。&lt;/p&gt;
&lt;p&gt;  a.&lt;
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/categories/javascript/es6/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/tags/es6/"/>
    
  </entry>
  
</feed>
