<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李白不在</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://libaibuzai.github.io/"/>
  <updated>2019-04-30T14:50:09.405Z</updated>
  <id>https://libaibuzai.github.io/</id>
  
  <author>
    <name>幽僻处的行人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hello LILI</title>
    <link href="https://libaibuzai.github.io/2019/04/30/hello-LILI/"/>
    <id>https://libaibuzai.github.io/2019/04/30/hello-LILI/</id>
    <published>2019-04-30T13:15:16.000Z</published>
    <updated>2019-04-30T14:50:09.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HELLO-LILI"><a href="#HELLO-LILI" class="headerlink" title="HELLO LILI"></a>HELLO LILI</h1><p>lili 这个名字来源于我曾经看过的一个电影 <a href="https://movie.douban.com/subject/2028659/" target="_blank" rel="noopener">《狐狸与我》</a>。</p><p>说的是一个小女孩着迷于一只田间狐狸的故事，她给狐狸起名叫”lili”,她从发现它，着迷于它，引诱它，了解它。就好像我着迷于人工智能。</p><h2 id="LILI是个怎样的形象"><a href="#LILI是个怎样的形象" class="headerlink" title="LILI是个怎样的形象"></a>LILI是个怎样的形象</h2><p>我对于人工智能我所知甚少，我不知道该如何给我心里的这位朋友一个更准确合适的定义。<br>就好像现在我的神经女朋友现在在我身边模仿我敲代码的一举一动，我笑她笑 我动动手指她动动手指，像”LILI”一样。<br>我相信有很多人都希望有一个这样的能够陪伴自己内心的她存在。所以我该如何定义这个朋友呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function person (name,sex,age...) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">    this.age = age;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最初的想法"><a href="#最初的想法" class="headerlink" title="最初的想法"></a>最初的想法</h2><p>既然不知道我该如何去创建她，那就从一个baby开始。</p><ol><li>她会摇头晃脑</li><li>她要会哭。</li><li>会笑</li><li>她要会拉屎。</li><li>她会拉尿。</li><li>她会睁眼 眨眼 闭眼。</li><li>会走路 前进 后退 会跑。</li><li>会伤心</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">person.prototype.speak = function (who,words) &#123;</span><br><span class="line">    console.log(who,&apos;speak &apos;,words);</span><br><span class="line">&#125;</span><br><span class="line">person.prototype.smill = function (who) &#123;</span><br><span class="line">    console.log(who ,&apos;is smilling!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">person.prototype.walk = function (who) &#123;</span><br><span class="line">    console.log(who, &apos;is walking&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LILI-会有哪些喜好？"><a href="#LILI-会有哪些喜好？" class="headerlink" title="LILI 会有哪些喜好？"></a>LILI 会有哪些喜好？</h2><ol><li>她会喜欢听歌吗</li><li>她会喜欢看电影吗</li><li>她喜欢在什么时候听歌？</li><li>她喜欢和谁看电影呢？</li></ol><h2 id="LILI-的能力"><a href="#LILI-的能力" class="headerlink" title="LILI 的能力"></a>LILI 的能力</h2><p>我知道说老师肯定不是太准确。抛去核心硬件如何实现不说，先假设。</p><h3 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h3><p>LILI需要听力，她需要对千万种声音进行识别，分析，判断，并确认是什么发出的。还需要对这些声音做出应对的动作，<br>比如：玻璃杯碎了，发出来声音，如果她看见了 ，如果应对；如果没看见，是否需要走到声音源附近，看见并确认发生了什么事？又该如何应对？</p><h3 id="视力"><a href="#视力" class="headerlink" title="视力"></a>视力</h3><p>需要识别物体，定义物体属性（动物，植物，会移动，不会移动…）<br>分析物体运动，并预判可能风险。</p><h3 id="嗅觉"><a href="#嗅觉" class="headerlink" title="嗅觉"></a>嗅觉</h3><p>分析味道组成，识别味道发出的物体。</p><h3 id="味觉"><a href="#味觉" class="headerlink" title="味觉"></a>味觉</h3><p>识别酸甜苦辣咸的味道，并更新物体属性。</p><h3 id="感觉"><a href="#感觉" class="headerlink" title="感觉"></a>感觉</h3><p>物体是硬的 软的 干的 湿的  记录软硬程度 。</p><blockquote><p>这些能力分别对应复杂的机器学习，深度学习，算法的演进，而现在很多的程序员在做很多类似方面的单独研究，但在未来得此五感者的天下。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我知道上面写的这些，很多逻辑问题，很多现在做不到的事情，但是后来的我总会嘲笑之前的我，无不例外，但这也是未来的我为之前的我感到骄傲的地方，同样从无例外。</p>]]></content>
    
    <summary type="html">
    
      hello LILI
    
    </summary>
    
      <category term="LILI" scheme="https://libaibuzai.github.io/categories/LILI/"/>
    
    
      <category term="LILI" scheme="https://libaibuzai.github.io/tags/LILI/"/>
    
  </entry>
  
  <entry>
    <title>一个新的面试题go()()(&#39;l&#39;)</title>
    <link href="https://libaibuzai.github.io/2019/04/28/%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98go()()(&#39;l&#39;)/"/>
    <id>https://libaibuzai.github.io/2019/04/28/一个新的面试题go()()(&#39;l&#39;)/</id>
    <published>2019-04-28T06:41:01.000Z</published>
    <updated>2019-04-28T10:36:01.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h1><p>不知道 为何好多人都在发这道题，好奇心驱动：👇</p><p><img src="/2019/04/28/一个新的面试题go()()('l')/1.jpeg" alt="图片被外星人抓走了"></p><p>解法：</p><pre><code>var Fc = function() { var str = &apos;g&apos;; var todo = function(a) {  if (a) {   str = `${str}o`;   return `${str}${a}`  } else {   str += &apos;o&apos;; /差一步这个   return todo;  } } return todo;}var go = Fc();console.log(go()()()(&apos;l&apos;));</code></pre>]]></content>
    
    <summary type="html">
    
      一个新的面试题go()()(&#39;l&#39;)
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Mac屏保开发之iScreenSaver</title>
    <link href="https://libaibuzai.github.io/2019/04/28/Mac%E5%B1%8F%E4%BF%9D%E5%BC%80%E5%8F%91%E4%B9%8BiScreenSaver/"/>
    <id>https://libaibuzai.github.io/2019/04/28/Mac屏保开发之iScreenSaver/</id>
    <published>2019-04-28T02:52:30.000Z</published>
    <updated>2019-04-28T03:28:18.854Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br><a href="https://github.com/libaibuzai/iScreenSaver" target="_blank"><br><img align="center" width="450" alt="A magic screen saver, a lot of fun. You can also customize your own screen saver." src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Header.gif"><br></a><br></p><p>大致思路;</p><ol><li>主程序使用 macOS 对应 kit 挂一个webview, 输入单文件 html document(html+js+css)</li><li>解析对应 document 并 load 到 webview 展示</li></ol><p>子程序从本地文件夹 load codepen 相关文件并根据codepen css js 引用规则做解析, 合并为单文件, 复制粘贴到 screen saver 里, load</p><h3 id="iScreenSaver-A-Screen-Saver-for-Mac-OSX-10-8"><a href="#iScreenSaver-A-Screen-Saver-for-Mac-OSX-10-8" class="headerlink" title="iScreenSaver - A Screen Saver for Mac OSX 10.8+"></a>iScreenSaver - A Screen Saver for Mac OSX 10.8+</h3><p>一个神奇的的屏幕保护程序，内置了30多种酷炫的屏幕保护。你还可以创建属于自己的屏幕保护！</p><p align="center"><img width="320" align="center" alt="Screen saver settings" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Settings.png"></p><h3 id="如何安装iScreenSaver"><a href="#如何安装iScreenSaver" class="headerlink" title="如何安装iScreenSaver"></a>如何安装iScreenSaver</h3><ol><li><strong><a href="https://github.com/titman/iScreenSaver/releases/" target="_blank" rel="noopener">下载最新的安装包 (名字一般为iScreenSaver.x.xx.saver.zip)</a></strong></li><li>解压文件</li><li>双击安装</li><li>打开 <code>系统偏好设置 &gt; 桌面与屏幕保护程序 &gt; 屏幕保护程序</code></li><li>选择 “iScreenSaver” (安装完后一般在列表最底部) 然后点击 <code>屏幕保护程序选项</code> 选择你喜欢的屏幕保护程序! 或者，你也可以自己自定义一个！</li></ol><pre><code>iScreenSaver支持屏保文件是HTML的 必须js，css，html在同一个文件内 （下面有代码合并工具）</code></pre><h3 id="安装Pen简易合成工具（可以不必安装只是个代码合并工具）"><a href="#安装Pen简易合成工具（可以不必安装只是个代码合并工具）" class="headerlink" title="安装Pen简易合成工具（可以不必安装只是个代码合并工具）"></a>安装Pen简易合成工具（可以不必安装只是个代码合并工具）</h3><ol><li><strong><a href="https://github.com/titman/iScreenSaver/releases/" target="_blank" rel="noopener">下载最新的安装包 (名字一般为CodePenSourceCodeFileMergeTool.dmg)</a></strong></li><li>解压文件并双击</li><li>双击：CodePenSourceCodeFileMergeTool.app</li><li>安装工具指示操作就可以了 </li></ol><h3 id="其中的一些屏幕保护程序截图"><a href="#其中的一些屏幕保护程序截图" class="headerlink" title="其中的一些屏幕保护程序截图"></a>其中的一些屏幕保护程序截图</h3><p><code>[Square lightning]</code></p><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview1.gif"></p><br><code>[Sheep]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview7.gif"></p><br><code>[Lonely moon]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview6.gif"></p><br><code>[Hearts]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview5.gif"></p><br><code>[Jellyfish]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview4.gif"></p><br><code>[Yellow Square]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview8.gif"></p><br><code>[Virus]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview3.gif"></p><br><code>[Plankton]</code><p align="left"><img width="320" align="center" alt="Preview" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/Preview2.gif"></p><p></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><strong>自动加载最新的屏幕保护程序:</strong> 作者会增加新的屏幕保护程序在推荐列表</li><li><strong>自定义属于你自己的屏幕保护程序:</strong> 如果你有一些酷炫的 <code>HTML / URL / JAVASCRIPT</code>, 你可以把它作为一个屏幕保护程序.</li></ul><p align="center"><img width="300" align="center" alt="Costom saver" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/CustomSaver2.gif"> <img width="300" align="center" alt="Costom saver" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/CustomSaver1.gif"></p><h3 id="Compatibility"><a href="#Compatibility" class="headerlink" title="Compatibility"></a>Compatibility</h3><p>最低支持 Mac OSX 10.8+</p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><blockquote><p>我不能安装iScreenSaver? <img width="20" align="center" alt="Error" src="https://raw.githubusercontent.com/titman/Pictures-of-the-warehouse/master/iScreenSaver/InstallError.png"></p></blockquote><p>请打开 <code>系统偏好设置 &gt; 安全性与隐私 &gt; 仍然打开</code>.</p><blockquote><p>有一些屏幕保护程序黑屏?</p></blockquote><p>请等待几秒钟，因为程序需要加载一些必要的js文件.</p><blockquote><p>我能找到其他酷炫的屏幕保护程序文件吗?</p></blockquote><p>请进入<a href="https://github.com/libaibuzai/iScreenSaver/issues" target="_blank" rel="noopener">反馈区</a> 一起讨论, 或者进入<a href="http://codepen.io/" target="_blank" rel="noopener">CodePen</a>搜索你喜欢的动画</p><blockquote><p>它的原理是什么?</p></blockquote><p>iScreenSaver使用经过深度优化的WebView来加载HTML文件, 高性能并且帧数有保证, 你也不必担心会耗电, 它与平常的保护程序没什么两样.</p><h3 id="Community"><a href="#Community" class="headerlink" title="Community"></a>Community</h3><ul><li><strong>发现Bug?</strong> <a href="https://github.com/libaibuzai/iScreenSaver/issues/new" target="_blank" rel="noopener">Open an issue</a>. Try to be as specific as possible.</li><li><strong>想增加一些功能?</strong> <a href="https://github.com/libaibuzai/iScreenSaver/issues/new" target="_blank" rel="noopener">Open an issue</a>. Tell me why this feature would be useful, and why you and others would want it.</li></ul><h3 id="Change-log"><a href="#Change-log" class="headerlink" title="Change log"></a>Change log</h3><ul><li>May 27th, 2017 - 1.04: 支持本地屏幕保护编辑.</li><li>May 23th, 2017 - 1.03: First release.</li></ul><h3 id="License"><a href="#License" class="headerlink" title="License"></a>License</h3><p>本项目是<strong>协助传播</strong><br>如果我侵犯了你的合法权益, 请及时联系我!</p>]]></content>
    
    <summary type="html">
    
      Mac屏保开发之iScreenSaver
    
    </summary>
    
      <category term="Mac" scheme="https://libaibuzai.github.io/categories/Mac/"/>
    
      <category term="屏保开发" scheme="https://libaibuzai.github.io/categories/Mac/%E5%B1%8F%E4%BF%9D%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Mac" scheme="https://libaibuzai.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>把酒问月</title>
    <link href="https://libaibuzai.github.io/2019/04/26/%E6%8A%8A%E9%85%92%E9%97%AE%E6%9C%88/"/>
    <id>https://libaibuzai.github.io/2019/04/26/把酒问月/</id>
    <published>2019-04-26T05:53:24.000Z</published>
    <updated>2019-04-28T02:31:51.971Z</updated>
    
    <content type="html"><![CDATA[<p>[唐] 李白</p><p>青天有月来几时，我今停杯一问之：<br>人攀明月不可得，月行却与人相随？<br>皎如飞镜临丹阙，绿烟灭尽清辉发？<br>但见宵从海上来，宁知晓向云间没？<br>白兔捣药秋复春，嫦娥孤栖与谁邻？<br><strong>今人不见古时月，今月曾经照古人。<br>古人今人若流水，共看明月皆如此。</strong><br>唯愿当歌对酒时，月光长照金樽里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[唐] 李白&lt;/p&gt;
&lt;p&gt;青天有月来几时，我今停杯一问之：&lt;br&gt;人攀明月不可得，月行却与人相随？&lt;br&gt;皎如飞镜临丹阙，绿烟灭尽清辉发？&lt;br&gt;但见宵从海上来，宁知晓向云间没？&lt;br&gt;白兔捣药秋复春，嫦娥孤栖与谁邻？&lt;br&gt;&lt;strong&gt;今人不见古时月，今月曾经照古人
      
    
    </summary>
    
      <category term="诗词" scheme="https://libaibuzai.github.io/categories/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="诗" scheme="https://libaibuzai.github.io/categories/%E8%AF%97%E8%AF%8D/%E8%AF%97/"/>
    
    
      <category term="诗词" scheme="https://libaibuzai.github.io/tags/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="诗" scheme="https://libaibuzai.github.io/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 之 原型和继承</title>
    <link href="https://libaibuzai.github.io/2019/04/24/Javascript-%E4%B9%8B-%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/"/>
    <id>https://libaibuzai.github.io/2019/04/24/Javascript-之-原型和继承/</id>
    <published>2019-04-24T06:32:03.000Z</published>
    <updated>2019-04-28T02:31:51.970Z</updated>
    
    <content type="html"><![CDATA[<hr><p>layout:         post<br>title:          Javascript 之 原型和继承<br>subtitle:       “JS this”<br>date:           2019-04-24 14:32:03<br>author:         “幽僻处的行人”<br>header-mask: 0.3<br>categories:</p><pre><code>- javascript</code></pre><p>catalog:    true</p><p>tags:</p><pre><code>- javascript</code></pre><hr><h1 id="等待研究"><a href="#等待研究" class="headerlink" title="等待研究"></a>等待研究</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;layout:         post&lt;br&gt;title:          Javascript 之 原型和继承&lt;br&gt;subtitle:       “JS this”&lt;br&gt;date:           2019-04-24 14:32:03&lt;br&gt;au
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>javascript 之 this</title>
    <link href="https://libaibuzai.github.io/2019/04/19/javascript-%E4%B9%8B-this/"/>
    <id>https://libaibuzai.github.io/2019/04/19/javascript-之-this/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-28T02:31:51.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="等待研究"><a href="#等待研究" class="headerlink" title="等待研究"></a>等待研究</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;等待研究&quot;&gt;&lt;a href=&quot;#等待研究&quot; class=&quot;headerlink&quot; title=&quot;等待研究&quot;&gt;&lt;/a&gt;等待研究&lt;/h1&gt;
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS之事件循环机制和任务队列</title>
    <link href="https://libaibuzai.github.io/2019/04/19/JS%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    <id>https://libaibuzai.github.io/2019/04/19/JS之事件循环机制和任务队列/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-28T09:15:43.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的认识事件循环"><a href="#简单的认识事件循环" class="headerlink" title="简单的认识事件循环"></a>简单的认识事件循环</h1><p>先看一段代码：（先热个身）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&apos;promise1&apos;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure></p><p>打印顺序是什么？ 正确答案是：script start, script end, promise1, promise2, setTimeout </p><p>没关系 继续看 </p><p>需要知道的专业名词术语：</p><pre><code>synchronous：同步任务asynchronous：异步任务task queue/callback queue：任务队列execution context stack：执行栈heap：堆stack：栈macro-task：宏任务micro-task：微任务</code></pre><p>首先我们还要知道两点：<br>JavaScript是单线程的语言<br>Event Loop是javascript的执行机制</p><p>异步任务包括：宏任务 和 微任务</p><p>同步任务：promise内的函数属于同步 .then()内部才属于异步微服务</p><p>new Promise(function(resolve) {<br>    console.log(‘7’);  //属于同步任务<br>    resolve();<br>}).then(function() {<br>    console.log(‘8’)   //属于异步微服务<br>})</p><p>宏任务：</p><pre><code>包括整体代码scriptsetTimeoutsetIntervalsetImmediate</code></pre><p>微任务：</p><pre><code>原生Promise(有些实现的promise将then方法放到了宏任务中)process.nextTick （process.nextTick(callback)类似node.js版的&quot;setTimeout&quot;）Object.observe(已废弃)MutationObserver</code></pre><p>记住就行了。</p><p>事件循环规则：</p><p>骚年 先接我八字真言：<strong>先同后异，先微后宏</strong></p><p>实例：</p><pre><code>Promise.resolve().then(()=&gt;{   console.log(&apos;Promise1&apos;)     setTimeout(()=&gt;{    console.log(&apos;setTimeout2&apos;)    Promise.resolve().then(()=&gt;{      console.log(&apos;Promise3&apos;)        setTimeout(()=&gt;{        Promise.resolve().then(()=&gt;{          console.log(&apos;Promise5&apos;)            setTimeout(()=&gt;{            console.log(&apos;setTimeout6&apos;)          },0)        })        console.log(&apos;setTimeout4&apos;)      },0)    })  },0)})</code></pre><ol><li><p>先从上到下执行<strong>同步任务</strong>并全部执行完成</p></li><li><p><strong>查找</strong>异步任务并<strong>分配</strong>到微任务列表 和 宏任务列表 （每个列表里<strong>先进栈先执行</strong>）</p></li><li><p>先<strong>执行</strong>微服务，并且<strong>查找</strong>微服务内部的 异步任务然后<strong>分配</strong>到微任务列表 和 宏任务列表</p></li><li><p>再<strong>执行</strong>宏任务，并且<strong>查找</strong>微服务内部的 异步任务然后<strong>分配</strong>到微任务列表 和 宏任务列表</p></li><li><p>既然是事件循环就不是一次就执行完毕了的，因为异步任务会有嵌套，最外层事件最先暴露出来，首先进入<strong>第一次循环</strong></p></li><li><p>再先<strong>执行</strong>微服务，并查找，分配</p></li><li><p>再<strong>执行</strong>宏任务，并查找，分配</p></li><li><p><strong>依次循环</strong>直至没有异步任务</p></li><li><p>执行结束</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">  console.log(&apos;Promise1&apos;)  </span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;setTimeout2&apos;)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">  console.log(&apos;setTimeout1&apos;)</span><br><span class="line">  Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;Promise2&apos;)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,0)</span><br></pre></td></tr></table></figure><p>第一回合 列出所有异步事件并逐个分配到宏服务和微任务里去，然后执行 先微后宏</p><pre><code>微：promise1   宏：setTimeout1先打印Promise1，setTimeout2进宏任务列表setTimeout1，Promise2进微任务列表</code></pre><p>第二回合 执行异步列表 先微后宏</p><pre><code>先打印Promise2，再打印setTimeout2，</code></pre><p>到这里是不是有个大概的了解了，测验来了：（先用纸笔根据自己理解先答一遍，然后再看答案）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;1&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&apos;3&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&apos;4&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;5&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">    console.log(&apos;6&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;7&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;9&apos;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&apos;10&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&apos;11&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;12&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一轮事件循环流程分析如下：</p><ol><li>整体script作为第一个宏任务进入主线程，遇到console.log，输出1。</li><li>遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。</li><li>遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。</li><li>遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。</li><li>又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。</li></ol><table><thead><tr><th style="text-align:center">宏任务Event Queue</th><th style="text-align:center">微任务Event Queue</th></tr></thead><tbody><tr><td style="text-align:center">setTimeout1</td><td style="text-align:center">process1</td></tr><tr><td style="text-align:center">setTimeout2</td><td style="text-align:center">then1</td></tr></tbody></table><ol start="6"><li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</li></ol><p>我们发现了process1和then1两个微任务。</p><ol start="7"><li>执行process1,输出6。</li><li>执行then1，输出8。</li></ol><p>好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始：</p><ol start="9"><li>首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。</li><li>new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2</li></ol><table><thead><tr><th style="text-align:center">宏任务Event Queue</th><th style="text-align:center">微任务Event Queue</th></tr></thead><tbody><tr><td style="text-align:center">setTimeout2</td><td style="text-align:center">process3</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">then3</td></tr></tbody></table><ol start="11"><li>第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。</li></ol><ol start="12"><li>输出10。</li></ol><ol start="13"><li>输出12。</li></ol><ol start="14"><li>第三轮事件循环结束，第三轮输出9，11，10，12。</li></ol><ol start="15"><li>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</li></ol><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>听到别人在讨论事件循环，我很想帮他们解答，可是我给出的答案都睡服不了我自己。所以决定自己整理一篇，我觉得可以让人理解的文章。下面还有别人的文章，建议大家多看看。广开言路，纳百家之言，行天下大事。</p><blockquote><p>⬇⬇⬇⬇⬇下方有补充</p></blockquote><hr><hr><hr><blockquote><p>奉上文章： <a href="https://juejin.im/post/5b498d245188251b193d4059" target="_blank" rel="noopener">JS事件循环机制（event loop）之宏任务/微任务</a></p></blockquote><hr><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote><hr><hr><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><blockquote><p>2019年4月28号：有一个地方被我忽略了 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">  console.log(&apos;6&apos;);</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;7&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;,0)</span><br><span class="line">  // resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&apos;8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;6</span><br><span class="line">&gt;7</span><br><span class="line">&gt;8</span><br></pre></td></tr></table></figure><p>resolve()如果写在定时器里面了，会使then处于等待状态，如果写在定时器外面这输出：6 8 7</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单的认识事件循环&quot;&gt;&lt;a href=&quot;#简单的认识事件循环&quot; class=&quot;headerlink&quot; title=&quot;简单的认识事件循环&quot;&gt;&lt;/a&gt;简单的认识事件循环&lt;/h1&gt;&lt;p&gt;先看一段代码：（先热个身）&lt;br&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>好了歌注</title>
    <link href="https://libaibuzai.github.io/2019/04/17/%E5%A5%BD%E4%BA%86%E6%AD%8C%E6%B3%A8/"/>
    <id>https://libaibuzai.github.io/2019/04/17/好了歌注/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-17T08:58:51.740Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[宋] 曹雪芹</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">陋室空堂，当年笏满床；</span><br><span class="line">衰草枯杨，曾为歌舞场。</span><br><span class="line">蛛丝儿结满雕梁，</span><br><span class="line">绿纱今又糊在蓬窗上。</span><br><span class="line">说什么脂正浓，粉正香，</span><br><span class="line">如何两鬓又成霜？</span><br><span class="line">昨日黄土陇头送白骨，</span><br><span class="line">今宵红灯帐底卧鸳鸯。</span><br><span class="line">金满箱，银满箱，展眼乞丐人皆谤。</span><br><span class="line">正叹他人命不长，那知自己归来丧！</span><br><span class="line">训有方，保不定日后作强梁。</span><br><span class="line">择膏粱，谁承望流落在烟花巷！</span><br><span class="line">因嫌纱帽小，致使锁枷杠，</span><br><span class="line">昨怜破袄寒，今嫌紫蟒长：</span><br><span class="line">乱烘烘你方唱罢我登场，</span><br><span class="line">反认他乡是故乡。甚荒唐，</span><br><span class="line">到头来都是为他人作嫁衣裳！</span><br></pre></td></tr></table></figure><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;[宋] 曹雪芹&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="诗词" scheme="https://libaibuzai.github.io/categories/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="词" scheme="https://libaibuzai.github.io/categories/%E8%AF%97%E8%AF%8D/%E8%AF%8D/"/>
    
    
      <category term="诗词" scheme="https://libaibuzai.github.io/tags/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="词" scheme="https://libaibuzai.github.io/tags/%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>CleanMyMac X</title>
    <link href="https://libaibuzai.github.io/2019/04/17/CleanMyMac%20X/"/>
    <id>https://libaibuzai.github.io/2019/04/17/CleanMyMac X/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-18T02:09:58.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CleanMyMac-X破解"><a href="#CleanMyMac-X破解" class="headerlink" title="CleanMyMac X破解"></a>CleanMyMac X破解</h1><h1 id="1-下载破解版"><a href="#1-下载破解版" class="headerlink" title="1.下载破解版"></a>1.下载破解版</h1><p><a href="https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/software/CleanMyMac_X_4.3.0.zip" target="_blank" rel="noopener">下载地址</a></p><h1 id="2-解压并打开dmg文件"><a href="#2-解压并打开dmg文件" class="headerlink" title="2.解压并打开dmg文件"></a>2.解压并打开dmg文件</h1><p><img src="https://dpq123456-1256164122.cos.ap-beijing.myqcloud.com/software/picture/CleanMyMac%20X%20%E7%A0%B4%E8%A7%A301.png"></p><pre><code>双击上图红框位置双击CleanMyMac X 4.3.0 [TNT].dmg将程序拖入Application即可</code></pre><h1 id="3-破解"><a href="#3-破解" class="headerlink" title="3.破解"></a>3.破解</h1><pre><code>双击Open Gatekeeper friendly一路回车即可</code></pre><h1 id="4-错误提示"><a href="#4-错误提示" class="headerlink" title="4.错误提示"></a>4.错误提示</h1><blockquote><p>1.XXX文件已损坏，需要移到废纸篓。</p></blockquote><pre><code>解决方法一：    终端运行 sudo spctl --master-disable    重新运行程序解决方法二：    xattr -r -d com.apple.quarantine /Applications/CleanMyMac\ X.app /Applications/CleanMyMac\ X.app是CleanMyMac X    运行此命令，需要自己对应到程序的安装目录</code></pre><blockquote><p>2.提示文件不信任</p></blockquote><pre><code>解决方法一：    Control+单击右键打开解决方法二：    终端运行 sudo spctl --master-disable    更改为任何来源</code></pre><blockquote><p>3.CleanMyMac X 因出现问题而无法打开</p></blockquote><pre><code>解决方法一：    运行此命令    sudo codesign --force --deep --sign - /Applications/CleanMyMac\ X.app</code></pre><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><blockquote><p>2019年4月17日</p></blockquote><pre><code>亲测 macOS Mojave 10.14.4 可用 </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CleanMyMac-X破解&quot;&gt;&lt;a href=&quot;#CleanMyMac-X破解&quot; class=&quot;headerlink&quot; title=&quot;CleanMyMac X破解&quot;&gt;&lt;/a&gt;CleanMyMac X破解&lt;/h1&gt;&lt;h1 id=&quot;1-下载破解版&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="软件" scheme="https://libaibuzai.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Mac" scheme="https://libaibuzai.github.io/categories/%E8%BD%AF%E4%BB%B6/Mac/"/>
    
    
      <category term="软件" scheme="https://libaibuzai.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Mac" scheme="https://libaibuzai.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>JS的防抖和节流</title>
    <link href="https://libaibuzai.github.io/2019/04/17/JS%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>https://libaibuzai.github.io/2019/04/17/JS的防抖和节流/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-18T02:09:05.279Z</updated>
    
    <content type="html"><![CDATA[<pre><code>前言：今天做了一个功能，input 扫码枪扫码输入然后查询设备添加列表，扫码枪的输入频率是几十毫秒，如果监听 onchange 事件效果也会如下图所示触发很多次并且每一次 onchange 都会触发查询请求。显然这不是我要的解决方案。后来查询了扫码枪的配置，原来可以设置自动回车功能。监听 onkeypress 事件完美解决。但是今天的重点是函数的防抖与节流，那我们就赶紧拿笔记下知识点吧 ！`</code></pre><p>在浏览器中如果一个事件被频繁触发，比如输入框的 keyup, 窗口的 resize 以及 scroll 事件等，如果不做任何处理，事件的回调函数将会对应执行，这必然会加重浏览器的负担，影响用户的体验。面对这种场景，我们可以用函数的防抖 (debounce) 和节流 (throttle) 来处理。</p><h1 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h1><p>防抖 debounce: 让事件触发时的回调在一定的延时后执行。如果在计时期间又触发了事件，则重新开始计时。</p><p>比如在做一个检索的输入框，输入的内容发送给后台查询。如果不做防抖处理我们来看下：</p><pre><code>&lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;</code></pre><p>用打印来模拟请求处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">用打印来模拟请求处理：</span><br><span class="line">var ipt = document.getElementById(&apos;input&apos;);</span><br><span class="line">ipt.addEventListener(&apos;keyup&apos;, function(e)&#123;</span><br><span class="line">  console.log(e.target.value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2019/04/17/JS的防抖和节流/1.gif" alt="图片丢失"></p><p>可见，每次触发事件都会执行回调函数，现在加入防抖处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var debounce = function(func, delay) &#123;</span><br><span class="line">  var timer = null</span><br><span class="line">  return function() &#123;</span><br><span class="line">      var that = this;</span><br><span class="line">      var args = arguments;</span><br><span class="line">      </span><br><span class="line">      if(timer) &#123;</span><br><span class="line">          clearTimeout(timer);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      timer = setTimeout(function() &#123;</span><br><span class="line">          func.apply(that, args);</span><br><span class="line">      &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ipt.addEventListener(&apos;keyup&apos;, debounce(function(e)&#123;</span><br><span class="line">  console.log(e.target.value);</span><br><span class="line">&#125;, 400))</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2019/04/17/JS的防抖和节流/2.gif" alt="图片丢失"></p><p>可见，输入框在停止输入400ms后执行回调。在防抖后的回调函数用 timer 记录计时，每次执行回调的时候会先清空之前的计时。注意这里的timer是闭包变量，始终保持着上一个计时。</p><h1 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h1><p>节流throttle: 让事件的回调一定时间间隔只执行一次。节流函数有两种实现方式，一种是记录增量，一种是定时方式。</p><p>用增量的方式实现节流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var throttle = function(func, delay) &#123;</span><br><span class="line">    var pre = Date.now();</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var that = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        var now = Date.now();</span><br><span class="line"></span><br><span class="line">        if (now - pre &gt;= delay) &#123;</span><br><span class="line">            func.apply(that, args);</span><br><span class="line">            pre = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ipt.addEventListener(&apos;keyup&apos;, throttle(function(e)&#123;</span><br><span class="line">    console.log(e.target.value);</span><br><span class="line">&#125;, 1000))</span><br></pre></td></tr></table></figure><p>节流的效果如下：</p><p><img src="/2019/04/17/JS的防抖和节流/3.gif" alt="图片丢失"></p><p>可见，无论怎么输入，事件回调总会在1s内执行一次。而且第一次输入会马上执行，这是因为处理节流的时候和第一次触发的时间间隔大于1s。但是最后一次触发不会执行回调。</p><p>利用计时方式处理节流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var throttle = function(func, delay) &#123;</span><br><span class="line">    var timer = null;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var that = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line"></span><br><span class="line">        if(!timer) &#123;</span><br><span class="line">            timer = setTimeout(function() &#123;</span><br><span class="line">                func.apply(that, args);</span><br><span class="line">                timer = null;</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用变量 timer 记录定时器，如果定时器存在，则不执行回调。否则创建一个延时器执行回调。这种方法和时间戳增量的区别就是第一个触发不会立即执行回调，但是最后一次时间会在延时后触发回调函数。</p><p>如果想要立即触发并且最后一次也要执行回调，可以利用时间戳和计时方式结合在实现节流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var throttle = function(func, delay) &#123;</span><br><span class="line">    var timer = null;</span><br><span class="line">    var pre = Date.now();</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var now = Date.now();</span><br><span class="line">        var that = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        var remain = delay - (now - pre);</span><br><span class="line"></span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        if (remain &lt;= 0) &#123;</span><br><span class="line">            func.apply(that, args);</span><br><span class="line">            pre = now</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            timer = setTimeout(function() &#123;</span><br><span class="line">                func.apply(that, args);</span><br><span class="line">                pre = now;</span><br><span class="line">            &#125;, remain)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的节流函数会先判断剩余的间隔时间，如果剩余时间小于0，则立即执行。否则创建一个剩余时间的定时。注意，每次要记得清空之前的定时。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>防抖 debounce 一般用来在输入检索，节约请求的资源。还有窗口的 resize，让不断调节窗口大小的最后一次触发。</p><p>节流 throttle 一般用在鼠标不断点击，让点击的回调按间隔执行一次。还有滑动 scroll 事件， 比如滚动到底部查询，按间隔请求一次数据来显示。</p><blockquote><p>感想：有的时候灵感也是能力的一部分</p></blockquote><hr><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote><blockquote><p>原文：<a href="https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;前言：今天做了一个功能，input 扫码枪扫码输入然后查询设备添加列表，扫码枪的输入频率是几十毫秒，
如果监听 onchange 事件效果也会如下图所示触发很多次并且每一次 onchange 都会触发查询请求。
显然这不是我要的解决方案。后来查询了扫码枪的配
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>悼允上人</title>
    <link href="https://libaibuzai.github.io/2019/03/23/%E6%82%BC%E5%85%81%E4%B8%8A%E4%BA%BA/"/>
    <id>https://libaibuzai.github.io/2019/03/23/悼允上人/</id>
    <published>2019-03-22T16:00:00.000Z</published>
    <updated>2019-04-17T08:59:31.734Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[宋] 释行海</strong></p><p>白云寺里同听讲，卜得山斋竹树幽。</p><p>君已不来梅自发，世皆如梦水长流，</p><p>寒灯苦志归黄土，俗客轻人将白头。</p><p>万惜少年多是死，静思吾道转堪愁。</p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;[宋] 释行海&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;白云寺里同听讲，卜得山斋竹树幽。&lt;/p&gt;
&lt;p&gt;君已不来梅自发，世皆如梦水长流，&lt;/p&gt;
&lt;p&gt;寒灯苦志归黄土，俗客轻人将白头。&lt;/p&gt;
&lt;p&gt;万惜少年多是死，静思吾道转堪愁。&lt;/p&gt;
&lt;blockquote&gt;
      
    
    </summary>
    
      <category term="诗词" scheme="https://libaibuzai.github.io/categories/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="诗" scheme="https://libaibuzai.github.io/categories/%E8%AF%97%E8%AF%8D/%E8%AF%97/"/>
    
    
      <category term="诗词" scheme="https://libaibuzai.github.io/tags/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="诗" scheme="https://libaibuzai.github.io/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>EVP_DecryptFinal_ex:bad decrypt 和 出现Illegal Buffer Error这种的情况</title>
    <link href="https://libaibuzai.github.io/2019/03/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%88%E6%9D%83%E9%97%AE%E9%A2%981/"/>
    <id>https://libaibuzai.github.io/2019/03/20/小程序授权问题1/</id>
    <published>2019-03-19T16:00:00.000Z</published>
    <updated>2019-04-15T00:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="看到这里-你的问题就不要担心了-大家的问题都是一样的。"><a href="#看到这里-你的问题就不要担心了-大家的问题都是一样的。" class="headerlink" title="看到这里 你的问题就不要担心了 大家的问题都是一样的。"></a>看到这里 你的问题就不要担心了 大家的问题都是一样的。</h3><p><strong>官网的实例是没问题的</strong> </p><ul><li><p>当前 Bug 的表现 - 预期表现可以对encryptedData正常解密。</p></li><li><p>复现路径点击登录按钮后，小程序本地数据缓存冷启动后还还会有吗，微信小程序教程。小程序调用wx.login()，再将code、iv、encrypedData一起发往后端程序，后端程序调用微信api接口（api.weixin.qq.com/sns/jscode2session）希望获取openId，但经常会出现上图中的错误。</p></li></ul><p>复现过程：</p><pre><code>1、这个问题不是持续连续发生，而是在一段时间未操作小程序时，再次点击登录按钮触发登录操作的第一次时会发生，第二次及以后的登录操作则会成功。如果再过一段时间未操作小程序，当第一次登录的时候还是会出现这个现象——第一次登录不成功，后续登录操作可以成功。2、问题的关键在于解密程序报错。将上述的ecryptedData、iv、session_key放入官方文档（貌似其中还有包括使用wx.getUserInfo()的描述，是否也要更新一下）中提供的demo.js程序运行，也会出现报错。</code></pre><h1 id="下面是我的解决-："><a href="#下面是我的解决-：" class="headerlink" title="下面是我的解决 ："></a>下面是我的解决 ：</h1><ul><li><p>一定要保证 新code的获取 在 getUserInfo或getPhoneNumber 之前</p></li><li><p>而且 每一次解密授权所用的code 都不是一样的</p></li><li><p>onload里先进行wx.login 获取code，再通过按钮开始授权 获取iv和encryptedData     </p><p>之后就不会报错了 O(∩_∩)O哈哈~</p></li></ul><p>这可能也是 小程序考虑授权先后出现的错误问题 才把全部授权按钮使用主动触发的方式的  </p><p>解决方案的出处：<br><a href="https://developers.weixin.qq.com/community/develop/doc/000808d32c06101b39d6032c956000" target="_blank" rel="noopener">https://developers.weixin.qq.com/community/develop/doc/000808d32c06101b39d6032c956000</a></p><blockquote><p>   如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p>   <a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;看到这里-你的问题就不要担心了-大家的问题都是一样的。&quot;&gt;&lt;a href=&quot;#看到这里-你的问题就不要担心了-大家的问题都是一样的。&quot; class=&quot;headerlink&quot; title=&quot;看到这里 你的问题就不要担心了 大家的问题都是一样的。&quot;&gt;&lt;/a&gt;看到这里 
      
    
    </summary>
    
      <category term="小程序" scheme="https://libaibuzai.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="https://libaibuzai.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="小程序授权问题" scheme="https://libaibuzai.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%88%E6%9D%83%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客 NexT主题从v5更新到v6的记录及总结.md</title>
    <link href="https://libaibuzai.github.io/2018/12/03/2018-12-03-Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E4%BB%8Ev5-x-x%E6%9B%B4%E6%96%B0%E5%88%B0v6-x-x%E7%9A%84%E8%AE%B0%E5%BD%95%E5%8F%8A%E6%80%BB%E7%BB%93/"/>
    <id>https://libaibuzai.github.io/2018/12/03/2018-12-03-Hexo博客NexT主题从v5-x-x更新到v6-x-x的记录及总结/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2019-04-15T00:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo博客-NexT主题从v5更新到v6的记录及总结"><a href="#Hexo博客-NexT主题从v5更新到v6的记录及总结" class="headerlink" title=" Hexo博客 NexT主题从v5更新到v6的记录及总结"></a> Hexo博客 NexT主题从v5更新到v6的记录及总结</h2><h2 id="今天索性升级一下我的主题-自定义配置样式还是很多的-需要详细修改配置"><a href="#今天索性升级一下我的主题-自定义配置样式还是很多的-需要详细修改配置" class="headerlink" title="今天索性升级一下我的主题 自定义配置样式还是很多的 需要详细修改配置"></a>今天索性升级一下我的主题 自定义配置样式还是很多的 需要详细修改配置</h2><p><a href="https://sevencho.github.io/archives/14534beb.html" target="_blank" rel="noopener">https://sevencho.github.io/archives/14534beb.html</a></p><p>#丰富插件和功能 参考博客<br><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26625249</a></p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hexo博客-NexT主题从v5更新到v6的记录及总结&quot;&gt;&lt;a href=&quot;#Hexo博客-NexT主题从v5更新到v6的记录及总结&quot; class=&quot;headerlink&quot; title=&quot; Hexo博客 NexT主题从v5更新到v6的记录及总结&quot;&gt;&lt;/a&gt; Hex
      
    
    </summary>
    
      <category term="Hexo" scheme="https://libaibuzai.github.io/categories/Hexo/"/>
    
      <category term="NexT" scheme="https://libaibuzai.github.io/categories/Hexo/NexT/"/>
    
    
      <category term="NexT" scheme="https://libaibuzai.github.io/tags/NexT/"/>
    
      <category term="Hexo" scheme="https://libaibuzai.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>es6之var let 和 const终极PK</title>
    <link href="https://libaibuzai.github.io/2018/08/02/es6%E4%B9%8Bvar-let-%E5%92%8C-const%E7%BB%88%E6%9E%81PK/"/>
    <id>https://libaibuzai.github.io/2018/08/02/es6之var-let-和-const终极PK/</id>
    <published>2018-08-01T16:00:00.000Z</published>
    <updated>2019-04-28T02:31:51.971Z</updated>
    
    <content type="html"><![CDATA[<p><strong><strong>直接上猛料</strong></strong></p><h1 id="let-取代-var"><a href="#let-取代-var" class="headerlink" title="let 取代 var"></a>let 取代 var</h1><p>ES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。</p><pre><code>&apos;use strict&apos;;if (true) {  let x = &apos;hello&apos;;}for (let i = 0; i &lt; 10; i++) {  console.log(i);}</code></pre><p>上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。</p><p>var命令存在变量提升效用，let命令没有这个问题。</p><pre><code>&apos;use strict&apos;;if(true) {  console.log(x); // ReferenceError  let x = &apos;hello&apos;;}</code></pre><p>上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。</p><p>所以，建议不再使用var命令，而是使用let命令取代。</p><h1 id="在let和const之间，建议优先使用const"><a href="#在let和const之间，建议优先使用const" class="headerlink" title="在let和const之间，建议优先使用const"></a>在let和const之间，建议优先使用const</h1><p>尤其是在全局环境，不应该设置变量，只应设置常量。</p><p> const优于let有几个原因。</p><ol><li><p>一个是const可以提醒阅读程序的人，这个变量不应该改变；</p></li><li><p>另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；</p></li><li><p>最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。</p><pre><code>// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3];</code></pre></li></ol><p>const 声明常量还有两个好处，</p><ol><li>阅读代码的人立刻会意识到不应该修改这个值，</li><li>防止了无意间修改变量值所导致的错误。</li></ol><p>所有的函数都应该设置为常量。</p><h1 id="感想："><a href="#感想：" class="headerlink" title="感想："></a>感想：</h1><p>长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p><p> 这里有<a href="https://www.jianshu.com/p/4e9cd99ecbf5" target="_blank" rel="noopener">var、let、const 区别？</a>详尽对比和分析</p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;strong&gt;直接上猛料&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;let-取代-var&quot;&gt;&lt;a href=&quot;#let-取代-var&quot; class=&quot;headerlink&quot; title=&quot;let 取代 var&quot;&gt;&lt;/a&gt;let 取代 va
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/categories/javascript/es6/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6之顶层对象的属性</title>
    <link href="https://libaibuzai.github.io/2018/06/24/es6%E4%B9%8B%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
    <id>https://libaibuzai.github.io/2018/06/24/es6之顶层对象的属性/</id>
    <published>2018-06-23T16:00:00.000Z</published>
    <updated>2019-04-18T02:08:41.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h1><p>顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。</p><pre><code>window.a = 1;a // 1a = 2;window.a // 2</code></pre><p> 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p><p> 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p> ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p><pre><code>var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined</code></pre><p>   上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。</p><h1 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h1><p>ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p><p>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。<br>浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。<br>Node 里面，顶层对象是global，但其他环境都不支持。<br>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</p><p>全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。<br>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。<br>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。<br>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p><p>// 方法一</p><pre><code>(typeof window !== &apos;undefined&apos;   ? window   : (typeof process === &apos;object&apos; &amp;&amp;      typeof require === &apos;function&apos; &amp;&amp;      typeof global === &apos;object&apos;)     ? global     : this);</code></pre><p>// 方法二</p><pre><code>var getGlobal = function () {  if (typeof self !== &apos;undefined&apos;) { return self; }  if (typeof window !== &apos;undefined&apos;) { return window; }  if (typeof global !== &apos;undefined&apos;) { return global; }  throw new Error(&apos;unable to locate global object&apos;);};</code></pre><p>现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。</p><p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。</p><pre><code>// CommonJS的写法require(&apos;system.global/shim&apos;)();// ES6模块的写法import shim from &apos;system.global/shim&apos;; shim();</code></pre><p>  上面代码可以保证各种环境里面，global对象都是存在的。</p><pre><code>// CommonJS的写法var global = require(&apos;system.global&apos;)();// ES6模块的写法import getGlobal from &apos;system.global&apos;;const global = getGlobal();</code></pre><p>   上面代码将顶层对象放入变量global。</p><h1 id="感想："><a href="#感想：" class="headerlink" title="感想："></a>感想：</h1><p>存在即合理 只是一个说辞 我们需要做的是不断的完善它，让它真的合理。毕竟罗马不是一日建成的！   </p><p> 这里有<a href="https://www.jianshu.com/p/4e9cd99ecbf5" target="_blank" rel="noopener">var、let、const 区别？</a>详尽对比和分析，希望可以帮你更好的理解。</p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;顶层对象的属性&quot;&gt;&lt;a href=&quot;#顶层对象的属性&quot; class=&quot;headerlink&quot; title=&quot;顶层对象的属性&quot;&gt;&lt;/a&gt;顶层对象的属性&lt;/h1&gt;&lt;p&gt;顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/categories/javascript/es6/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6之let 和 const</title>
    <link href="https://libaibuzai.github.io/2018/06/22/es6%E4%B9%8Blet-%E5%92%8C-const/"/>
    <id>https://libaibuzai.github.io/2018/06/22/es6之let-和-const/</id>
    <published>2018-06-21T16:00:00.000Z</published>
    <updated>2019-04-18T02:08:41.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h1><p>##let特性：</p><p>   ###1.只在let命令所在的代码块内有效。</p><p>  a.</p><pre><code>{  let a = 10;  var b = 1;}a // ReferenceError: a is not defined.b // 1</code></pre><p>  b. （let 与 for循环的用法） 要求必须 等let声明语句执行完之后，变量才能使用，不然会报Uncaught ReferenceError错误。</p><pre><code>var a = [];for (let i = 0; i &lt; 10; i++) {  a[i] = function () {    console.log(i);  };}a[6](); // 6  如同for 循环里产生了10次i的循环并没有被更新a[2](); // 2a[4](); // 4a[7](); // 7a[0](); // 0</code></pre><p>  #2.不存在变量提升 </p><pre><code>// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; </code></pre><p>  ###3.暂时性死区</p><pre><code>console.log(aicoder);    // 错误：Uncaught ReferenceError ...let aicoder = &apos;aicoder.com&apos;;// 这里就可以安全使用aicoder</code></pre><p>   有些“死区”比较隐蔽，不太容易发现。</p><pre><code>function bar(x = y, y = 2) {  return [x, y];}bar(); // 报错//因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。</code></pre><blockquote><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>     总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p></blockquote><p>  ###4.let变量不能重复声明</p><pre><code>let a = 0;let a = &apos;sss&apos;;// Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared</code></pre><p>######**ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>######<strong>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p><p>#2. 块级作用域</p><blockquote><p>为什么需要块级作用域？</p></blockquote><blockquote><blockquote><p>第一：内层变量可能会覆盖外层变量。</p></blockquote></blockquote><pre><code>var tmp = new Date();function f() {  console.log(tmp);  if (false) {    var tmp = &quot;hello world&quot;;  }}f(); // undefined</code></pre><blockquote><blockquote><p>第二：用来计数的循环变量泄露为全局变量。</p></blockquote></blockquote><pre><code>var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) {  console.log(s[i]);}console.log(i); // 5</code></pre><p> 块级作用域特点：</p><p>  1.ES6允许块级作用域的任意嵌套。</p><pre><code>{{{{{let insane = 'Hello World'}}}}};</code></pre><p>  2.允许在块级作用域之中声明函数。</p><pre><code>// ES6严格模式&apos;use strict&apos;;if (true) {  function f() {}}// 不报错</code></pre><blockquote><p>ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p></blockquote><blockquote><blockquote><blockquote><p>特别注意：<br> ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p></blockquote></blockquote></blockquote><pre><code>// 不报错&apos;use strict&apos;;if (true) {  function f() {}}// 报错&apos;use strict&apos;;if (true)  function f() {}</code></pre><p>#const命令<br>  1.const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><pre><code>const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable.</code></pre><p>  2.const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><pre><code>const foo;// SyntaxError: Missing initializer in const declaration</code></pre><p>  3.const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p><pre><code>if (true) {  const MAX = 5;}MAX // Uncaught ReferenceError: MAX is not defined</code></pre><ol start="4"><li><p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><p>if (true) {<br> console.log(MAX); // ReferenceError<br> const MAX = 5;<br>}</p></li><li><p>const声明的常量，也与let一样不可重复声明。</p><p>var message = “Hello!”;<br>let age = 25;</p><p>// 以下两行都会报错<br>const message = “Goodbye!”;<br>const age = 30;</p><p>6.对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</p><p>const foo = {};<br>foo.prop = 123;</p><p>foo.prop<br>// 123</p><p>foo = {}; // TypeError: “foo” is read-only</p><p>下面是另一个例子（可以为其添加新属性。）</p><p>const a = [];<br>a.push(‘Hello’); // 可执行<br>a.length = 0;    // 可执行<br>a = [‘Dave’];    // 报错</p><blockquote><p>ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。</p></blockquote></li></ol><h1 id="感想："><a href="#感想：" class="headerlink" title="感想："></a>感想：</h1><p>明白了前辈们对javascript的不断的优化的心情，感谢他们的贡献我将好好细读文档。不服厚爱！   </p><p> 这里有<a href="https://www.jianshu.com/p/4e9cd99ecbf5" target="_blank" rel="noopener">var、let、const 区别？</a>详尽对比和分析</p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;let-命令&quot;&gt;&lt;a href=&quot;#let-命令&quot; class=&quot;headerlink&quot; title=&quot;let 命令&quot;&gt;&lt;/a&gt;let 命令&lt;/h1&gt;&lt;p&gt;##let特性：&lt;/p&gt;
&lt;p&gt;   ###1.只在let命令所在的代码块内有效。&lt;/p&gt;
&lt;p&gt;  a.&lt;
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/categories/javascript/es6/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6之变量的解构赋值</title>
    <link href="https://libaibuzai.github.io/2018/06/20/es6%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>https://libaibuzai.github.io/2018/06/20/es6之变量的解构赋值/</id>
    <published>2018-06-19T16:00:00.000Z</published>
    <updated>2019-04-18T02:28:08.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-变量的解构赋值"><a href="#ES6-变量的解构赋值" class="headerlink" title="ES6 变量的解构赋值"></a>ES6 变量的解构赋值</h1><h1 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>以前，为变量赋值，只能直接指定值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 2;</span><br><span class="line">var c = 3;</span><br></pre></td></tr></table></figure><p>ES6允许写成下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var [a, b, c] = [1, 2, 3];</span><br></pre></td></tr></table></figure><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class="line">foo // 1</span><br><span class="line">bar // 2</span><br><span class="line">baz // 3</span><br><span class="line"></span><br><span class="line">let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];</span><br><span class="line">third // &quot;baz&quot;</span><br><span class="line"></span><br><span class="line">let [x, , y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line">let [head, ...tail] = [1, 2, 3, 4];</span><br><span class="line">head // 1</span><br><span class="line">tail // [2, 3, 4]</span><br><span class="line"></span><br><span class="line">let [x, y, ...z] = [&apos;a&apos;];</span><br><span class="line">x // &quot;a&quot;</span><br><span class="line">y // undefined</span><br><span class="line">z // []</span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值就等于undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var [foo] = [];</span><br><span class="line">var [bar, foo] = [1];</span><br></pre></td></tr></table></figure></p><p>以上两种情况都属于解构不成功，foo的值都会等于undefined。</p><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let [x, y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line"></span><br><span class="line">let [a, [b], d] = [1, [2, 3], 4];</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">d // 4</span><br></pre></td></tr></table></figure><p>上面两个例子，都属于不完全解构，但是可以成功。</p><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">let [foo] = 1;</span><br><span class="line">let [foo] = false;</span><br><span class="line">let [foo] = NaN;</span><br><span class="line">let [foo] = undefined;</span><br><span class="line">let [foo] = null;</span><br><span class="line">let [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。</p><p>解构赋值不仅适用于var命令，也适用于let和const命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var [v1, v2, ..., vN ] = array;</span><br><span class="line">let [v1, v2, ..., vN ] = array;</span><br><span class="line">const [v1, v2, ..., vN ] = array;</span><br></pre></td></tr></table></figure><p>对于Set结构，也可以使用数组的解构赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [x, y, z] = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);</span><br><span class="line">x // &quot;a&quot;</span><br></pre></td></tr></table></figure><p>事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* fibs() &#123;</span><br><span class="line">  var a = 0;</span><br><span class="line">  var b = 1;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    yield a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth // 5</span><br></pre></td></tr></table></figure><p>上面代码中，fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。</p><p>默认值<br>解构赋值允许指定默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var [foo = true] = [];</span><br><span class="line">foo // true</span><br><span class="line"></span><br><span class="line">[x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;</span><br><span class="line">[x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos;</span><br></pre></td></tr></table></figure></p><p>注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var [x = 1] = [undefined];</span><br><span class="line">x // 1</span><br><span class="line"></span><br><span class="line">var [x = 1] = [null];</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure><p>上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  console.log(&apos;aaa&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let [x = f()] = [1];</span><br></pre></td></tr></table></figure><p>上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let x;</span><br><span class="line">if ([1][0] === undefined) &#123;</span><br><span class="line">  x = f();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  x = [1][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let [x = 1, y = x] = [];     // x=1; y=1</span><br><span class="line">let [x = 1, y = x] = [2];    // x=2; y=2</span><br><span class="line">let [x = 1, y = x] = [1, 2]; // x=1; y=2</span><br><span class="line">let [x = y, y = 1] = [];     // ReferenceError</span><br></pre></td></tr></table></figure><p>上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。</p><p>对象的解构赋值<br>解构不仅可以用于数组，还可以用于对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br></pre></td></tr></table></figure></p><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br><span class="line"></span><br><span class="line">var &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">baz // undefined</span><br></pre></td></tr></table></figure></p><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。</p><p>如果变量名与属性名不一致，必须写成下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;</span><br><span class="line">baz // &quot;aaa&quot;</span><br><span class="line"></span><br><span class="line">let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;</span><br><span class="line">let &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f // &apos;hello&apos;</span><br><span class="line">l // &apos;world&apos;</span><br></pre></td></tr></table></figure></p><p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var &#123; foo: foo, bar: bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</span><br><span class="line"></span><br><span class="line">var &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">baz // &quot;aaa&quot;</span><br><span class="line">foo // error: foo is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p><p>注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let foo;</span><br><span class="line">let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration &quot;foo&quot;</span><br><span class="line"></span><br><span class="line">let baz;</span><br><span class="line">let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration &quot;baz&quot;</span><br></pre></td></tr></table></figure></p><p>上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let foo;</span><br><span class="line">(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功</span><br><span class="line"></span><br><span class="line">let baz;</span><br><span class="line">(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功</span><br></pre></td></tr></table></figure></p><p>上面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。</p><p>和数组一样，解构也可以用于嵌套结构的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    &apos;Hello&apos;,</span><br><span class="line">    &#123; y: &apos;World&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // &quot;Hello&quot;</span><br><span class="line">y // &quot;World&quot;</span><br></pre></td></tr></table></figure></p><p>注意，这时p是模式，不是变量，因此不会被赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: 1,</span><br><span class="line">      column: 5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line // 1</span><br><span class="line">loc  // error: loc is undefined</span><br><span class="line">start // error: start is undefined</span><br></pre></td></tr></table></figure></p><p>上面代码中，只有line是变量，loc和start都是模式，不会被赋值。</p><p>下面是嵌套赋值的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">let arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);</span><br><span class="line"></span><br><span class="line">obj // &#123;prop:123&#125;</span><br><span class="line">arr // [true]</span><br></pre></td></tr></table></figure></p><p>对象的解构也可以指定默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var &#123;x = 3&#125; = &#123;&#125;;</span><br><span class="line">x // 3</span><br><span class="line"></span><br><span class="line">var &#123;x, y = 5&#125; = &#123;x: 1&#125;;</span><br><span class="line">x // 1</span><br><span class="line">y // 5</span><br><span class="line"></span><br><span class="line">var &#123;x:y = 3&#125; = &#123;&#125;;</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line">var &#123;x:y = 3&#125; = &#123;x: 5&#125;;</span><br><span class="line">y // 5</span><br><span class="line"></span><br><span class="line">var &#123; message: msg = &apos;Something went wrong&apos; &#125; = &#123;&#125;;</span><br><span class="line">msg // &quot;Something went wrong&quot;</span><br></pre></td></tr></table></figure></p><p>默认值生效的条件是，对象的属性值严格等于undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var &#123;x = 3&#125; = &#123;x: undefined&#125;;</span><br><span class="line">x // 3</span><br><span class="line"></span><br><span class="line">var &#123;x = 3&#125; = &#123;x: null&#125;;</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure></p><p>上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。</p><p>如果解构失败，变量的值等于undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var &#123;foo&#125; = &#123;bar: &apos;baz&apos;&#125;;</span><br><span class="line">foo // undefined</span><br></pre></td></tr></table></figure></p><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">var &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &apos;baz&apos;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var _tmp = &#123;baz: &apos;baz&apos;&#125;;</span><br><span class="line">_tmp.foo.bar // 报错</span><br></pre></td></tr></table></figure></p><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 错误的写法</span><br><span class="line">var x;</span><br><span class="line">&#123;x&#125; = &#123;x: 1&#125;;</span><br><span class="line">// SyntaxError: syntax error</span><br></pre></td></tr></table></figure></p><p>上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 正确的写法</span><br><span class="line">(&#123;x&#125; = &#123;x: 1&#125;);</span><br></pre></td></tr></table></figure><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p><p>解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [true, false]);</span><br><span class="line">(&#123;&#125; = &apos;abc&apos;);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><pre><code>let { log, sin, cos } = Math;</code></pre><p>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">var &#123;0 : first, [arr.length - 1] : last&#125; = arr;</span><br><span class="line">first // 1</span><br><span class="line">last // 3</span><br></pre></td></tr></table></figure><p>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。</p><p>字符串的解构赋值<br>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const [a, b, c, d, e] = &apos;hello&apos;;</span><br><span class="line">a // &quot;h&quot;</span><br><span class="line">b // &quot;e&quot;</span><br><span class="line">c // &quot;l&quot;</span><br><span class="line">d // &quot;l&quot;</span><br><span class="line">e // &quot;o&quot;</span><br></pre></td></tr></table></figure></p><p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let &#123;length : len&#125; = &apos;hello&apos;;</span><br><span class="line">len // 5</span><br></pre></td></tr></table></figure></p><p>数值和布尔值的解构赋值<br>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let &#123;toString: s&#125; = 123;</span><br><span class="line">s === Number.prototype.toString // true</span><br><span class="line"></span><br><span class="line">let &#123;toString: s&#125; = true;</span><br><span class="line">s === Boolean.prototype.toString // true</span><br></pre></td></tr></table></figure></p><p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p><p>解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let &#123; prop: x &#125; = undefined; // TypeError</span><br><span class="line">let &#123; prop: y &#125; = null; // TypeError</span><br></pre></td></tr></table></figure></p><p>函数参数的解构赋值<br>函数的参数也可以使用解构赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function add([x, y])&#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([1, 2]); // 3</span><br></pre></td></tr></table></figure></p><p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p><p>下面是另一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);</span><br><span class="line">// [ 3, 7 ]</span><br></pre></td></tr></table></figure></p><p>函数参数的解构也可以使用默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, 0]</span><br><span class="line">move(&#123;&#125;); // [0, 0]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure></p><p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</p><p>注意，下面的写法会得到不一样的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</span><br><span class="line">move(&#123;x: 3&#125;); // [3, undefined]</span><br><span class="line">move(&#123;&#125;); // [undefined, undefined]</span><br><span class="line">move(); // [0, 0]</span><br></pre></td></tr></table></figure></p><p>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p><p>undefined就会触发函数参数的默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[1, undefined, 3].map((x = &apos;yes&apos;) =&gt; x);</span><br><span class="line">// [ 1, &apos;yes&apos;, 3 ]</span><br></pre></td></tr></table></figure></p><p>圆括号问题<br>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p><p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p><p>不能使用圆括号的情况<br>以下三种解构赋值不得使用圆括号。</p><p>（1）变量声明语句中，不能带有圆括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 全部报错</span><br><span class="line">var [(a)] = [1];</span><br><span class="line"></span><br><span class="line">var &#123;x: (c)&#125; = &#123;&#125;;</span><br><span class="line">var (&#123;x: c&#125;) = &#123;&#125;;</span><br><span class="line">var &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line">var &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;</span><br></pre></td></tr></table></figure></p><p>上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p><p>（2）函数参数中，模式不能带有圆括号。</p><p>函数参数也属于变量声明，因此不能带有圆括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function f([(z)]) &#123; return z; &#125;</span><br></pre></td></tr></table></figure></p><p>（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line">(&#123; p: a &#125;) = &#123; p: 42 &#125;;</span><br><span class="line">([a]) = [5];</span><br></pre></td></tr></table></figure><p>上面代码将整个模式放在圆括号之中，导致报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><p>上面代码将嵌套模式的一层，放在圆括号之中，导致报错。</p><p>可以使用圆括号的情况<br>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[(b)] = [3]; // 正确</span><br><span class="line">(&#123; p: (d) &#125; = &#123;&#125;); // 正确</span><br><span class="line">[(parseInt.prop)] = [3]; // 正确</span><br></pre></td></tr></table></figure></p><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p><p>用途<br>变量的解构赋值用途很多。</p><p>（1）交换变量的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p><p>（2）从函数返回多个值</p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 返回一个数组</span><br><span class="line"></span><br><span class="line">function example() &#123;</span><br><span class="line">  return [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">var [a, b, c] = example();</span><br><span class="line"></span><br><span class="line">// 返回一个对象</span><br><span class="line"></span><br><span class="line">function example() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><p>（3）函数参数的定义</p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 参数是一组有次序的值</span><br><span class="line">function f([x, y, z]) &#123; ... &#125;</span><br><span class="line">f([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 参数是一组无次序的值</span><br><span class="line">function f(&#123;x, y, z&#125;) &#123; ... &#125;</span><br><span class="line">f(&#123;z: 3, y: 2, x: 1&#125;);</span><br></pre></td></tr></table></figure><p>（4）提取JSON数据</p><p>解构赋值对提取JSON对象中的数据，尤其有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: &quot;OK&quot;,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.log(id, status, number);</span><br><span class="line">// 42, &quot;OK&quot;, [867, 5309]</span><br></pre></td></tr></table></figure></p><p>上面代码可以快速提取JSON数据的值。</p><p>（5）函数参数的默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = function (url, &#123;</span><br><span class="line">  async = true,</span><br><span class="line">  beforeSend = function () &#123;&#125;,</span><br><span class="line">  cache = true,</span><br><span class="line">  complete = function () &#123;&#125;,</span><br><span class="line">  crossDomain = false,</span><br><span class="line">  global = true,</span><br><span class="line">  // ... more config</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  // ... do stuff</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p><p>（6）遍历Map结构</p><p>任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var map = new Map();</span><br><span class="line">map.set(&apos;first&apos;, &apos;hello&apos;);</span><br><span class="line">map.set(&apos;second&apos;, &apos;world&apos;);</span><br><span class="line"></span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">  console.log(key + &quot; is &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br></pre></td></tr></table></figure></p><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 获取键名</span><br><span class="line">for (let [key] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取键值</span><br><span class="line">for (let [,value] of map) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（7）输入模块的指定方法</p><p>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p><p><code>`</code>const { SourceMapConsumer, SourceNode } = require(“source-map”);</p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6-变量的解构赋值&quot;&gt;&lt;a href=&quot;#ES6-变量的解构赋值&quot; class=&quot;headerlink&quot; title=&quot;ES6 变量的解构赋值&quot;&gt;&lt;/a&gt;ES6 变量的解构赋值&lt;/h1&gt;&lt;h1 id=&quot;数组的解构赋值&quot;&gt;&lt;a href=&quot;#数组的解构赋值&quot; c
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/categories/javascript/es6/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6之编码规范</title>
    <link href="https://libaibuzai.github.io/2018/06/18/es6%E4%B9%8B%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://libaibuzai.github.io/2018/06/18/es6之编码规范/</id>
    <published>2018-06-17T16:00:00.000Z</published>
    <updated>2019-04-18T02:08:41.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h1><p>##let特性：</p><p>   ###1.只在let命令所在的代码块内有效。</p><p>  a.</p><pre><code>{  let a = 10;  var b = 1;}a // ReferenceError: a is not defined.b // 1</code></pre><p>  b. （let 与 for循环的用法） 要求必须 等let声明语句执行完之后，变量才能使用，不然会报Uncaught ReferenceError错误。</p><pre><code>var a = [];for (let i = 0; i &lt; 10; i++) {  a[i] = function () {    console.log(i);  };}a[6](); // 6  如同for 循环里产生了10次i的循环并没有被更新a[2](); // 2a[4](); // 4a[7](); // 7a[0](); // 0</code></pre><p>  #2.不存在变量提升 </p><pre><code>// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; </code></pre><p>  ###3.暂时性死区</p><pre><code>console.log(aicoder);    // 错误：Uncaught ReferenceError ...let aicoder = &apos;aicoder.com&apos;;// 这里就可以安全使用aicoder</code></pre><p>   有些“死区”比较隐蔽，不太容易发现。</p><pre><code>function bar(x = y, y = 2) {  return [x, y];}bar(); // 报错//因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。</code></pre><blockquote><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>     总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p></blockquote><p>  ###4.let变量不能重复声明</p><pre><code>let a = 0;let a = &apos;sss&apos;;// Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared</code></pre><p>######**ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>######<strong>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p><p>#2. 块级作用域</p><blockquote><p>为什么需要块级作用域？</p></blockquote><blockquote><blockquote><p>第一：内层变量可能会覆盖外层变量。</p></blockquote></blockquote><pre><code>var tmp = new Date();function f() {  console.log(tmp);  if (false) {    var tmp = &quot;hello world&quot;;  }}f(); // undefined</code></pre><blockquote><blockquote><p>第二：用来计数的循环变量泄露为全局变量。</p></blockquote></blockquote><pre><code>var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) {  console.log(s[i]);}console.log(i); // 5</code></pre><p> 块级作用域特点：</p><p>  1.ES6允许块级作用域的任意嵌套。</p><pre><code>{{{{{let insane = 'Hello World'}}}}};</code></pre><p>  2.允许在块级作用域之中声明函数。</p><pre><code>// ES6严格模式&apos;use strict&apos;;if (true) {  function f() {}}// 不报错</code></pre><blockquote><p>ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p></blockquote><blockquote><blockquote><blockquote><p>特别注意：<br> ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p></blockquote></blockquote></blockquote><pre><code>// 不报错&apos;use strict&apos;;if (true) {  function f() {}}// 报错&apos;use strict&apos;;if (true)  function f() {}</code></pre><p>#const命令<br>  1.const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><pre><code>const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable.</code></pre><p>  2.const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><pre><code>const foo;// SyntaxError: Missing initializer in const declaration</code></pre><p>  3.const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p><pre><code>if (true) {  const MAX = 5;}MAX // Uncaught ReferenceError: MAX is not defined</code></pre><ol start="4"><li><p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><p>if (true) {<br> console.log(MAX); // ReferenceError<br> const MAX = 5;<br>}</p></li><li><p>const声明的常量，也与let一样不可重复声明。</p><p>var message = “Hello!”;<br>let age = 25;</p><p>// 以下两行都会报错<br>const message = “Goodbye!”;<br>const age = 30;</p><p>6.对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</p><p>const foo = {};<br>foo.prop = 123;</p><p>foo.prop<br>// 123</p><p>foo = {}; // TypeError: “foo” is read-only</p><p>下面是另一个例子（可以为其添加新属性。）</p><p>const a = [];<br>a.push(‘Hello’); // 可执行<br>a.length = 0;    // 可执行<br>a = [‘Dave’];    // 报错</p><blockquote><p>ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。</p></blockquote></li></ol><h1 id="感想："><a href="#感想：" class="headerlink" title="感想："></a>感想：</h1><p>明白了前辈们对javascript的不断的优化的心情，感谢他们的贡献我将好好细读文档。不服厚爱！   </p><p> 这里有<a href="https://www.jianshu.com/p/4e9cd99ecbf5" target="_blank" rel="noopener">var、let、const 区别？</a>详尽对比和分析</p><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;let-命令&quot;&gt;&lt;a href=&quot;#let-命令&quot; class=&quot;headerlink&quot; title=&quot;let 命令&quot;&gt;&lt;/a&gt;let 命令&lt;/h1&gt;&lt;p&gt;##let特性：&lt;/p&gt;
&lt;p&gt;   ###1.只在let命令所在的代码块内有效。&lt;/p&gt;
&lt;p&gt;  a.&lt;
      
    
    </summary>
    
      <category term="javascript" scheme="https://libaibuzai.github.io/categories/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/categories/javascript/es6/"/>
    
    
      <category term="javascript" scheme="https://libaibuzai.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="https://libaibuzai.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>修改默认浏览器滚动条</title>
    <link href="https://libaibuzai.github.io/2017/10/08/2017-10-8-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BB%9A%E5%8A%A8%E6%9D%A1/"/>
    <id>https://libaibuzai.github.io/2017/10/08/2017-10-8-修改默认浏览器滚动条/</id>
    <published>2017-10-07T16:00:00.000Z</published>
    <updated>2019-04-15T00:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改默认浏览器滚动条"><a href="#修改默认浏览器滚动条" class="headerlink" title="修改默认浏览器滚动条"></a>修改默认浏览器滚动条</h1><pre><code>::-webkit-scrollbar{ width:3px; height:0px;} /* 滚动条的大小 */::-webkit-scrollbar-track {background-color: #6d7277;} /* 滚动条的滑轨背景颜色 */::-webkit-scrollbar-thumb {background-color:#4b4d50; border-radius:0px;} /* 滑块颜色 *//*::-webkit-scrollbar-button {background-color: #7c2929;} /* 滑轨两头的监听按钮颜色::-webkit-scrollbar-corner {background-color: black;} /* 横向滚动条和纵向滚动条相交处尖角的颜色 */</code></pre><blockquote><p>如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p><a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;修改默认浏览器滚动条&quot;&gt;&lt;a href=&quot;#修改默认浏览器滚动条&quot; class=&quot;headerlink&quot; title=&quot;修改默认浏览器滚动条&quot;&gt;&lt;/a&gt;修改默认浏览器滚动条&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;::-webkit-scrollbar{ width:3px
      
    
    </summary>
    
      <category term="css" scheme="https://libaibuzai.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://libaibuzai.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>angular控制器间的通讯</title>
    <link href="https://libaibuzai.github.io/2017/07/20/angular%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E8%AE%AF/"/>
    <id>https://libaibuzai.github.io/2017/07/20/angular控制器通讯/</id>
    <published>2017-07-19T16:00:00.000Z</published>
    <updated>2019-04-15T00:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ng笔记broadcast-amp-amp-on-amp-amp-emit"><a href="#ng笔记broadcast-amp-amp-on-amp-amp-emit" class="headerlink" title="ng笔记broadcast&amp;&amp;on&amp;&amp;emit"></a>ng笔记broadcast&amp;&amp;on&amp;&amp;emit</h3><pre><code>&lt;script&gt;varmyapp=angular.module(&apos;TestApp&apos;,[&apos;ng&apos;]);myapp.controller(&apos;ParentCtrl&apos;,function($scope){    $scope.$on(&apos;to-child&apos;,function(e,d){        console.log(&apos;[ParentCtrl]to-child&apos;);    });    $scope.$on(&apos;to-parent&apos;,function(e,d){        console.log(&apos;[ParentCtrl]to-parent&apos;);    });})    myapp.controller(&apos;SelfCtrl&apos;,function($scope){        $scope.click=function(){            $scope.$broadcast(&apos;to-child&apos;,&apos;haha&apos;);            $scope.$emit(&apos;to-parent&apos;,&apos;hehe&apos;);}})            myapp.controller(&apos;ChildCtrl&apos;,function($scope){                $scope.$on(&apos;to-child&apos;,function(e,d){                console.log(&apos;[ChildCtrl]to-child&apos;);            });            $scope.$on(&apos;to-parent&apos;,function(e,d){                    console.log(&apos;[ChildCtrl]to-parent&apos;);            });        })        myapp.controller(&apos;BroCtrl&apos;,function($scope){            $scope.$on(&apos;to-child&apos;,function(e,d){            console.log(&apos;[BroCtrl]to-child&apos;);        });        $scope.$on(&apos;to-parent&apos;,function(e,d){            console.log(&apos;[BroCtrl]to-parent&apos;);        });    });    &lt;/script&gt;    &lt;div ng-controller=&quot;ParentCtrl&quot;&gt;        &lt;div ng-controller=&quot;SelfCtrl&quot;&gt;            &lt;a class=&quot;btn&quot;ng-click=&quot;click()&quot;&gt;clickme&lt;/a&gt;            &lt;div ng-controller=&quot;ChildCtrl&quot;&gt;                &lt;span&gt;{{great}}&lt;/span&gt;                &lt;p&gt;参数：{{canshu}}&lt;/p&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div ng-controller=&quot;BroCtrl&quot;&gt;{{text}}&lt;/div&gt;    &lt;/div&gt;</code></pre><h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><p>上面的例子可以看到，事件和事件发生者的兄弟是没有关系的，怎样都收不到。</p><blockquote><p>   如有侵权行为，请<a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">点击这里</a>联系我删除</p></blockquote><blockquote><p>   <a href="https://github.com/libaibuzai/libaibuzai/issues" target="_blank" rel="noopener">如发现疑问或者错误点击反馈</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ng笔记broadcast-amp-amp-on-amp-amp-emit&quot;&gt;&lt;a href=&quot;#ng笔记broadcast-amp-amp-on-amp-amp-emit&quot; class=&quot;headerlink&quot; title=&quot;ng笔记broadcast&amp;amp;
      
    
    </summary>
    
      <category term="angular" scheme="https://libaibuzai.github.io/categories/angular/"/>
    
    
      <category term="angular" scheme="https://libaibuzai.github.io/tags/angular/"/>
    
  </entry>
  
</feed>
