<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最全的npm知识点总结]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%9C%80%E5%85%A8%E7%9A%84npm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[npm在前端开发流程中提供了非常完善的自动化工具链，已成为每个前端开发者必备的工具，但是同样由于其强大性导致很多前端开发者只会简单的使用它。本文将总结在日常开发中所需要的npm知识点，以便开发者们更好的将npm运用在实际开发中。 npm 处理 node_modules 目录结构一个项目开发、上线所依赖的插件包都存放在node_modules中。虽然在实际开发中无需关注这个目录里面的文件结构细节，但了解node_modules中的内容可以帮助我们更好的理解npm组织这些文件的机制。 假设项目App中有如下三个依赖： &quot;dependencies&quot;: { A: &quot;1.0.0&quot;, B: &quot;1.0.0&quot;, C: &quot;1.0.0&quot; } A、B、C三个模块又有如下依赖： A@1.0.0 -&gt; D@1.0.0 B@1.0.0 -&gt; D@2.0.0 C@1.0.0 -&gt; D@1.0.0 npm 2.x - 嵌套结构 npm 2.x安装依赖方式比较简单直接，以递归的方式，按照包依赖的树形结构下载填充本地目录结构，也就是说每个包都会将该包的依赖安装到当前包所在的node_modules目录中。 执行npm install后，项目App的node_modules会变成如下目录结构： ├── node_modules │ ├── A@1.0.0 │ │ └── node_modules │ │ │ └── D@1.0.0 │ ├── B@1.0.0 │ │ └── node_modules │ │ │ └── D@2.0.0 │ └── C@1.0.0 │ │ └── node_modules │ │ │ └── D@1.0.0 很显然这样的依赖组织结构，有如下优点： 层级结构明显简单的实现了多版本兼容保证了对依赖包无论是安装还是删除都会有统一的行为和结构但是缺点也一样很明显： 可能造成相同模块大量冗余问题可能造成目录结构嵌套比较深的问题npm 3.x - 扁平结构 npm 3.x则采用了扁平化的结构来安装组织node_modules。也就是在执行npm install的时候，按照package.json 里依赖的顺序依次解析，遇到新的包就把它安装在第一级目录，后续安装如果遇到一级目录已经存在的包，会先按照约定版本判断版本，如果符合版本约定则忽略，否则会按照npm 2.x的方式依次挂在依赖包目录下。 还以项目App为例，在npm 3.x环境下，执行npm install后，node_modules会变成如下目录结构： ├── node_modules │ ├── A@1.0.0 │ ├── D@1.0.0 │ ├── B@1.0.0 │ │ └── node_modules │ │ │ └── D@2.0.0 │ └── C@1.0.0 模块的安装次序决定了node_modules中的目录结构，npm会优先将模块安装在根目录下的node_modules中。再在项目中安装模块E@1.0.0（依赖于模块D@2.0.0），目录结构变为： ├── node_modules │ ├── A@1.0.0 │ ├── D@1.0.0 │ ├── B@1.0.0 │ │ └── node_modules │ │ │ └── D@2.0.0 │ └── C@1.0.0 │ ├── E@1.0.0 │ │ └── node_modules │ │ │ └── D@2.0.0 B、E模块下都包含了依赖的模块D@2.0.0，存在代码冗余的情况。 再在项目中安装模块F@1.0.0（依赖于模块D@1.0.0）。由于D@1.0.0已经存在于项目根目录下的node_modules 下，所以在安装F模块的时候，无需再在其依赖包中安装D@1.0.0模块，目录结构变为： ├── node_modules│ ├── A@1.0.0│ ├── D@1.0.0│ ├── B@1.0.0│ │ └── node_modules│ │ │ └── D@2.0.0│ └── C@1.0.0│ ├── E@1.0.0│ │ └── node_modules│ │ │ └── D@2.0.0│ └── F@1.0.0从以上结构可以看出，npm 3.x并没有完美的解决npm 2.x中的问题，甚至还会退化到npm 2.x的行为。 为了解决目录中存在很多副本的情况，（在A、C模块的依赖模块D升级到2.0.0前提下）可以通过npm dedupe指令把所有二级的依赖模块D@2.0.0重定向到一级目录下： ├── node_modules│ ├── A@1.0.0│ ├── D@2.0.0│ ├── B@1.0.0│ └── C@1.0.0│ ├── E@1.0.0│ └── F@1.0.0node_modules路径查找机制：模块再找对应的依赖包时，nodejs会尝试从当前模块所在目录开始，尝试在它的node_modules 文件夹里加载相应模块，如果没有找到，那么就再向上一级目录移动，直到全局安装路径中的node_modules为止。npm 5.x - package-lock.json 从npm 5.x开始，安装组织node_modules和npm 3.x一样采用了扁平化的方式，最大的变化是增加了 package-lock.json 文件。 npm为了让开发者在安全的前提下使用最新的依赖包，在package.json中通常做了锁定大版本的操作，这样在每次npm install的时候都会拉取依赖包大版本下的最新的版本。这种机制最大的一个缺点就是当有依赖包有小版本更新时，可能会出现协同开发者的依赖包不一致的问题。 package-lock.json文件精确描述了node_modules 目录下所有的包的树状依赖结构，每个包的版本号都是完全精确的。以sass-loader在package-lock.json中为例： &quot;dependencies&quot;: { &quot;sass-loader&quot;: { &quot;version&quot;: &quot;7.1.0&quot;, &quot;resolved&quot;: &quot;http://registry.npm.taobao.org/sass-loader/download/sass-loader-7.1.0.tgz&quot;, &quot;integrity&quot;: &quot;sha1-Fv1ROMuLQkv4p1lSihly1yqtBp0=&quot;, &quot;dev&quot;: true, &quot;requires&quot;: { &quot;clone-deep&quot;: &quot;^2.0.1&quot;, &quot;loader-utils&quot;: &quot;^1.0.1&quot;, &quot;lodash.tail&quot;: &quot;^4.1.1&quot;, &quot;neo-async&quot;: &quot;^2.5.0&quot;, &quot;pify&quot;: &quot;^3.0.0&quot;, &quot;semver&quot;: &quot;^5.5.0&quot; }, &quot;dependencies&quot;: { &quot;pify&quot;: { &quot;version&quot;: &quot;3.0.0&quot;, &quot;resolved&quot;: &quot;http://registry.npm.taobao.org/pify/download/pify-3.0.0.tgz&quot;, &quot;integrity&quot;: &quot;sha1-5aSs0sEB/fPZpNB/DbxNtJ3SgXY=&quot;, &quot;dev&quot;: true } } } } package-lock.json的详细描述主要由version、resolved、integrity、dev、requires、dependencies这几个字段构成： version：包唯一的版本号resolved：安装源integrity：表明包完整性的hash值（验证包是否已失效）dev：如果为true，则此依赖关系仅是顶级模块的开发依赖关系或者是一个的传递依赖关系requires：依赖包所需要的所有依赖项，对应依赖包package.json里dependencies中的依赖项dependencies：依赖包node_modules中依赖的包，与顶层的dependencies一样的结构在上面的package-lock.json文件中可以发现，在requires和dependencies中都存在pify依赖项。那我们顺便去node_modules里面探下究竟： 打开根目录的node_modules会发现安装了sass-loader所需要的所有依赖包，这些依赖包中除了pify以外，所有依赖包的大版本号都与sass-loader所需要的一致。到根目录的node_modules找到pify依赖包，发现版本为4.0.1。找到sass-loader项目依赖包，打开其node_modules发现其中也存在个pify依赖包，但版本为3.0.0。这个版本的sass-loader真正依赖的是这个版本的pify。通过以上几个步骤，也验证了之前阐述过的npm 5.x是扁平化处理依赖的方式。 在开发一个应用时，建议把package-lock.json文件提交到代码版本仓库，从而让你的团队成员、运维部署人员或CI系统可以在执行npm install时安装的依赖版本都是一致的。 但是在开发一个库时，则不应把package-lock.json文件发布到仓库中。实际上，npm也默认不会把package-lock.json文件发布出去。之所以这么做，是因为库项目一般是被其他项目依赖的，在不写死的情况下，就可以复用主项目已经加载过的包，而一旦库依赖的是精确的版本号那么可能会造成包的冗余。 npm 中的依赖包 依赖包分类 在 node 中其实总共有5种依赖： dependencies - 业务依赖 devDependencies - 开发依赖 peerDependencies - 同伴依赖 bundledDependencies / bundleDependencies - 打包依赖 optionalDependencies - 可选依赖 作为npm的使用者，我们常用的依赖是dependencies和devDependencies，剩下三种依赖则是作为包的发布者才会使用到的字段。 dependencies 这种依赖在项目最终上线或者发布npm包时所需要，即其中的依赖项应该属于线上代码的一部分。比如框架vue，第三方的组件库element-ui等，这些依赖包都是必须装在这个选项里供生产环境使用。 通过命令npm install/i packageName -S/–save把包装在此依赖项里。如果没有指定版本，直接写一个包的名字，则安装当前npm仓库中这个包的最新版本。如果要指定版本的，可以把版本号写在包名后面，比如npm i vue@3.0.1 -S。 从npm 5.x开始，可以不用手动添加-S/–save指令，直接执行npm i packageName把依赖包添加到dependencies中去。devDependencies 这种依赖只在项目开发时所需要，即其中的依赖项不应该属于线上代码的一部分。比如构建工具webpack、gulp，预处理器babel-loader、scss-loader，测试工具e2e、chai等，这些都是辅助开发的工具包，无须在生产环境使用。 通过命令npm install/i -D/–save-dev把包安装成开发依赖。如果想缩减安装包，可以使用命令npm i –production忽略开发依赖，只安装基本依赖，这通常在线上机器（或者QA环境）上使用。 千万别以为只有在dependencies中的模块才会被一起打包，而在devDependencies中的不会！模块能否被打包，取决于项目里是否被引入了该模块！在业务项目中dependencies和devDependencies没有什么本质区别，只是单纯的一个规范作用，在执行npm i时两个依赖下的模块都会被下载；而在发布npm包的时候，包中的dependencies依赖项在安装该包的时候会被一起下载，devDependencies依赖项则不会。peerDependencies 这种依赖的作用是提示宿主环境去安装插件在peerDependencies中所指定依赖的包，然后插件所依赖的包永远都是宿主环境统一安装的npm包，最终解决插件与所依赖包不一致的问题。 这句话听起来可能有点拗口，举个例子来给大家说明下。element-ui@2.6.3只是提供一套基于vue的ui组件库，但它要求宿主环境需要安装指定的vue版本，所以你可以看到element项目中的package.json中具有一项配置： &quot;peerDependencies&quot;: { &quot;vue&quot;: &quot;^2.5.16&quot; } 它要求宿主环境安装3.0.0 &gt; vue@ &gt;= 2.5.16的版本，也就是element-ui的运行依赖宿主环境提供的该版本范围的vue依赖包。 在安装插件的时候，peerDependencies在npm 2.x和npm 3.x中表现不一样： 在npm 2.x中，安装包中peerDependencies所指定的依赖会随着npm install packageName一起被强制安装，并且peerDependencies中指定的依赖会安装在宿主环境中，所以不需要在宿主环境的package.json文件中指定对所安装包中peerDependencies内容的依赖。 在npm 3.x中，不会再要求peerDependencies所指定的依赖包被强制安装，npm 3.x只会在安装结束后检查本次安装是否正确，如果不正确会给用户打印警告提示，比如提示用户有的包必须安装或者有的包版本不对等。 大白话：如果你安装我，那么你最好也要按照我的要求安装A、B和C。bundledDependencies / bundleDependencies 这种依赖跟npm pack打包命令有关。假设package.json中有如下配置： { &quot;name&quot;: &quot;font-end&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;dependencies&quot;: { &quot;fe1&quot;: &quot;^0.3.2&quot;, ... }, &quot;devDependencies&quot;: { ... &quot;fe2&quot;: &quot;^1.0.0&quot; }, &quot;bundledDependencies&quot;: [ &quot;fe1&quot;, &quot;fe2&quot; ] } 执行打包命令npm pack，会生成front-end-1.0.0.tgz压缩包，并且该压缩包中包含fe1和fe2两个安装包，这样使用者执行npm install front-end-1.0.0.tgz也会安装这两个依赖。 在bundledDependencies中指定的依赖包，必须先在dependencies和devDependencies声明过，否则打包会报错。optionalDependencies 这种依赖中的依赖项即使安装失败了，也不影响整个安装的过程。需要注意的是，如果一个依赖同时出现在dependencies和optionalDependencies中，那么optionalDependencies会获得更高的优先级，可能造成一些预期之外的效果，所以尽量要避免这种情况发生。 在实际项目中，如果某个包已经失效，我们通常会寻找它的替代者，或者换一个实现方案。不确定的依赖会增加代码判断和测试难度，所以这个依赖项还是尽量不要使用。依赖包版本号 npm采用了semver规范作为依赖版本管理方案。 按照semver的约定，一个npm依赖包的版本格式一般为：主版本号.次版本号.修订号（x.y.z），每个号的含义是： 主版本号（也叫大版本，major version） 大版本的改动很可能是一次颠覆性的改动，也就意味着可能存在与低版本不兼容的API或者用法，（比如 vue 2 -&gt; 3)。 次版本号（也叫小版本，minor version） 小版本的改动应当兼容同一个大版本内的API和用法，因此应该让开发者无感。所以我们通常只说大版本号，很少会精确到小版本号。 如果大版本号是 0 的话，表示软件处于开发初始阶段，一切都可能随时被改变，可能每个小版本之间也会存在不兼容性。所以在选择依赖时，尽量避开大版本号是 0 的包。修订号（也叫补丁，patch） 一般用于修复bug或者很细微的变更，也需要保持向前兼容。 常见的几个版本格式如下： “1.2.3” 表示精确版本号。任何其他版本号都不匹配。在一些比较重要的线上项目中，建议使用这种方式锁定版本。 “^1.2.3” 表示兼容补丁和小版本更新的版本号。官方的定义是“能够兼容除了最左侧的非 0 版本号之外的其他变化”(Allows changes that do not modify the left-most non-zero digit in the [major, minor, patch] tuple)。这句话很拗口，举几个例子大家就明白了： “^1.2.3” 等价于 “&gt;= 1.2.3 &lt; 2.0.0”。即只要最左侧的 “1” 不变，其他都可以改变。所以 “1.2.4”, “1.3.0” 都可以兼容。 “^0.2.3” 等价于 “&gt;= 0.2.3 &lt; 0.3.0”。因为最左侧的是 “0”，那么只要第二位 “2” 不变，其他的都兼容，比如 “0.2.4” 和 “0.2.99”。 “^0.0.3” 等价于 “&gt;= 0.0.3 &lt; 0.0.4”。大版本号和小版本号都为 “0” ，所以也就等价于精确的 “0.0.3”。从这几个例子可以看出，^ 是一个兼具更新和安全的写法，但是对于大版本号为 1 和 0 的版本还是会有不同的处理机制的。 “~1.2.3” 表示只兼容补丁更新的版本号。关于 ~ 的定义分为两部分：如果列出了小版本号（第二位），则只兼容补丁（第三位）的修改；如果没有列出小版本号，则兼容第二和第三位的修改。我们分两种情况理解一下这个定义： “~1.2.3” 列出了小版本号 “2”，因此只兼容第三位的修改，等价于 “&gt;= 1.2.3 &lt; 1.3.0”。 “~1.2” 也列出了小版本号 “2”，因此和上面一样兼容第三位的修改，等价于 “&gt;= 1.2.0 &lt; 1.3.0”。 “~1” 没有列出小版本号，可以兼容第二第三位的修改，因此等价于 “&gt;= 1.0.0 &lt; 2.0.0”从这几个例子可以看出，~ 是一个比^更加谨慎安全的写法，而且~并不对大版本号 0 或者 1 区别对待，所以 “~0.2.3” 与 “~1.2.3” 是相同的算法。当首位是 0 并且列出了第二位的时候，两者是等价的，例如 “~0.2.3” 和 “^0.2.3”。 “1.x” 、”1.X”、1.“、”1”、”“ 表示使用通配符的版本号。x、X、* 和 （空） 的含义相同，都表示可以匹配任何内容。具体来说： “*” 、”x” 或者 （空） 表示可以匹配任何版本。 “1.x”, “1.*” 和 “1” 表示匹配主版本号为 “1” 的所有版本，因此等价于 “&gt;= 1.0.0 &lt; 2.0.0”。 “1.2.x”, “1.2.*” 和 “1.2” 表示匹配版本号以 “1.2” 开头的所有版本，因此等价于 “&gt;= 1.2.0 &lt; 1.3.0”。“1.2.3-beta.1” 带预发布关键词的版本号。先说说几个预发布关键词的定义： alpha(α)：预览版，或者叫内部测试版；一般不向外部发布，会有很多bug；一般只有测试人员使用。 beta(β)：测试版，或者叫公开测试版；这个阶段的版本会一直加入新的功能；在alpha版之后推出。 rc(release candidate)：最终测试版本；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本。以包开发者的角度来考虑这个问题：假设当前线上版本是 “1.2.3”，如果我作了一些改动需要发布版本 “1.2.4”，但我不想直接上线（因为使用 “~1.2.3” 或者 “^1.2.3” 的用户都会直接静默更新），这就需要使用预发布功能。因此我可能会发布 “1.2.4-alpha.1” 或者 “1.2.4-beta.1” 等等。 “&gt;1.2.4-alpha.1”表示接受 “1.2.4-alpha” 版本下所有大于 1 的预发布版本。因此 “1.2.4-alpha.7” 是符合要求的，但 “1.2.4-beta.1” 和 “1.2.5-alpha.2” 都不符合。此外如果是正式版本（不带预发布关键词），只要版本号符合要求即可，不检查预发布版本号，例如 “1.2.5”, “1.3.0” 都是认可的。 “~1.2.4-alpha.1” 表示 “&gt;=1.2.4-alpha.1 &lt; 1.3.0”。这样 “1.2.5”, “1.2.4-alpha.2” 都符合条件，而 “1.2.5-alpha.1”, “1.3.0” 不符合。 “^1.2.4-alpha.1” 表示 “&gt;=1.2.4-alpha.1 &lt; 2.0.0”。这样 “1.2.5”, “1.2.4-alpha.2”, “1.3.0” 都符合条件，而 “1.2.5-alpha.1”, “2.0.0” 不符合。版本号还有更多的写法，例如范围（a - b），大于等于号（&gt;=），小于等于号（&lt;=），或（||）等等，因为用的不多，这里不再展开。详细的文档可以参见语义化版本(semver)。它同时也是一个 npm 包，可以用来比较两个版本号的大小，以及是否符合要求等。 依赖包版本管理 npm 2.x/3.x已成为过去式，在npm 5.x以上环境下（版本最好在5.6以上，因为在5.0 ~ 5.6中间对package-lock.json的处理逻辑更新过几个版本，5.6以上才开始稳定），管理项目中的依赖包版本你应该知道（以^版本为例，其他类型版本参照即可）： 在大版本相同的前提下，如果一个模块在package.json中的小版本要大于package-lock.json中的小版本，则在执行npm install时，会将该模块更新到大版本下的最新的版本，并将版本号更新至package-lock.json。如果小于，则被package-lock.json中的版本锁定。// package-lock.json 中原版本 “clipboard”: { “version”: “1.5.10”, }, “vue”: { “version”: “2.6.10”, }// package.json 中修改版本 “dependencies”: { “clipboard”: “^1.5.12”, “vue”: “^2.5.6” … } // 执行完 npm install 后，package-lock.json 中 “clipboard”: { “version”: “1.7.1”, // 更新到大版本下的最新版本 }, “vue”: { “version”: “2.6.10”, // 版本没发生改变 }如果一个模块在package.json和package-lock.json中的大版本不相同，则在执行npm install时，都将根据package.json中大版本下的最新版本进行更新，并将版本号更新至package-lock.json。// package-lock.json 中原版 “clipboard”: { “version”: “2.0.4”, } // package.json 中修改版本 “dependencies”: { “clipboard”: “^1.6.1”, } // 执行完npm install后，package-lock.json 中// “clipboard”: { “version”: “1.7.1”, // 更新到大版本下的最新版本 }如果一个模块在package.json中有记录，而在package-lock.json中无记录，执行npm install后，则会在package-lock.json生成该模块的详细记录。同理，一个模块在package.json中无记录，而在package-lock.json中有记录，执行npm install后，则会在package-lock.json删除该模块的详细记录。 如果要更新某个模块大版本下的最新版本（升级小版本号），请执行如下命令： npm install packageName// 或者npm update packageName如果要更新到指定版本号（升级大版本号），请执行如下命令：npm install packageName@x.x.x卸载某个模块，请执行如下命令：npm uninstall packageName通过上述的命令来管理依赖包，package.json和package-lock.json中的版本号都将会随之更新。 我们在升级/卸载依赖包的时候，尽量通过命令来实现，避免手动修改package.json中的版本号，尤其不要手动修改package-lock.json。 npm scripts 脚本 package.json中的 scripts 字段可以用来自定义脚本命令，它的每一个属性，对应一段脚本。以vue-cli3为例： &quot;scripts&quot;: { &quot;serve&quot;: &quot;vue-cli-service serve&quot;, ... } 这样就可以通过npm run serve脚本代替vue-cli-service serve脚本来启动项目，而无需每次敲一遍这么冗长的脚本。 工作原理 package.json 中的 bin 字段 package.json中的字段 bin 表示的是一个可执行文件到指定文件源的映射。例如在@vue/cli-service的package.json中： &quot;bin&quot;: { &quot;vue-cli-service&quot;: &quot;bin/vue-cli-service.js&quot; } 如果全局安装@vue/cli-service的话，@vue/cli-service源文件会被安装在全局源文件安装目录（/user/local/lib/node_modules）下，而npm会在全局可执行bin文件安装目录（/usr/local/bin）下创建一个指向../lib/node_modules/@vue/cli-service/bin/vue-cli-service.js文件的名为vue-cli-service的软链接，这样就可以直接在终端输入vue-cli-service来执行。 如果局部安装@vue/cli-service的话，npm则会在本地项目node_modules/.bin目录下创建一个指向../@vue/cli-service/bin/vue-cli-service.js名为vue-cli-service的软链接，这个时候需要在终端中输入./node_modules/.bin/vue-cli-service来执行（也可以使用npx vue-cli-service命令来执行，npx 的作用就是为了方便调用项目内部安装的模块）。 软链接（符号链接）是一类特殊的可执行文件， 其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用。在bin目录下执行ll指令可以查看具体的软链接指向。在对链接文件进行读或写操作的时候，系统会自动把该操作转换为对源文件的操作，但删除链接文件时，系统仅仅删除链接文件，而不删除源文件本身。PATH 环境变量 在terminal中执行命令时，命令会在PATH环境变量里包含的路径中去寻找相同名字的可执行文件。局部安装的包只在./node_modules/.bin中注册了它们的可执行文件，不会被包含在PATH环境变量中，这个时候在terminal中输入命令将会报无法找到的错误。 那为什么通过npm run可以执行局部安装的命令行包呢？ 是因为每当执行npm run时，会自动新建一个Shell，这个 Shell会将当前项目的node_modules/.bin的绝对路径加入到环境变量PATH中，执行结束后，再将环境变量PATH恢复原样。 我们来验证下这个说法。首先执行 env 查看当前所有的环境变量，可以看到PATH环境变量为： PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin再在当前项目下执行npm run env查看脚本运行时的环境变量，可以看到PATH环境变量为： PATH=/usr/local/lib/node_modules/npm/node_modules/npm-lifecycle/node-gyp-bin:/Users/mac/Vue-projects/hao-cli/node_modules/.bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin可以看到运行时的PATH环境变量多了两个路径：npm指令路径和项目中node_modules/.bin的绝对路径。 所以，通过npm run可以在不添加路径前缀的情况下直接访问当前项目node_modules/.bin目录里面的可执行文件。 PATH环境变量，是告诉系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到哪些目录下去寻找。用法指南 传入参数 关于scripts中的参数，这里要多说几句。网上有很多不是很准确的说法，经过本人的反复试验，node处理scripts参数其实很简单，比如： &quot;scripts&quot;: { &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;serve1&quot;: &quot;vue-cli-service --serve1&quot;, &quot;serve2&quot;: &quot;vue-cli-service -serve2&quot;, &quot;serve3&quot;: &quot;vue-cli-service serve --mode=dev --mobile -config build/example.js&quot; } 除了第一个可执行的命令，以空格分割的任何字符串（除了一些shell的语法）都是参数，并且都能通过process.argv属性访问。 process.argv属性返回一个数组，这个数组包含了启动node进程时的命令行参数。第一个元素为启动node 进程的可执行文件的绝对路径名process.execPath，第二个元素为当前执行的JavaScript文件路径。剩余的元素为其他命令行参数。比如执行npm run serve3命令，process.argv的具体内容为： [ &apos;/usr/local/Cellar/node/7.7.1_1/bin/node&apos;, &apos;/Users/mac/Vue-projects/hao-cli/node_modules/.bin/vue-cli-service&apos;, &apos;serve&apos;, &apos;--mode=dev&apos;, &apos;--mobile&apos;, &apos;-config&apos;, &apos;build/example.js&apos;] 很多命令行包之所以这么写，都是依赖了 minimist 或者 yargs 等参数解析工具来对命令行参数进行解析。 以minimist对vue-cli-service serve –mode=dev –mobile -config build/example.js解析为例，解析后的结果为： { _: [ &apos;serve&apos; ], mode: &apos;dev&apos;, mobile: true, config: &apos;build/example.js&apos;, &apos;$0&apos;: &apos;/Users/mac/Vue-projects/hao-cli/node_modules/.bin/vue-cli-service&apos;} 在./node_modules/.bin/vue-cli-service文件中可以看到minimist对命令行参数的处理： const rawArgv = process.argv.slice(2) const args = require(&apos;minimist&apos;)(rawArgv, { boolean: [ // build &apos;modern&apos;, &apos;report&apos;, &apos;report-json&apos;, &apos;watch&apos;, // serve &apos;open&apos;, &apos;copy&apos;, &apos;https&apos;, // inspect &apos;verbose&apos; ] }) const command = args._[0] service.run(command, args, rawArgv).catch(err =&gt; { error(err) process.exit(1) }) 我们还可以通过命令行传参的形式来进行参数传递： npm run serve --params // 参数params将转化成process.env.npm_config_params = true npm run serve --params=123 // 参数params将转化成process.env.npm_config_params = 123 npm run serve -params // 等同于--params参数 npm run serve -- --params // 将--params参数添加到process.env.argv数组中 npm run serve params // 将params参数添加到process.env.argv数组中 npm run serve -- params // 将params参数添加到process.env.argv数组中 多命令运行 有的项目在启动时可能需要同时执行多个任务，多个任务的执行顺序决定了项目的表现。 串行执行 串行执行，要求前一个任务执行成功以后才能执行下一个任务，使用&amp;&amp;符号来连接。 npm run script1 &amp;&amp; npm run script2 串行命令执行过程中，只要一个命令执行失败，则整个脚本终止。并行执行 并行执行，就是多个命令可以同时的平行执行，使用&amp;符号来连接。 npm run script1 &amp; npm run script2 这两个符号是Bash的内置功能。此外，还可以使用第三方的任务管理器模块：script-runner、npm-run-all、redrun。 env 环境变量 在执行npm run脚本时，npm会设置一些特殊的env环境变量。其中package.json中的所有字段，都会被设置为以npm_package_ 开头的环境变量。比如package.json中有如下字段内容： { &quot;name&quot;: &quot;sh&quot;, &quot;version&quot;: &quot;1.1.1&quot;, &quot;description&quot;: &quot;shenhao&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+ssh://git@gitlab.com/xxxx/sh.git&quot; } } 可以通过process.env.npm_package_name 可以获取到package.json中name字段的值sh，也可以通过process.env.npm_package_repository_type获取到嵌套属性type的值git。 同时，npm相关的所有配置也会被设置为以npm_config_开头的环境变量。 此外，还会设置一个比较特殊的环境变量npm_lifecycle_event，表示正在运行的脚本名称。比如执行npm run serve 的时候，process.env.npm_lifecycle_event值为serve，通过判断这个变量，可以将一个脚本使用在不同的npm scripts中。 这些环境变量只能在npm run的脚本执行环境内拿到，正常执行的node脚本是获取不到的。所以，不能直接通过env $NODE_ENV的形式访问，但可以在scripts中定义脚本”scripts”: “echo $NODE_ENV”来访问。指令钩子 在执行npm scripts命令（无论是自定义还是内置）时，都经历了pre和post两个钩子，在这两个钩子中可以定义某个命令执行前后的命令。 比如在执行npm run serve命令时，会依次执行npm run preserve、npm run serve、npm run postserve，所以可以在这两个钩子中自定义一些动作： &quot;scripts&quot;: { &quot;preserve&quot;: &quot;xxxxx&quot;, &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;postserve&quot;: &quot;xxxxxx&quot; } 当然，如果没有指定preserve、postserve，会默默的跳过。如果想要指定钩子，必须严格按照pre和post前缀来添加。 上面提到过一个环境变量process.env.npm_lifecycle_event可以配合钩子来一起使用： const event = process.env.npm_lifecycle_event if (event === &apos;preserve&apos;) { console.log(&apos;Running the preserve task!&apos;) } else if (_event === &apos;serve&apos;) { console.log(&apos;Running the serve task!&apos;) } npm 配置 npm的配置操作可以帮助我们预先设定好npm对项目的行为动作，也可以让我们预先定义好一些配置项以供项目中使用。所以了解npm的配置机制也是很有必要。 优先级 npm可以从不同的来源获取其配置值，按优先级从高到低的顺序排序： 命令行 npm run serve –params=123执行上述命令时，会将配置项params的值设为123，通过process.env.npm_config_params可以访问其配置值。这个时候的params配置值将覆盖所有其他来源存在的params配置值。 env 环境变量 如果env环境变量中存在以npm_config_为前缀的环境变量，则会被识别为npm的配置属性。比如在env环境变量中设置npm_config_package_lock变量： export npm_config_package_lock=false // 修改的是内存中的变量，只对当前终端有效这时候执行npm install，npm会从环境变量中读取到这个配置项，从而不会生成package-lock.json文件。 查看某个环境变量：echo $NODE_ENV 删除某个环境变量：unset NODE_ENVnpmrc 文件 通过修改 npmrc 文件可以直接修改配置。系统中存在多个npmrc文件，这些npmrc文件被访问的优先级从高到低的顺序为： 项目级的.npmrc文件 只作用在本项目下。在其他项目中，这些配置不生效。通过创建这个.npmrc文件可以统一团队的npm配置规范。 用户级的.npmrc文件 mac下的地址为~/.npmrc。（npm config get userconfig可以看到存放的路径） 全局级的npmrc文件 mac下的地址为$PREFIX/etc/npmrc。（npm config get globalconfig可以看到存放的路径） npm内置的npmrc文件 这是一个不可更改的内置配置文件，为了维护者以标准和一致的方式覆盖默认配置。mac下的地址为/path/to/npm/npmrc。 .npmrc参照 npm/ini 格式编写。默认配置 通过npm config ls -l查看npm内部的默认配置参数。如果命令行、环境变量、所有配置文件都没有配置参数，则使用默认参数值。 npm config 指令 npm提供了几个 npm config 指令来进行用户级和全局级配置： set npm config set [-g|–global]npm config set registry # 指定下载 npm 包的来源，默认为 https://registry.npmjs.org/ ，可以指定私有源使用-g|–global标志修改或新增全局级配置，不使用的话修改或者新增用户级配置（相应级别的.npmrc文件会更新）。 如果key不存在，则会新增到配置中。如果省略value，则key会被设置成true。 还可以覆盖package.json中config字段的值： // package.json { “name” : “foo”, “config” : { “port” : “8080” }, “scripts” : { “start” : “node server.js” } }// server.jsconsole.log(process.env.npm_package_config_port)npm config set foo:port 8000 # 打印8000get npm config get npm config get prefix # 获取npm的安装路径按照配置优先级，获取指定配置项的值。 delete npm config delete npm官网上说可以删除所有配置文件中指定的配置项，但经实验无法删除项目级的.npmrc文件里指定的配置项。 list npm config list [-l] [–json]加上-l或者–json查看所有的配置项，包括默认的配置项。不加的话，不能查看默认的配置项。 edit npm config edit [-g|–global]在编辑器中打开配置文件。使用-g|–global标志编辑全局级配置和默认配置，不使用的话编辑用户级配置和默认配置。 参考 npm config 来获取更多的默认配置。 npm 工程管理 项目版本号管理 package.json中的version字段代表的是该项目的版本号。每当项目发布新版本时，需要将version字段进行相应的更新以便后期维护。虽然可以手动的修改vsersion字段，但是为了整个发布过程的自动化，尽量使用 npm version 指令来自动更新version： npm version (v)1.2.3 # 显示设置版本号为 1.2.3 npm version major # 大版本号加 1，其余版本号归 0 npm version minor # 小版本号加 1，修订号归 0 npm version patch # 修订号加 1 显示的设置版本号时，版本号必须符合semver规范，允许在版本号前加上个v标识。如果不想让此次更新正式发布，还可以创建预发布版本： 当前版本号为 1.2.3npm version prepatch # 版本号变为 1.2.4-0，也就是 1.2.4 版本的第一个预发布版本 npm version preminor # 版本号变为 1.3.0-0，也就是 1.3.0 版本的第一个预发布版本 npm version premajor # 版本号变为 2.0.0-0，也就是 2.0.0 版本的第一个预发布版本 npm version prerelease # 版本号变为 2.0.0-1，也就是使预发布版本号加一 在git环境中，执行npm version修改完版本号以后，还会默认执行git add-&gt;git commit-&gt;git tag操作： 其中commit message默认是自动修改完的版本号，可以通过添加-m/–message选项来自定义commit message： npm version xxx -m “upgrade to %s for reasons” # %s 会自动替换为新版本号比如执行npm version minor -m “feat(version): upgrade to %s for reasons”后： 如果git工作区还有未提交的修改，npm version将会执行失败，可以加上-f/–force后缀来强制执行。 如果不想让npm version指令影响你的git仓库，可以在指令中使用–no-git-tag-version参数： npm --no-git-tag-version version xxx 如果想默认不影响你的git仓库，可以在npm设置中禁止： npm config set git-tag-version false # 不自动打 tag npm config set commit-hooks false # 不自动 commit 模块 tag 管理 不经常发布包的同学可能对模块 tag 概念不是很清楚。以vue为例，首先执行npm dist-tag ls vue查看vue包的tag： beta: 2.6.0-beta.3 csp: 1.0.28-csp latest: 2.6.10 上面列出的beta、csp、latest就是tag。每个tag对应了一个版本。 那tag到底有什么用呢？tag类似于git里面分支的概念，发布者可以在指定的tag上发布版本，而使用者可以选择指定的tag来安装包。不同的标签下的版本之间互不影响，这在发布者发布预发布版本包和使用者尝鲜预发布版本包的同时，不影响到正式版本。 在发布包的时候执行npm publish默认会打上latest这个tag，实际上是执行了npm publish –tag latest。而在安装包的时候执行npm install xxx则会默认下载latest这个tag下面的最新版本，实际上是执行了npm install xxx@latest。当然，我们也可以自定义tag： 当前版本为1.0.1npm version prerelease # 1.0.2-0 npm publish --tag beta npm dist-tag ls xxx # # beta: 1.0.2-0 npm install xxx@beta # 下载beta版本 1.0.2-0 当prerelease版本已经稳定了，可以将prerelease版本设置为稳定版本： npm dist-tag add xxx@1.0.2-0 latest npm dist-tag ls xxx # latest: 1.0.2-0 域级包管理 细心的同学会发现，在package.json中的依赖有两种形式： &quot;devDependencies&quot;: { &quot;@commitlint/cli&quot;: &quot;^7.2.1&quot;, &quot;commitizen&quot;: &quot;^3.0.4&quot; } 其中以@开头的包名，是一个域级包（scoped package），这种域级包的作用是将一些packages集中在一个命名空间下，一方面可以集中管理，一方面可以防止与别的包产生命名冲突。 要发布域级包，首先要在项目的package.json的name属性中添加scope相关的声明，可以通过指令添加： npm init --scope=scopeName -y package.json变为： { &quot;name&quot;: &quot;@scopeName/package&quot; } 可以将用户名作为域名，也可以将组织名作为域名。由于用@声明了该包，npm会默认将此包认定为私有包，而在npm上托管私有包是需要收费的，所以为了避免发布私有包，可以在发布时添加–accss=public参数告知npm这不是一个私有包： npm publish --access=public 域级包不一定就是私有包，但是私有包一定是一个域级包。同时，在安装域级包时需要按照域级包全名来安装： npm install @scopeName/package npm 的几个实用技巧 自定义默认的 npm init 使用npm init初始化一个新的项目时会提示你去填写一些项目描述信息。如果觉得填写这些信息比较麻烦的话，可以使用-y标记表示接受package.json中的一些默认值： npm init -y 也可以设置初始化的默认值： npm config set init-author-name &lt;name&gt; // 为 npm init 设置了默认的作者名 查看 npm 脚本命令 查看当前项目的所有npm脚本命令最直接的办法就是打开项目中的package.json文件并检查scripts字段。我们还可以使用不带任何参数的npm run命令查看： npm run 查看环境变量 通过env查看当前的所有环境变量，而查看运行时的所有环境变量可以执行： npm run env 模块管理 检查当前项目依赖的所有模块，包括子模块以及子模块的子模块： npm list/ls 如果还想查看模块的一些描述信息（package.json中的description中的内容）： npm la/ll // 相当于npm ls --long 一个项目依赖的模块往往很多，可以限制输出模块的层级来查看： npm list/ls --depth=0 // 只列出父包依赖的模块 检查项目中依赖的某个模块的当前版本信息： npm list/ls &lt;packageName&gt; 查看某个模块包的版本信息： npm view/info &lt;packageName&gt; version // 模块已经发布的最新的版本信息（不包括预发布版本） npm view/info &lt;packageName&gt; versions // 模块所有的历史版本信息（包括预发布版本） 查看一个模块到底是因为谁被安装进来的，如果显示为空则表明该模块为内置模块或者不存在： npm ll &lt;packageName&gt; 查看某个模块的所有信息，包括它的依赖、关键字、更新日期、贡献者、仓库地址和许可证等： npm view/info &lt;packageName&gt; 查看当前项目中可升级的模块： npm outdated 整理项目中无关的模块： npm prune 查看模块文档 打开模块的 github 主页： npm repo &lt;packageName&gt; 打开模块的文档地址： npm docs &lt;packageName&gt; 打开模块的 issues 地址： npm bugs &lt;packageName&gt; 在不同的目录下运行脚本 你的文件夹中肯定存在很多应用程序，而当你想要启动某个应用程序时，肯定是通过cd指令一步步进入到你所想要启动的应用程序目录下，然后再执行启动命令。npm提供了–prefix可以指定启动目录： npm run dev --prefix /path/to/your/folder 模块全局化 假设你在开发一个模块A，同时需要在另外一个项目B中测试它，当然你可以将该模块的代码拷贝到需要使用它的项目中，但这也不是理想的方法，可以在模块A的目录下执行： npm linknpm link命令通过链接目录和可执行文件，实现任意位置的npm包命令的全局可执行。 npm link主要做了两件事： 为目标npm模块创建软链接，将其链接到全局node模块安装路径/usr/local/lib/node_modules/为目标npm模块的可执行bin文件创建软链接，将其链接到全局node命令安装路径/usr/local/bin/安全漏洞检查 检查项目中是否存在具有安全漏洞的依赖包，如果存在，则将生成其漏洞报告显示在控制台中： npm audit [–json] # 加上–json，以 JSON 格式生成漏洞报告npm升级到6.x版本以后，在项目中更新或者下载新的依赖包以后会自动执行 npm audit 命令，对项目依赖包进行安全检查，如果存在安全漏洞，将生成漏洞报告并在控制台中显示。修复存在安全漏洞的依赖包（自动更新到兼容的安全版本）： npm audit fix执行npm audit fix能修复大部分存在安全漏洞的依赖包，对于一些没能自动修复漏洞的依赖包，说明出现了SERVER WARNING之类的警告（主要发生在依赖包更改了不兼容的api或者大版本做了升级的情况下），这意味着推荐的修复版本还可能出现问题，这时可以执行如下命令来修复这些依赖包： npm audit fix –force–force会将依赖包版本号升级到最新的大版本，而不是兼容的安全版本。大版本的升级可能会出现一些不兼容的用法，所以尽量避免使用–force。如果执行npm audit fix –force后还是存在有安全漏洞的依赖包，手动执行npm audit打印出还存在安全漏洞的依赖包的具体信息，其中More info对应的链接中可能给出了解决方案。 如果想知道audit fix会怎么处理项目中的依赖包，可以预先查看： npm audit fix –dry-run –json如果只想修复生产环境的依赖包（只更新dependencies中的依赖包，不更新devDependencies中的依赖包）： npm audit --only=prod 如果不想修复依赖包，只修改package-lock.json文件： npm audit fix --package-lock-only 如果想安装某个包时不进行安全漏洞检查： npm install packageName --no-audit 要想安装所有包时都不进行安全漏洞检查，则可以修改npm配置： npm config set audit false 依赖锁定 npm默认安装模块时，会通过脱字符^来限定所安装模块的主版本号。可以配置npm通过波浪符~来限定安装模块版本号： npm config set save-prefix=&quot;~&quot; 当然还可以配置npm仅安装精确版本号的模块： npm config set save-exact true 最后 关于npm的知识点暂时总结到这里，可能还有很多方面没有总结到位，后续如果还有新的知识点会随时更新，也欢迎各位大佬们随时来补充，共同进步！]]></content>
      <categories>
        <category>node</category>
        <category>npm</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 之 bind（）]]></title>
    <url>%2F2019%2F05%2F07%2Fjs-%E4%B9%8B-bind%EF%BC%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言今天跟朋友讨论了一个面试题，深入探究了一下。 12// 3// 3 两次输出都是3。期初我们总结为：只执行第一个绑定的，后面执行多少都无效。 ？？？ 但是有人就问为啥后面不再输出4 和 5继续往下看⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️ Function​.prototype​.bind()以下是 MDN 给出了bind（）的定义：bind()方法创建一个新的函数，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。 语法：function.bind(thisArg[, arg1[, arg2[, …]]]) 返回值是：返回一个原函数的拷贝，并拥有指定的this值和初始参数。 描述：bind() 函数会创建一个新绑定函数（bound function，BF）。绑定函数是一个exotic function object（怪异函数对象，ECMAScript 2015中的术语），它包装了原函数对象。调用绑定函数通常会导致执行包装函数。 分割线 以上好对问题并没有很好的解释，看下面的案例 123456789101112131415Function.prototype.bind = function (scope ，...args ) &#123; const self = this return function () &#123; self.call(scope,args) &#125;&#125;const b = &#123;x:1&#125;const c = &#123;x:2&#125;const a = function () &#123; console.log(this.x)&#125;a.bind(b).bind(c)() // output : 1 删除上面Function 12345678const b = &#123;x:1&#125;const c = &#123;x:2&#125;const a = function () &#123; console.log(this.x)&#125;a.bind(b).bind(c)() // output : 1 输出也是1 总结：也就是说 bind()的实现，相当于使用函数在内部包了一个call/apply，第二次bind()相当于在包住第一次bind（）， 故第二次以后的bind 是无法生效的。 再看下面123456789101112131415const b = &#123;x:1&#125;const c = &#123;x:2&#125;const a = function () &#123; console.log(this.x)&#125;function test() &#123; (function()&#123; a.call(b) &#125;).call(c)&#125;test() //output : 1 差不多可以解释了 感兴趣的可以自己试试。 更加欢迎大家能给出更好的解释或加以指正。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello LILI]]></title>
    <url>%2F2019%2F04%2F30%2Fhello-LILI%2F</url>
    <content type="text"><![CDATA[HELLO LILIlili 这个名字来源于我曾经看过的一个电影 《狐狸与我》。 说的是一个小女孩着迷于一只田间狐狸的故事，她给狐狸起名叫”lili”,她从发现它，着迷于它，引诱它，了解它。就好像我着迷于人工智能。 LILI是个怎样的形象我对于人工智能我所知甚少，我不知道该如何给我心里的这位朋友一个更准确合适的定义。就好像现在我的神经女朋友现在在我身边模仿我敲代码的一举一动，我笑她笑 我动动手指她动动手指，像”LILI”一样。我相信有很多人都希望有一个这样的能够陪伴自己内心的她存在。所以我该如何定义这个朋友呢 123456function person (name,sex,age...) &#123; this.name = name; this.sex = sex; this.age = age; ...&#125; 最初的想法既然不知道我该如何去创建她，那就从一个baby开始。 她会摇头晃脑 她要会哭。 会笑 她要会拉屎。 她会拉尿。 她会睁眼 眨眼 闭眼。 会走路 前进 后退 会跑。 会伤心 123456789person.prototype.speak = function (who,words) &#123; console.log(who,&apos;speak &apos;,words);&#125;person.prototype.smill = function (who) &#123; console.log(who ,&apos;is smilling!&apos;);&#125;person.prototype.walk = function (who) &#123; console.log(who, &apos;is walking&apos;);&#125; LILI 会有哪些喜好？ 她会喜欢听歌吗 她会喜欢看电影吗 她喜欢在什么时候听歌？ 她喜欢和谁看电影呢？ LILI 的能力我知道说老师肯定不是太准确。抛去核心硬件如何实现不说，先假设。 听力LILI需要听力，她需要对千万种声音进行识别，分析，判断，并确认是什么发出的。还需要对这些声音做出应对的动作，比如：玻璃杯碎了，发出来声音，如果她看见了 ，如果应对；如果没看见，是否需要走到声音源附近，看见并确认发生了什么事？又该如何应对？ 视力需要识别物体，定义物体属性（动物，植物，会移动，不会移动…）分析物体运动，并预判可能风险。 嗅觉分析味道组成，识别味道发出的物体。 味觉识别酸甜苦辣咸的味道，并更新物体属性。 感觉物体是硬的 软的 干的 湿的 记录软硬程度 。 这些能力分别对应复杂的机器学习，深度学习，算法的演进，而现在很多的程序员在做很多类似方面的单独研究，但在未来得此五感者的天下。 总结我知道上面写的这些，很多逻辑问题，很多现在做不到的事情，但是后来的我总会嘲笑之前的我，无1例外，但这也是未来的我为之前的我感到骄傲的地方，同样从无例外。 补充 2019/05/05： 对于机器来说什么是好的？什么是坏的？因为感知也是有判断行为的]]></content>
      <categories>
        <category>灵感</category>
        <category>LILI</category>
      </categories>
      <tags>
        <tag>灵感</tag>
        <tag>LILI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个新的面试题go()()('l')]]></title>
    <url>%2F2019%2F04%2F28%2F%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98go()()('l')%2F</url>
    <content type="text"><![CDATA[面试题：不知道 为何好多人都在发这道题，好奇心驱动：👇 解法： var Fc = function() { var str = &apos;g&apos;; var todo = function(a) { if (a) { str = `${str}o`; return `${str}${a}` } else { str += &apos;o&apos;; /差一步这个 return todo; } } return todo; } var go = Fc(); console.log(go()()()(&apos;l&apos;));]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac屏保开发之iScreenSaver]]></title>
    <url>%2F2019%2F04%2F28%2FMac%E5%B1%8F%E4%BF%9D%E5%BC%80%E5%8F%91%E4%B9%8BiScreenSaver%2F</url>
    <content type="text"><![CDATA[大致思路; 主程序使用 macOS 对应 kit 挂一个webview, 输入单文件 html document(html+js+css) 解析对应 document 并 load 到 webview 展示 子程序从本地文件夹 load codepen 相关文件并根据codepen css js 引用规则做解析, 合并为单文件, 复制粘贴到 screen saver 里, load iScreenSaver - A Screen Saver for Mac OSX 10.8+一个神奇的的屏幕保护程序，内置了30多种酷炫的屏幕保护。你还可以创建属于自己的屏幕保护！ 如何安装iScreenSaver 下载最新的安装包 (名字一般为iScreenSaver.x.xx.saver.zip) 解压文件 双击安装 打开 系统偏好设置 &gt; 桌面与屏幕保护程序 &gt; 屏幕保护程序 选择 “iScreenSaver” (安装完后一般在列表最底部) 然后点击 屏幕保护程序选项 选择你喜欢的屏幕保护程序! 或者，你也可以自己自定义一个！ iScreenSaver支持屏保文件是HTML的 必须js，css，html在同一个文件内 （下面有代码合并工具） 安装Pen简易合成工具（可以不必安装只是个代码合并工具） 下载最新的安装包 (名字一般为CodePenSourceCodeFileMergeTool.dmg) 解压文件并双击 双击：CodePenSourceCodeFileMergeTool.app 安装工具指示操作就可以了 其中的一些屏幕保护程序截图[Square lightning][Sheep][Lonely moon][Hearts][Jellyfish][Yellow Square][Virus][Plankton] 特性 自动加载最新的屏幕保护程序: 作者会增加新的屏幕保护程序在推荐列表 自定义属于你自己的屏幕保护程序: 如果你有一些酷炫的 HTML / URL / JAVASCRIPT, 你可以把它作为一个屏幕保护程序. Compatibility最低支持 Mac OSX 10.8+ FAQ 我不能安装iScreenSaver? 请打开 系统偏好设置 &gt; 安全性与隐私 &gt; 仍然打开. 有一些屏幕保护程序黑屏? 请等待几秒钟，因为程序需要加载一些必要的js文件. 我能找到其他酷炫的屏幕保护程序文件吗? 请进入反馈区 一起讨论, 或者进入CodePen搜索你喜欢的动画 它的原理是什么? iScreenSaver使用经过深度优化的WebView来加载HTML文件, 高性能并且帧数有保证, 你也不必担心会耗电, 它与平常的保护程序没什么两样. Community 发现Bug? Open an issue. Try to be as specific as possible. 想增加一些功能? Open an issue. Tell me why this feature would be useful, and why you and others would want it. Change log May 27th, 2017 - 1.04: 支持本地屏幕保护编辑. May 23th, 2017 - 1.03: First release. License本项目是协助传播如果我侵犯了你的合法权益, 请及时联系我!]]></content>
      <categories>
        <category>Mac</category>
        <category>屏保开发</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把酒问月]]></title>
    <url>%2F2019%2F04%2F26%2F%E6%8A%8A%E9%85%92%E9%97%AE%E6%9C%88%2F</url>
    <content type="text"><![CDATA[[唐] 李白 青天有月来几时，我今停杯一问之：人攀明月不可得，月行却与人相随？皎如飞镜临丹阙，绿烟灭尽清辉发？但见宵从海上来，宁知晓向云间没？白兔捣药秋复春，嫦娥孤栖与谁邻？今人不见古时月，今月曾经照古人。古人今人若流水，共看明月皆如此。唯愿当歌对酒时，月光长照金樽里。]]></content>
      <categories>
        <category>诗词</category>
        <category>诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 之 原型和继承]]></title>
    <url>%2F2019%2F04%2F24%2FJavascript-%E4%B9%8B-%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[layout: posttitle: Javascript 之 原型和继承subtitle: “JS this”date: 2019-04-24 14:32:03author: “幽僻处的行人”header-mask: 0.3categories: - javascript catalog: true tags: - javascript 等待研究]]></content>
  </entry>
  <entry>
    <title><![CDATA[javascript 之 this]]></title>
    <url>%2F2019%2F04%2F19%2Fjavascript-%E4%B9%8B-this%2F</url>
    <content type="text"><![CDATA[学习需要静下心来，认真的研究一个问题。 为什么要有this ?var f = function () { console.log(x); } 这里有个函数，内部使用了一个变量，这个变量由函数的运行环境提供。 现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 例题： var f = function () { console.log(this.x); } var x = 1; var obj = { f: f, x: 2, }; // window 环境执行 f() // 1 // obj 环境执行 obj.f() // 2 有哪些运行环境呢？在实际应用中，this的运行环境（也就是指向）大致可以分为下面4种： 作为 window 的环境 a() 作为 对象 的环境 obj.a() 作为 构造函数 的环境 var b = new a(); function.prototype.call或function.prototype.apply 环境下 作为 箭头函数 环境 （ES6） 下面是分别概括。 作为 window 的环境在严格模式下绑定到 undefined，否则绑定到全局对象。 作为 对象 的环境哪个函数调用就指向到那个对象上。 作为 构造函数 的环境指向到新创建的对象，注意：显示return函数或对象，返回值不是新创建的对象，而是显式返回的函数或对象。 call 或者 apply（ 或者 bind） 严格模式下，指向到指定的第一个参数。 非严格模式下，null和undefined，指向全局对象（浏览器中是window） 其余值指向被new Object()包装的对象。 ES6 中的箭头函数箭头函数内没有this，箭头函数的this是父级函数的this 不会使用上文的四条标准的绑定规则， 而是根据当前的词法作用域来决定this， 具体来说， 箭头函数会继承外层函数，调用的 this 绑定（ 无论 this 绑定到什么），没有外层函数，则是绑定到全局对象（浏览器中是window）。 这其实和 ES6 之前代码中的 self = this 机制一样。 其他环境DOM事件函数：一般指向绑定事件的DOM元素，但有些情况绑定到全局对象（比如IE6~IE8的attachEvent）。 一定要注意，有些调用可能在无意中使用普通函数绑定规则。 如果想“ 更安全” 地忽略 this 绑 定， 你可以使用一个对象， 比如ø = Object.create(null)， 以保护全局对象。 考点：面试官考察this指向就可以考察new、call、apply、bind，箭头函数等用法。从而扩展到作用域、闭包、原型链、继承、严格模式等。这就是面试官乐此不疲的原因。 小小沧海：一道常被人轻视的前端JS面试题从这两套题，重新认识JS的this、作用域、闭包、对象 扩展文章出处 点击查看]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之事件循环机制和任务队列]]></title>
    <url>%2F2019%2F04%2F19%2FJS%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[简单的认识事件循环先看一段代码：（先热个身）12345678910111213console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);Promise.resolve().then(function() &#123; console.log(&apos;promise1&apos;);&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;); 打印顺序是什么？ 正确答案是：script start, script end, promise1, promise2, setTimeout 没关系 继续看 需要知道的专业名词术语： synchronous：同步任务 asynchronous：异步任务 task queue/callback queue：任务队列 execution context stack：执行栈 heap：堆 stack：栈 macro-task：宏任务 micro-task：微任务 首先我们还要知道两点：JavaScript是单线程的语言Event Loop是javascript的执行机制 异步任务包括：宏任务 和 微任务 同步任务：promise内的函数属于同步 .then()内部才属于异步微服务 new Promise(function(resolve) { console.log(‘7’); //属于同步任务 resolve();}).then(function() { console.log(‘8’) //属于异步微服务}) 宏任务： 包括整体代码script setTimeout setInterval setImmediate 微任务： 原生Promise(有些实现的promise将then方法放到了宏任务中) process.nextTick （process.nextTick(callback)类似node.js版的&quot;setTimeout&quot;） Object.observe(已废弃) MutationObserver 记住就行了。 事件循环规则： 骚年 先接我八字真言：先同后异，先微后宏 实例： Promise.resolve().then(()=&gt;{ console.log(&apos;Promise1&apos;) setTimeout(()=&gt;{ console.log(&apos;setTimeout2&apos;) Promise.resolve().then(()=&gt;{ console.log(&apos;Promise3&apos;) setTimeout(()=&gt;{ Promise.resolve().then(()=&gt;{ console.log(&apos;Promise5&apos;) setTimeout(()=&gt;{ console.log(&apos;setTimeout6&apos;) },0) }) console.log(&apos;setTimeout4&apos;) },0) }) },0) }) 先从上到下执行同步任务并全部执行完成 查找异步任务并分配到微任务列表 和 宏任务列表 （每个列表里先进栈先执行） 先执行微服务，并且查找微服务内部的 异步任务然后分配到微任务列表 和 宏任务列表 再执行宏任务，并且查找微服务内部的 异步任务然后分配到微任务列表 和 宏任务列表 既然是事件循环就不是一次就执行完毕了的，因为异步任务会有嵌套，最外层事件最先暴露出来，首先进入第一次循环 再先执行微服务，并查找，分配 再执行宏任务，并查找，分配 依次循环直至没有异步任务 执行结束 12345678910111213Promise.resolve().then(()=&gt;&#123; console.log(&apos;Promise1&apos;) setTimeout(()=&gt;&#123; console.log(&apos;setTimeout2&apos;) &#125;,0)&#125;)setTimeout(()=&gt;&#123; console.log(&apos;setTimeout1&apos;) Promise.resolve().then(()=&gt;&#123; console.log(&apos;Promise2&apos;) &#125;)&#125;,0) 第一回合 列出所有异步事件并逐个分配到宏服务和微任务里去，然后执行 先微后宏 微：promise1 宏：setTimeout1 先打印Promise1，setTimeout2进宏任务列表 setTimeout1，Promise2进微任务列表 第二回合 执行异步列表 先微后宏 先打印Promise2， 再打印setTimeout2， 到这里是不是有个大概的了解了，测验来了：（先用纸笔根据自己理解先答一遍，然后再看答案） 123456789101112131415161718192021222324252627282930313233343536console.log(&apos;1&apos;);setTimeout(function() &#123; console.log(&apos;2&apos;); process.nextTick(function() &#123; console.log(&apos;3&apos;); &#125;) new Promise(function(resolve) &#123; console.log(&apos;4&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;5&apos;) &#125;)&#125;)process.nextTick(function() &#123; console.log(&apos;6&apos;);&#125;)new Promise(function(resolve) &#123; console.log(&apos;7&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;8&apos;)&#125;)setTimeout(function() &#123; console.log(&apos;9&apos;); process.nextTick(function() &#123; console.log(&apos;10&apos;); &#125;) new Promise(function(resolve) &#123; console.log(&apos;11&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;12&apos;) &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 宏任务Event Queue 微任务Event Queue setTimeout1 process1 setTimeout2 then1 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。 new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2 宏任务Event Queue 微任务Event Queue setTimeout2 process3 then3 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 结尾听到别人在讨论事件循环，我很想帮他们解答，可是我给出的答案都睡服不了我自己。所以决定自己整理一篇，我觉得可以让人理解的文章。下面还有别人的文章，建议大家多看看。广开言路，纳百家之言，行天下大事。 ⬇⬇⬇⬇⬇下方有补充 奉上文章： JS事件循环机制（event loop）之宏任务/微任务 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈 补充 2019年4月28号：有一个地方被我忽略了 123456789101112131415new Promise(function(resolve) &#123; console.log(&apos;6&apos;); setTimeout(function () &#123; console.log(&apos;7&apos;); resolve(); &#125;,0) // resolve();&#125;).then(function() &#123; console.log(&apos;8&apos;)&#125;)&gt;6&gt;7&gt;8 resolve()如果写在定时器里面了，会使then处于等待状态，如果写在定时器外面这输出：6 8 7 2019年5月22号: 练习 123456789101112131415161718192021222324new Promise((resolve, reject) =&gt; &#123; console.log(&quot;promise1&quot;) resolve() &#125;).then(() =&gt; &#123; console.log(&quot;then11&quot;) new Promise((resolve, reject) =&gt; &#123; console.log(&quot;promise2&quot;) resolve() &#125;).then(() =&gt; &#123; console.log(&quot;then21&quot;) &#125;).then(() =&gt; &#123; console.log(&quot;then23&quot;) &#125;) &#125;).then(() =&gt; &#123; console.log(&quot;then12&quot;) &#125;)promise1then11promise2then21then12then23 下面是说明用例 new Promise((resolve, reject) =&gt; { console.log(&quot;1&quot;) resolve() }).then(() =&gt; { console.log(&quot;2&quot;) setTimeout(function() { console.log(&quot;22&quot;) }, 0) new Promise((resolve, reject) =&gt; { console.log(&quot;3&quot;) resolve() }).then(() =&gt; { console.log(&quot;4&quot;) }).then(() =&gt; { console.log(&quot;5&quot;) }).then(() =&gt; { console.log(&quot;12&quot;) }) }).then(() =&gt; { console.log(&quot;6&quot;) }).then(() =&gt; { console.log(&quot;11&quot;) }).then(() =&gt; { console.log(&quot;13&quot;) }) 总结： 1.promise后面的n多个then 在同一个事件回合里 由上到下 依次加入微列表 内外promise的同位then（两个promise的第2个then，由外到内，依次添加到微列表）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CleanMyMac X]]></title>
    <url>%2F2019%2F04%2F17%2FCleanMyMac%20X%2F</url>
    <content type="text"><![CDATA[CleanMyMac X破解1.下载破解版下载地址 2.解压并打开dmg文件 双击上图红框位置 双击CleanMyMac X 4.3.0 [TNT].dmg 将程序拖入Application即可 3.破解双击Open Gatekeeper friendly 一路回车即可 4.错误提示 1.XXX文件已损坏，需要移到废纸篓。 解决方法一： 终端运行 sudo spctl --master-disable 重新运行程序 解决方法二： xattr -r -d com.apple.quarantine /Applications/CleanMyMac\ X.app /Applications/CleanMyMac\ X.app是CleanMyMac X 运行此命令，需要自己对应到程序的安装目录 2.提示文件不信任 解决方法一： Control+单击右键打开 解决方法二： 终端运行 sudo spctl --master-disable 更改为任何来源 3.CleanMyMac X 因出现问题而无法打开 解决方法一： 运行此命令 sudo codesign --force --deep --sign - /Applications/CleanMyMac\ X.app 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈 备注 2019年4月17日 亲测 macOS Mojave 10.14.4 可用]]></content>
      <categories>
        <category>软件</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好了歌注]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%A5%BD%E4%BA%86%E6%AD%8C%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[[宋] 曹雪芹 1234567891011121314151617陋室空堂，当年笏满床；衰草枯杨，曾为歌舞场。蛛丝儿结满雕梁，绿纱今又糊在蓬窗上。说什么脂正浓，粉正香，如何两鬓又成霜？昨日黄土陇头送白骨，今宵红灯帐底卧鸳鸯。金满箱，银满箱，展眼乞丐人皆谤。正叹他人命不长，那知自己归来丧！训有方，保不定日后作强梁。择膏粱，谁承望流落在烟花巷！因嫌纱帽小，致使锁枷杠，昨怜破袄寒，今嫌紫蟒长：乱烘烘你方唱罢我登场，反认他乡是故乡。甚荒唐，到头来都是为他人作嫁衣裳！ 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>诗词</category>
        <category>词</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的防抖和节流]]></title>
    <url>%2F2019%2F04%2F17%2FJS%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[前言：今天做了一个功能，input 扫码枪扫码输入然后查询设备添加列表，扫码枪的输入频率是几十毫秒， 如果监听 onchange 事件效果也会如下图所示触发很多次并且每一次 onchange 都会触发查询请求。 显然这不是我要的解决方案。后来查询了扫码枪的配置，原来可以设置自动回车功能。监听 onkeypress 事件完美解决。但是今天的重点是函数的防抖与节流， 那我们就赶紧拿笔记下知识点吧 ！` 在浏览器中如果一个事件被频繁触发，比如输入框的 keyup, 窗口的 resize 以及 scroll 事件等，如果不做任何处理，事件的回调函数将会对应执行，这必然会加重浏览器的负担，影响用户的体验。面对这种场景，我们可以用函数的防抖 (debounce) 和节流 (throttle) 来处理。 函数防抖防抖 debounce: 让事件触发时的回调在一定的延时后执行。如果在计时期间又触发了事件，则重新开始计时。 比如在做一个检索的输入框，输入的内容发送给后台查询。如果不做防抖处理我们来看下： &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt; 用打印来模拟请求处理： 123456用打印来模拟请求处理：var ipt = document.getElementById(&apos;input&apos;);ipt.addEventListener(&apos;keyup&apos;, function(e)&#123; console.log(e.target.value);&#125;); 结果如下： 可见，每次触发事件都会执行回调函数，现在加入防抖处理： 12345678910111213141516171819var debounce = function(func, delay) &#123; var timer = null return function() &#123; var that = this; var args = arguments; if(timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(function() &#123; func.apply(that, args); &#125;, delay) &#125;&#125;ipt.addEventListener(&apos;keyup&apos;, debounce(function(e)&#123; console.log(e.target.value);&#125;, 400)) 效果如下： 可见，输入框在停止输入400ms后执行回调。在防抖后的回调函数用 timer 记录计时，每次执行回调的时候会先清空之前的计时。注意这里的timer是闭包变量，始终保持着上一个计时。 函数节流节流throttle: 让事件的回调一定时间间隔只执行一次。节流函数有两种实现方式，一种是记录增量，一种是定时方式。 用增量的方式实现节流： 1234567891011121314151617var throttle = function(func, delay) &#123; var pre = Date.now(); return function() &#123; var that = this; var args = arguments; var now = Date.now(); if (now - pre &gt;= delay) &#123; func.apply(that, args); pre = now; &#125; &#125;&#125;ipt.addEventListener(&apos;keyup&apos;, throttle(function(e)&#123; console.log(e.target.value);&#125;, 1000)) 节流的效果如下： 可见，无论怎么输入，事件回调总会在1s内执行一次。而且第一次输入会马上执行，这是因为处理节流的时候和第一次触发的时间间隔大于1s。但是最后一次触发不会执行回调。 利用计时方式处理节流： 1234567891011121314var throttle = function(func, delay) &#123; var timer = null; return function() &#123; var that = this; var args = arguments; if(!timer) &#123; timer = setTimeout(function() &#123; func.apply(that, args); timer = null; &#125;, delay) &#125; &#125;&#125; 利用变量 timer 记录定时器，如果定时器存在，则不执行回调。否则创建一个延时器执行回调。这种方法和时间戳增量的区别就是第一个触发不会立即执行回调，但是最后一次时间会在延时后触发回调函数。 如果想要立即触发并且最后一次也要执行回调，可以利用时间戳和计时方式结合在实现节流： 123456789101112131415161718192021var throttle = function(func, delay) &#123; var timer = null; var pre = Date.now(); return function() &#123; var now = Date.now(); var that = this; var args = arguments; var remain = delay - (now - pre); clearTimeout(timer); if (remain &lt;= 0) &#123; func.apply(that, args); pre = now &#125;else &#123; timer = setTimeout(function() &#123; func.apply(that, args); pre = now; &#125;, remain) &#125; &#125;&#125; 上面的节流函数会先判断剩余的间隔时间，如果剩余时间小于0，则立即执行。否则创建一个剩余时间的定时。注意，每次要记得清空之前的定时。 应用场景防抖 debounce 一般用来在输入检索，节约请求的资源。还有窗口的 resize，让不断调节窗口大小的最后一次触发。 节流 throttle 一般用在鼠标不断点击，让点击的回调按间隔执行一次。还有滑动 scroll 事件， 比如滚动到底部查询，按间隔请求一次数据来显示。 感想：有的时候灵感也是能力的一部分 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈 原文：https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悼允上人]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%82%BC%E5%85%81%E4%B8%8A%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[[宋] 释行海 白云寺里同听讲，卜得山斋竹树幽。 君已不来梅自发，世皆如梦水长流， 寒灯苦志归黄土，俗客轻人将白头。 万惜少年多是死，静思吾道转堪愁。 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>诗词</category>
        <category>诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EVP_DecryptFinal_ex:bad decrypt 和 出现Illegal Buffer Error这种的情况]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%88%E6%9D%83%E9%97%AE%E9%A2%981%2F</url>
    <content type="text"><![CDATA[看到这里 你的问题就不要担心了 大家的问题都是一样的。官网的实例是没问题的 当前 Bug 的表现 - 预期表现可以对encryptedData正常解密。 复现路径点击登录按钮后，小程序本地数据缓存冷启动后还还会有吗，微信小程序教程。小程序调用wx.login()，再将code、iv、encrypedData一起发往后端程序，后端程序调用微信api接口（api.weixin.qq.com/sns/jscode2session）希望获取openId，但经常会出现上图中的错误。 复现过程： 1、这个问题不是持续连续发生，而是在一段时间未操作小程序时，再次点击登录按钮触发登录操作的第一次时会发生，第二次及以后的登录操作则会成功。如果再过一段时间未操作小程序，当第一次登录的时候还是会出现这个现象——第一次登录不成功，后续登录操作可以成功。 2、问题的关键在于解密程序报错。将上述的ecryptedData、iv、session_key放入官方文档（貌似其中还有包括使用wx.getUserInfo()的描述，是否也要更新一下）中提供的demo.js程序运行，也会出现报错。 下面是我的解决 ： 一定要保证 新code的获取 在 getUserInfo或getPhoneNumber 之前 而且 每一次解密授权所用的code 都不是一样的 onload里先进行wx.login 获取code，再通过按钮开始授权 获取iv和encryptedData 之后就不会报错了 O(∩_∩)O哈哈~ 这可能也是 小程序考虑授权先后出现的错误问题 才把全部授权按钮使用主动触发的方式的 解决方案的出处：https://developers.weixin.qq.com/community/develop/doc/000808d32c06101b39d6032c956000 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>小程序授权问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客 NexT主题从v5更新到v6的记录及总结.md]]></title>
    <url>%2F2018%2F12%2F03%2F2018-12-03-Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E4%BB%8Ev5-x-x%E6%9B%B4%E6%96%B0%E5%88%B0v6-x-x%E7%9A%84%E8%AE%B0%E5%BD%95%E5%8F%8A%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Hexo博客 NexT主题从v5更新到v6的记录及总结今天索性升级一下我的主题 自定义配置样式还是很多的 需要详细修改配置https://sevencho.github.io/archives/14534beb.html #丰富插件和功能 参考博客https://zhuanlan.zhihu.com/p/26625249 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>Hexo</category>
        <category>NexT</category>
      </categories>
      <tags>
        <tag>NexT</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6之var let 和 const终极PK]]></title>
    <url>%2F2018%2F08%2F02%2Fes6%E4%B9%8Bvar-let-%E5%92%8C-const%E7%BB%88%E6%9E%81PK%2F</url>
    <content type="text"><![CDATA[直接上猛料 let 取代 varES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。 &apos;use strict&apos;; if (true) { let x = &apos;hello&apos;; } for (let i = 0; i &lt; 10; i++) { console.log(i); } 上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。 var命令存在变量提升效用，let命令没有这个问题。 &apos;use strict&apos;; if(true) { console.log(x); // ReferenceError let x = &apos;hello&apos;; } 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。 所以，建议不再使用var命令，而是使用let命令取代。 在let和const之间，建议优先使用const尤其是在全局环境，不应该设置变量，只应设置常量。 const优于let有几个原因。 一个是const可以提醒阅读程序的人，这个变量不应该改变； 另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算； 最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。 // bad var a = 1, b = 2, c = 3; // good const a = 1; const b = 2; const c = 3; // best const [a, b, c] = [1, 2, 3]; const 声明常量还有两个好处， 阅读代码的人立刻会意识到不应该修改这个值， 防止了无意间修改变量值所导致的错误。 所有的函数都应该设置为常量。 感想：长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 这里有var、let、const 区别？详尽对比和分析 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6之顶层对象的属性]]></title>
    <url>%2F2018%2F06%2F24%2Fes6%E4%B9%8B%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[顶层对象的属性顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。 window.a = 1; a // 1 a = 2; window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 var a = 1; // 如果在Node的REPL环境，可以写成global.a // 或者采用通用方法，写成this.a window.a // 1 let b = 1; window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。Node 里面，顶层对象是global，但其他环境都不支持。同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 // 方法一 (typeof window !== &apos;undefined&apos; ? window : (typeof process === &apos;object&apos; &amp;&amp; typeof require === &apos;function&apos; &amp;&amp; typeof global === &apos;object&apos;) ? global : this); // 方法二 var getGlobal = function () { if (typeof self !== &apos;undefined&apos;) { return self; } if (typeof window !== &apos;undefined&apos;) { return window; } if (typeof global !== &apos;undefined&apos;) { return global; } throw new Error(&apos;unable to locate global object&apos;); }; 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。 垫片库system.global模拟了这个提案，可以在所有环境拿到global。 // CommonJS的写法 require(&apos;system.global/shim&apos;)(); // ES6模块的写法 import shim from &apos;system.global/shim&apos;; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 // CommonJS的写法 var global = require(&apos;system.global&apos;)(); // ES6模块的写法 import getGlobal from &apos;system.global&apos;; const global = getGlobal(); 上面代码将顶层对象放入变量global。 感想：存在即合理 只是一个说辞 我们需要做的是不断的完善它，让它真的合理。毕竟罗马不是一日建成的！ 这里有var、let、const 区别？详尽对比和分析，希望可以帮你更好的理解。 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6之let 和 const]]></title>
    <url>%2F2018%2F06%2F22%2Fes6%E4%B9%8Blet-%E5%92%8C-const%2F</url>
    <content type="text"><![CDATA[let 命令##let特性： ###1.只在let命令所在的代码块内有效。 a. { let a = 10; var b = 1; } a // ReferenceError: a is not defined. b // 1 b. （let 与 for循环的用法） 要求必须 等let声明语句执行完之后，变量才能使用，不然会报Uncaught ReferenceError错误。 var a = []; for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 如同for 循环里产生了10次i的循环并没有被更新 a[2](); // 2 a[4](); // 4 a[7](); // 7 a[0](); // 0 #2.不存在变量提升 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; ###3.暂时性死区 console.log(aicoder); // 错误：Uncaught ReferenceError ... let aicoder = &apos;aicoder.com&apos;; // 这里就可以安全使用aicoder 有些“死区”比较隐蔽，不太容易发现。 function bar(x = y, y = 2) { return [x, y]; } bar(); // 报错 //因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 ###4.let变量不能重复声明 let a = 0; let a = &apos;sss&apos;; // Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared ######**ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。 ######总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 #2. 块级作用域 为什么需要块级作用域？ 第一：内层变量可能会覆盖外层变量。 var tmp = new Date(); function f() { console.log(tmp); if (false) { var tmp = &quot;hello world&quot;; } } f(); // undefined 第二：用来计数的循环变量泄露为全局变量。 var s = &apos;hello&apos;; for (var i = 0; i &lt; s.length; i++) { console.log(s[i]); } console.log(i); // 5 块级作用域特点： 1.ES6允许块级作用域的任意嵌套。 {{{{{let insane = 'Hello World'}}}}}; 2.允许在块级作用域之中声明函数。 // ES6严格模式 &apos;use strict&apos;; if (true) { function f() {} } // 不报错 ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 特别注意： ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 // 不报错 &apos;use strict&apos;; if (true) { function f() {} } // 报错 &apos;use strict&apos;; if (true) function f() {} #const命令 1.const声明一个只读的常量。一旦声明，常量的值就不能改变。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. 2.const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 const foo; // SyntaxError: Missing initializer in const declaration 3.const的作用域与let命令相同：只在声明所在的块级作用域内有效。 if (true) { const MAX = 5; } MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 if (true) { console.log(MAX); // ReferenceError const MAX = 5;} const声明的常量，也与let一样不可重复声明。 var message = “Hello!”;let age = 25; // 以下两行都会报错const message = “Goodbye!”;const age = 30; 6.对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 const foo = {};foo.prop = 123; foo.prop// 123 foo = {}; // TypeError: “foo” is read-only 下面是另一个例子（可以为其添加新属性。） const a = [];a.push(‘Hello’); // 可执行a.length = 0; // 可执行a = [‘Dave’]; // 报错 ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。 感想：明白了前辈们对javascript的不断的优化的心情，感谢他们的贡献我将好好细读文档。不服厚爱！ 这里有var、let、const 区别？详尽对比和分析 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6之变量的解构赋值]]></title>
    <url>%2F2018%2F06%2F20%2Fes6%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[ES6 变量的解构赋值数组的解构赋值基本用法ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 123var a = 1;var b = 2;var c = 3; ES6允许写成下面这样。 1var [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 1234567891011121314151617181920[foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = [&apos;a&apos;];x // &quot;a&quot;y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。123var [foo] = [];var [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。 解构赋值不仅适用于var命令，也适用于let和const命令。 123var [v1, v2, ..., vN ] = array;let [v1, v2, ..., vN ] = array;const [v1, v2, ..., vN ] = array; 对于Set结构，也可以使用数组的解构赋值。 12let [x, y, z] = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);x // &quot;a&quot; 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。 1234567891011function* fibs() &#123; var a = 0; var b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;var [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 上面代码中，fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。 默认值解构赋值允许指定默认值。123456var [foo = true] = [];foo // true[x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;[x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos; 注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 123456var [x = 1] = [undefined];x // 1var [x = 1] = [null];x // null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() &#123; console.log(&apos;aaa&apos;);&#125;let [x = f()] = [1]; 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。 123456let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。 对象的解构赋值解构不仅可以用于数组，还可以用于对象。1234var &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot; 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。1234567var &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;var &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。 如果变量名与属性名不一致，必须写成下面这样。12345678var &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;baz // &quot;aaa&quot;let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;let &#123; first: f, last: l &#125; = obj;f // &apos;hello&apos;l // &apos;world&apos; 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。 123456var &#123; foo: foo, bar: bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。var &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // &quot;aaa&quot;foo // error: foo is not defined 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。123456let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration &quot;foo&quot;let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration &quot;baz&quot; 上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。123456let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功 上面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。 和数组一样，解构也可以用于嵌套结构的对象。1234567891011var obj = &#123; p: [ &apos;Hello&apos;, &#123; y: &apos;World&apos; &#125; ]&#125;;var &#123; p: [x, &#123; y &#125;] &#125; = obj;x // &quot;Hello&quot;y // &quot;World&quot; 注意，这时p是模式，不是变量，因此不会被赋值。1234567891011121314var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // error: loc is undefinedstart // error: start is undefined 上面代码中，只有line是变量，loc和start都是模式，不会被赋值。 下面是嵌套赋值的例子。12345678let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true] 对象的解构也可以指定默认值。12345678910111213141516var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = &apos;Something went wrong&apos; &#125; = &#123;&#125;;msg // &quot;Something went wrong&quot; 默认值生效的条件是，对象的属性值严格等于undefined。123456var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。 如果解构失败，变量的值等于undefined。123var &#123;foo&#125; = &#123;bar: &apos;baz&apos;&#125;;foo // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 12// 报错var &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &apos;baz&apos;&#125;; 上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。123var _tmp = &#123;baz: &apos;baz&apos;&#125;;_tmp.foo.bar // 报错 如果要将一个已经声明的变量用于解构赋值，必须非常小心。12345// 错误的写法var x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。 12// 正确的写法(&#123;x&#125; = &#123;x: 1&#125;); 上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。 解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 123(&#123;&#125; = [true, false]);(&#123;&#125; = &apos;abc&apos;);(&#123;&#125; = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 let { log, sin, cos } = Math; 上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234var arr = [1, 2, 3];var &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。1234567const [a, b, c, d, e] = &apos;hello&apos;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。123let &#123;length : len&#125; = &apos;hello&apos;;len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。123456let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。123let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值。123456function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 下面是另一个例子。123[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值。123456789function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 注意，下面的写法会得到不一样的结果。123456789function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 undefined就会触发函数参数的默认值。123[1, undefined, 3].map((x = &apos;yes&apos;) =&gt; x);// [ 1, &apos;yes&apos;, 3 ] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况以下三种解构赋值不得使用圆括号。 （1）变量声明语句中，不能带有圆括号。12345678910// 全部报错var [(a)] = [1];var &#123;x: (c)&#125; = &#123;&#125;;var (&#123;x: c&#125;) = &#123;&#125;;var &#123;(x: c)&#125; = &#123;&#125;;var &#123;(x): c&#125; = &#123;&#125;;var &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。 （2）函数参数中，模式不能带有圆括号。 函数参数也属于变量声明，因此不能带有圆括号。123// 报错function f([(z)]) &#123; return z; &#125; （3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。 123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 12// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 上面代码将嵌套模式的一层，放在圆括号之中，导致报错。 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。1234[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途变量的解构赋值用途很多。 （1）交换变量的值 1[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = example(); （3）函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取JSON数据 解构赋值对提取JSON对象中的数据，尤其有用。1234567891011var jsonData = &#123; id: 42, status: &quot;OK&quot;, data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 上面代码可以快速提取JSON数据的值。 （5）函数参数的默认值 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。 （6）遍历Map结构 任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。12345678910var map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) &#123; console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。12345678910// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; （7）输入模块的指定方法 加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。 `const { SourceMapConsumer, SourceNode } = require(“source-map”); 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6之编码规范]]></title>
    <url>%2F2018%2F06%2F18%2Fes6%E4%B9%8B%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[let 命令##let特性： ###1.只在let命令所在的代码块内有效。 a. { let a = 10; var b = 1; } a // ReferenceError: a is not defined. b // 1 b. （let 与 for循环的用法） 要求必须 等let声明语句执行完之后，变量才能使用，不然会报Uncaught ReferenceError错误。 var a = []; for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 如同for 循环里产生了10次i的循环并没有被更新 a[2](); // 2 a[4](); // 4 a[7](); // 7 a[0](); // 0 #2.不存在变量提升 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; ###3.暂时性死区 console.log(aicoder); // 错误：Uncaught ReferenceError ... let aicoder = &apos;aicoder.com&apos;; // 这里就可以安全使用aicoder 有些“死区”比较隐蔽，不太容易发现。 function bar(x = y, y = 2) { return [x, y]; } bar(); // 报错 //因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 ###4.let变量不能重复声明 let a = 0; let a = &apos;sss&apos;; // Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared ######**ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。 ######总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 #2. 块级作用域 为什么需要块级作用域？ 第一：内层变量可能会覆盖外层变量。 var tmp = new Date(); function f() { console.log(tmp); if (false) { var tmp = &quot;hello world&quot;; } } f(); // undefined 第二：用来计数的循环变量泄露为全局变量。 var s = &apos;hello&apos;; for (var i = 0; i &lt; s.length; i++) { console.log(s[i]); } console.log(i); // 5 块级作用域特点： 1.ES6允许块级作用域的任意嵌套。 {{{{{let insane = 'Hello World'}}}}}; 2.允许在块级作用域之中声明函数。 // ES6严格模式 &apos;use strict&apos;; if (true) { function f() {} } // 不报错 ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 特别注意： ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 // 不报错 &apos;use strict&apos;; if (true) { function f() {} } // 报错 &apos;use strict&apos;; if (true) function f() {} #const命令 1.const声明一个只读的常量。一旦声明，常量的值就不能改变。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. 2.const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 const foo; // SyntaxError: Missing initializer in const declaration 3.const的作用域与let命令相同：只在声明所在的块级作用域内有效。 if (true) { const MAX = 5; } MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 if (true) { console.log(MAX); // ReferenceError const MAX = 5;} const声明的常量，也与let一样不可重复声明。 var message = “Hello!”;let age = 25; // 以下两行都会报错const message = “Goodbye!”;const age = 30; 6.对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 const foo = {};foo.prop = 123; foo.prop// 123 foo = {}; // TypeError: “foo” is read-only 下面是另一个例子（可以为其添加新属性。） const a = [];a.push(‘Hello’); // 可执行a.length = 0; // 可执行a = [‘Dave’]; // 报错 ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。 感想：明白了前辈们对javascript的不断的优化的心情，感谢他们的贡献我将好好细读文档。不服厚爱！ 这里有var、let、const 区别？详尽对比和分析 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改默认浏览器滚动条]]></title>
    <url>%2F2017%2F10%2F08%2F2017-10-8-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BB%9A%E5%8A%A8%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[修改默认浏览器滚动条::-webkit-scrollbar{ width:3px; height:0px;} /* 滚动条的大小 */ ::-webkit-scrollbar-track {background-color: #6d7277;} /* 滚动条的滑轨背景颜色 */ ::-webkit-scrollbar-thumb {background-color:#4b4d50; border-radius:0px;} /* 滑块颜色 */ /*::-webkit-scrollbar-button {background-color: #7c2929;} /* 滑轨两头的监听按钮颜色 ::-webkit-scrollbar-corner {background-color: black;} /* 横向滚动条和纵向滚动条相交处尖角的颜色 */ 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular控制器间的通讯]]></title>
    <url>%2F2017%2F07%2F20%2Fangular%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[ng笔记broadcast&amp;&amp;on&amp;&amp;emit&lt;script&gt; varmyapp=angular.module(&apos;TestApp&apos;,[&apos;ng&apos;]); myapp.controller(&apos;ParentCtrl&apos;,function($scope){ $scope.$on(&apos;to-child&apos;,function(e,d){ console.log(&apos;[ParentCtrl]to-child&apos;); }); $scope.$on(&apos;to-parent&apos;,function(e,d){ console.log(&apos;[ParentCtrl]to-parent&apos;); });}) myapp.controller(&apos;SelfCtrl&apos;,function($scope){ $scope.click=function(){ $scope.$broadcast(&apos;to-child&apos;,&apos;haha&apos;); $scope.$emit(&apos;to-parent&apos;,&apos;hehe&apos;);}}) myapp.controller(&apos;ChildCtrl&apos;,function($scope){ $scope.$on(&apos;to-child&apos;,function(e,d){ console.log(&apos;[ChildCtrl]to-child&apos;); }); $scope.$on(&apos;to-parent&apos;,function(e,d){ console.log(&apos;[ChildCtrl]to-parent&apos;); }); }) myapp.controller(&apos;BroCtrl&apos;,function($scope){ $scope.$on(&apos;to-child&apos;,function(e,d){ console.log(&apos;[BroCtrl]to-child&apos;); }); $scope.$on(&apos;to-parent&apos;,function(e,d){ console.log(&apos;[BroCtrl]to-parent&apos;); }); }); &lt;/script&gt; &lt;div ng-controller=&quot;ParentCtrl&quot;&gt; &lt;div ng-controller=&quot;SelfCtrl&quot;&gt; &lt;a class=&quot;btn&quot;ng-click=&quot;click()&quot;&gt;clickme&lt;/a&gt; &lt;div ng-controller=&quot;ChildCtrl&quot;&gt; &lt;span&gt;{{great}}&lt;/span&gt; &lt;p&gt;参数：{{canshu}}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div ng-controller=&quot;BroCtrl&quot;&gt;{{text}}&lt;/div&gt; &lt;/div&gt; Notes上面的例子可以看到，事件和事件发生者的兄弟是没有关系的，怎样都收不到。 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工欲善其事之markdown教程篇]]></title>
    <url>%2F2017%2F05%2F23%2F%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E4%B9%8Bmarkdown%E6%95%99%E7%A8%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Markdown基本语法1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可4、需要记一些语法（当然，也是很简单的） 一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 示例： # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 效果： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来 示例： **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 效果如下： 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例： &gt;这是引用的内容 &gt;&gt;这是引用的内容 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： --- ---- *** ***** 效果如下：可以看到，显示效果是一样的。 五、图片语法：![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例：![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/ u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下： 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法：】 [超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 示例： [百度](http://baidu.com) 效果如下： 百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 示例： &lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt; 效果如下：百度 七、列表##无序列表 语法： 无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表语法： // 数字加点 1.列表内容 2.列表内容 3.列表内容 注意：序号跟内容之间要有空格 效果如下： 1.列表内容2.列表内容3.列表内容 列表嵌套这里语法有些不同如下： - 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容 1. 一级有序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 2. 一级有序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容 4. 二级有序列表内容 八、表格语法： 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 示例： | 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 效果如下： 左对齐 居中对齐 右对齐 单元格 单元格 单元格 单元格 单元格 单元格 九、代码 注：直接tab 缩进或四个空格 也可以实现代码块 语法： 单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 点点点 代码... 代码... 代码... 点点点 注：为了防止转译，前后三个反引号使用’点点点’，实际是没有的 3个`。这里只是用来演示。 示例： 单行代码 `create database hero;` 代码块 点点点 function fun(){ echo &quot;这是一句非常牛逼的代码&quot;; } fun(); 点点点 效果如下： 单行代码 create database hero; 代码块 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 感想：语法虽然很简单还是多使用才能得心应手 来源：简书作者：高鸿祥链接：https://www.jianshu.com/p/191d1e21f7ed 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习是一件逆人性的事]]></title>
    <url>%2F2016%2F12%2F02%2F%E5%AD%A6%E4%B9%A0%E6%98%AF%E4%B8%80%E4%BB%B6%E9%80%86%E4%BA%BA%E6%80%A7%E7%9A%84%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[投资自己的时间其实，时间就像金钱一样，你得学会投资时间，把时间投资在有价值有意义的地方，你就会有“更多的时间”。 1.花时间学习基础知识，花时间读文档。 我发现，很多程序员都把时间都浪费在了查错上。究其根本原因就是基础知识不完整，没有好好地把技术相关的用户文档读完就仓促上手做事情了。其实只要把基础打扎实，认真读一下文档，你会省出很多很多的时间。系统地学习一门技术是非常关键的，所以这个时间是值得投资的。 2.花时间在解放自己生产力的事上。 在自动化、可配置、可重用、可扩展上要多花时间。对于软件开发来说，能自动化的事，就算多花点时间也要自动化，因为下次就不用花时间了。让自己的软件模块可以更灵活地配置和扩展，这样如果有需求变更或是有新需求的时候，可以不用改代码，或者就算要改代码也很容易。这里，可能很多人会说不要过度设计，对于这个观点，我既同意，也反对。的确，过度设计不好，但是只要是能在未来节省时间的，宁可这个项目延期，我也会做的。花时间在解放自己的事上是最有意义的了。 3.花时间在让自己成长的事上。注意，晋升并不代表成长，成长不应该只看在一个公司内，而是要看在行业内，在行业内的成长才是真正的成长。所以，把时间花在能让自己成长，能让自己有更强的竞争力，能让自己有更大的视野，能让自己有更多可能性的事情上。这样的时间投资才是有价值的。 4.花时间在建立高效的环境上。我相信你和我会有一样的一个习惯，那就“工欲善其事，必先利其器”。我们程序员在做事之前都喜欢把自己的工作环境整理到自己喜欢的状态下。比如使用趁手的开发工具，使用趁手的设备。这里，我想把这个事扩大一下，花些时间在影响你身边的人上，比如你的同事，你的产品经理，你的老板，去影响他们，让他们理解你，让他们配合你来建立更好的流程和管理方法。在这个方向上花时间也是很值得的。 规划自己的时间定义好优先级。无论你写不写出来，你一定都会有一个自己的 to-do list。有 to-do list 并不是什么高深的事。更重要的是，你要知道什么事是重要的，什么事是紧急的，什么事重要但不紧急，什么事又重要又紧急。这有利于你划分优先级。 最短作业优先。对于相同优先级的事，我个人喜欢的是“最短作业优先”的调度算法。理由是，先把可以快速做完的事做完，看到 to-do list 上划掉一个任务，看到任何的数据在减少，对于自己也好，对于老板也好。老板可以看到你的工作进度飞快，一方面有利于为后面复杂的工作争取更多的时间（老板只有在你有 Deliver 的时候才愿意给你更多的时间），另一方面，看到任务列表的减少会让你的心态更为积极。 而反过来，你花太多的时间在长作业上，长作业通常很容易出现“意外情况”让你花更多的时间，但此时你发现还有很多别的事没有做，这会让你产生焦虑感，产生更多的压力，进而导致更慢的生产效率。 想清楚再做。我发现很多时候，我们没有想清楚就开干了，边干边想，这样的工作方式其实很糟糕。你会发现，如果你没有想清楚，你总是要对已完成的工作进行返工，返工好几次，其实是非常浪费时间的。 所以，对于一些没想清楚的事，或是自己不太有信心的事，还是先看看有没有已有的成熟解决方案，或是找更牛的人来给你把把关，帮你出出主意，看看有没有更好、更简单的方式。 关注长期利益规划。要多关注长远可以节省多少时间，而不是当前会花费多少时间。长期成本会比短期成本大得多。所以，宁可在短期延期，也不要透支未来。这里的逻辑是，工作上的事你永远也做不完的，长痛不如短痛。 我一年要做 10 个项目，我宁可第 1 或第 2 个项目被老板骂，但是我可以赢得后面 8 个项目，从后面 8 个项目上把之前失去的找回来。而如果反过来的话，我虽然一开始得到了老板的信任，但是后面越来越玩不动，最终搬起一块大石头砸了自己的脚。而且，不关注长远利益的人，基本上来说也是很难有成长的。 也就是说，你要学会规划自己的行动计划，不是短期的，而是一个中长期的。我个人建议是按季度来规划，这个季度做什么，达到什么目标，一年往前走四步，而不是只考虑眼下。 用好自己的时间将军赶路不追小兔。这个世界有太多的东西会让我们分心和跑偏。能专注地把时间投入到一个有价值的事上是非常重要的。确定自己的目标，专注达到这个目标，而不是分心。将军的目标是要攻城，而不是追兔子。所以，你要学会过滤掉与自己目标无关的事，不要让那些无关的事控制自己。 比如，不要让别人来影响自己的心情，心情被影响了，你一下就会什么都不想干了。做自己心情的主人，不要让别人 hack 了你的心情。再比如，知道哪些是自己可以控制的事，哪些是自己控制不了的事，在自己能控制的地方花时间。 再比如，知道哪些是更有效的路径，是花时间改变别人，还是花时间去寻找志同道合的人。不与不如自己的人争论，也不要尝试花时间去叫醒那些装睡的人，这些都是非常浪费时间的事。多花时间在有产出的事上，少花时间在说服别人的事上。 形成习惯。再好的方法，如果没有形成习惯，不能在实际的工作和生活中解决实际问题，都将成为空谈。如果你是个追求上进的人，我相信一定看过很多时间管理方法的文章和书籍，并且看的时候还会有些振奋，内心有时还会不自觉地想，“嗯，嗯！这个方法不错，正是我需要的，可以解决我的问题……”但很多时候都坚持不了几天就抛之脑后了。 所以，在讲述完如何争取时间，及如何使用时间之后，我想分享一下如何将这些时间管理方法形成习惯，因为我坚信：“做”比“做好”更重要。养成一个好习惯通常需要 30 天左右的时间，尤其在最初的几天就更为重要了。这时，不妨将文章中提到的方法和几个要点，写在某本书或者笔记本的扉页上，方便查看，时刻提醒自己。 而且，你可以结合自己的实际情况，适当做出调整。我的方法是我根据自己的情况总结的，不一定完全适合你，你完全可以基于我说的几个原则，发掘其他更适合自己的方法，这样才能更有利于形成习惯，对你更有帮助。 形成正反馈。在前面的文章中，我提到过，要有正反馈，也就是成就感，有助于完成一些看似难以完成的事儿。比如，我们说过，学习是逆人性的事儿，但如果在学习过程中不断地有正反馈，就更利于我们坚持下去。要让自己有正反馈，那就需要把时间花在有价值的地方，比如，解决自己和他人的痛点，这样你会收获别人的赞扬和鼓励。 反思和举一反三。可以尝试每周末花上点时间思考一下，本周做了哪些事儿？时间安排是否合理？还有哪些可以优化提高的地方？有点儿类似于我们常说的“复盘”。然后思考一下，下周的主要任务是什么？并根据优先级规划一下完成这些任务的顺序，也就是做一些下周的工作规划。 这样每周都能及时得到自己做时间管理之后的反馈，并有助于持续优化。通常坚持做时间管理一段时间以后，你都能在每次复盘时得到正反馈，这是有利于我们形成时间管理习惯的。但我这里也想强调一点，我们也要允许偶尔的“负反馈”，因为人的状态总是会有高潮和低谷的，控制好一个合理的度就可以了。 人最宝贵的财富就是时间，把时间用在刀刃上，必将让你的人生有更多收获。 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F05%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[就在这里写一些，搭建成功的心情吧。 首先，有点小喜悦。搭建成功，也是经历9981难的。 其次，需要抽些时间把我的学习成长的路径，我的每一步脚印从我的笔记里，搬出来。整理在这里，供”未来人” 借鉴，交流和学习。 最后，感谢全世界这么多的开源项目的开发者的大力贡献。 The peace of the world Hello worldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
