<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[把酒问月]]></title>
    <url>%2F2019%2F04%2F26%2F%E6%8A%8A%E9%85%92%E9%97%AE%E6%9C%88%2F</url>
    <content type="text"><![CDATA[[唐] 李白 青天有月来几时，我今停杯一问之：人攀明月不可得，月行却与人相随？皎如飞镜临丹阙，绿烟灭尽清辉发？但见宵从海上来，宁知晓向云间没？白兔捣药秋复春，嫦娥孤栖与谁邻？今人不见古时月，今月曾经照古人。古人今人若流水，共看明月皆如此。唯愿当歌对酒时，月光长照金樽里。]]></content>
      <categories>
        <category>诗词</category>
        <category>诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 之 原型和继承]]></title>
    <url>%2F2019%2F04%2F24%2FJavascript-%E4%B9%8B-%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[layout: posttitle: Javascript 之 原型和继承subtitle: “JS this”date: 2019-04-24 14:32:03author: “幽僻处的行人”header-mask: 0.3categories: - javascript catalog: true tags: - javascript 等待研究]]></content>
  </entry>
  <entry>
    <title><![CDATA[javascript 之 this]]></title>
    <url>%2F2019%2F04%2F19%2Fjavascript-%E4%B9%8B-this%2F</url>
    <content type="text"><![CDATA[等待研究]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之事件循环机制和任务队列]]></title>
    <url>%2F2019%2F04%2F19%2FJS%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[简单的认识事件循环先看一段代码：（先热个身）12345678910111213console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);Promise.resolve().then(function() &#123; console.log(&apos;promise1&apos;);&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;); 打印顺序是什么？ 正确答案是：script start, script end, promise1, promise2, setTimeout 没关系 继续看 需要知道的专业名词术语： synchronous：同步任务 asynchronous：异步任务 task queue/callback queue：任务队列 execution context stack：执行栈 heap：堆 stack：栈 macro-task：宏任务 micro-task：微任务 首先我们还要知道两点：JavaScript是单线程的语言Event Loop是javascript的执行机制 异步任务包括：宏任务 和 微任务 同步任务：promise内的函数属于同步 .then()内部才属于异步微服务 new Promise(function(resolve) { console.log(‘7’); //属于同步任务 resolve();}).then(function() { console.log(‘8’) //属于异步微服务}) 宏任务： 包括整体代码script setTimeout setInterval setImmediate 微任务： 原生Promise(有些实现的promise将then方法放到了宏任务中) process.nextTick （process.nextTick(callback)类似node.js版的&quot;setTimeout&quot;） Object.observe(已废弃) MutationObserver 记住就行了。 事件循环规则： 骚年 先接我八字真言：先同后异，先微后宏 实例： Promise.resolve().then(()=&gt;{ console.log(&apos;Promise1&apos;) setTimeout(()=&gt;{ console.log(&apos;setTimeout2&apos;) Promise.resolve().then(()=&gt;{ console.log(&apos;Promise3&apos;) setTimeout(()=&gt;{ Promise.resolve().then(()=&gt;{ console.log(&apos;Promise5&apos;) setTimeout(()=&gt;{ console.log(&apos;setTimeout6&apos;) },0) }) console.log(&apos;setTimeout4&apos;) },0) }) },0) }) 先从上到下执行同步任务并全部执行完成 查找异步任务并分配到微任务列表 和 宏任务列表 （每个列表里先进栈先执行） 先执行微服务，并且查找微服务内部的 异步任务然后分配到微任务列表 和 宏任务列表 再执行宏任务，并且查找微服务内部的 异步任务然后分配到微任务列表 和 宏任务列表 既然是事件循环就不是一次就执行完毕了的，因为异步任务会有嵌套，最外层事件最先暴露出来，首先进入第一次循环 再先执行微服务，并查找，分配 再执行宏任务，并查找，分配 依次循环直至没有异步任务 执行结束 12345678910111213Promise.resolve().then(()=&gt;&#123; console.log(&apos;Promise1&apos;) setTimeout(()=&gt;&#123; console.log(&apos;setTimeout2&apos;) &#125;,0)&#125;)setTimeout(()=&gt;&#123; console.log(&apos;setTimeout1&apos;) Promise.resolve().then(()=&gt;&#123; console.log(&apos;Promise2&apos;) &#125;)&#125;,0) 第一回合 列出所有异步事件并逐个分配到宏服务和微任务里去，然后执行 先微后宏 微：promise1 宏：setTimeout1 先打印Promise1，setTimeout2进宏任务列表 setTimeout1，Promise2进微任务列表 第二回合 执行异步列表 先微后宏 先打印Promise2， 再打印setTimeout2， 到这里是不是有个大概的了解了，测验来了：（先用纸笔根据自己理解先答一遍，然后再看答案） 123456789101112131415161718192021222324252627282930313233343536console.log(&apos;1&apos;);setTimeout(function() &#123; console.log(&apos;2&apos;); process.nextTick(function() &#123; console.log(&apos;3&apos;); &#125;) new Promise(function(resolve) &#123; console.log(&apos;4&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;5&apos;) &#125;)&#125;)process.nextTick(function() &#123; console.log(&apos;6&apos;);&#125;)new Promise(function(resolve) &#123; console.log(&apos;7&apos;); resolve();&#125;).then(function() &#123; console.log(&apos;8&apos;)&#125;)setTimeout(function() &#123; console.log(&apos;9&apos;); process.nextTick(function() &#123; console.log(&apos;10&apos;); &#125;) new Promise(function(resolve) &#123; console.log(&apos;11&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;12&apos;) &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 宏任务Event Queue 微任务Event Queue setTimeout1 process1 setTimeout2 then1 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。 new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2 宏任务Event Queue 微任务Event Queue setTimeout2 process3 then3 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 结尾听到别人在讨论事件循环，我很想帮他们解答，可是我给出的答案都睡服不了我自己。所以决定自己整理一篇，我觉得可以让人理解的文章。下面还有别人的文章，建议大家多看看。广开言路，纳百家之言，行天下大事。 奉上文章： JS事件循环机制（event loop）之宏任务/微任务 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的防抖和节流]]></title>
    <url>%2F2019%2F04%2F17%2FJS%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[前言：今天做了一个功能，input 扫码枪扫码输入然后查询设备添加列表，扫码枪的输入频率是几十毫秒， 如果监听 onchange 事件效果也会如下图所示触发很多次并且每一次 onchange 都会触发查询请求。 显然这不是我要的解决方案。后来查询了扫码枪的配置，原来可以设置自动回车功能。监听 onkeypress 事件完美解决。但是今天的重点是函数的防抖与节流， 那我们就赶紧拿笔记下知识点吧 ！` 在浏览器中如果一个事件被频繁触发，比如输入框的 keyup, 窗口的 resize 以及 scroll 事件等，如果不做任何处理，事件的回调函数将会对应执行，这必然会加重浏览器的负担，影响用户的体验。面对这种场景，我们可以用函数的防抖 (debounce) 和节流 (throttle) 来处理。 函数防抖防抖 debounce: 让事件触发时的回调在一定的延时后执行。如果在计时期间又触发了事件，则重新开始计时。 比如在做一个检索的输入框，输入的内容发送给后台查询。如果不做防抖处理我们来看下： &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt; 用打印来模拟请求处理： 123456用打印来模拟请求处理：var ipt = document.getElementById(&apos;input&apos;);ipt.addEventListener(&apos;keyup&apos;, function(e)&#123; console.log(e.target.value);&#125;); 结果如下： 可见，每次触发事件都会执行回调函数，现在加入防抖处理： 12345678910111213141516171819var debounce = function(func, delay) &#123; var timer = null return function() &#123; var that = this; var args = arguments; if(timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(function() &#123; func.apply(that, args); &#125;, delay) &#125;&#125;ipt.addEventListener(&apos;keyup&apos;, debounce(function(e)&#123; console.log(e.target.value);&#125;, 400)) 效果如下： 可见，输入框在停止输入400ms后执行回调。在防抖后的回调函数用 timer 记录计时，每次执行回调的时候会先清空之前的计时。注意这里的timer是闭包变量，始终保持着上一个计时。 函数节流节流throttle: 让事件的回调一定时间间隔只执行一次。节流函数有两种实现方式，一种是记录增量，一种是定时方式。 用增量的方式实现节流： 1234567891011121314151617var throttle = function(func, delay) &#123; var pre = Date.now(); return function() &#123; var that = this; var args = arguments; var now = Date.now(); if (now - pre &gt;= delay) &#123; func.apply(that, args); pre = now; &#125; &#125;&#125;ipt.addEventListener(&apos;keyup&apos;, throttle(function(e)&#123; console.log(e.target.value);&#125;, 1000)) 节流的效果如下： 可见，无论怎么输入，事件回调总会在1s内执行一次。而且第一次输入会马上执行，这是因为处理节流的时候和第一次触发的时间间隔大于1s。但是最后一次触发不会执行回调。 利用计时方式处理节流： 1234567891011121314var throttle = function(func, delay) &#123; var timer = null; return function() &#123; var that = this; var args = arguments; if(!timer) &#123; timer = setTimeout(function() &#123; func.apply(that, args); timer = null; &#125;, delay) &#125; &#125;&#125; 利用变量 timer 记录定时器，如果定时器存在，则不执行回调。否则创建一个延时器执行回调。这种方法和时间戳增量的区别就是第一个触发不会立即执行回调，但是最后一次时间会在延时后触发回调函数。 如果想要立即触发并且最后一次也要执行回调，可以利用时间戳和计时方式结合在实现节流： 123456789101112131415161718192021var throttle = function(func, delay) &#123; var timer = null; var pre = Date.now(); return function() &#123; var now = Date.now(); var that = this; var args = arguments; var remain = delay - (now - pre); clearTimeout(timer); if (remain &lt;= 0) &#123; func.apply(that, args); pre = now &#125;else &#123; timer = setTimeout(function() &#123; func.apply(that, args); pre = now; &#125;, remain) &#125; &#125;&#125; 上面的节流函数会先判断剩余的间隔时间，如果剩余时间小于0，则立即执行。否则创建一个剩余时间的定时。注意，每次要记得清空之前的定时。 应用场景防抖 debounce 一般用来在输入检索，节约请求的资源。还有窗口的 resize，让不断调节窗口大小的最后一次触发。 节流 throttle 一般用在鼠标不断点击，让点击的回调按间隔执行一次。还有滑动 scroll 事件， 比如滚动到底部查询，按间隔请求一次数据来显示。 感想：有的时候灵感也是能力的一部分 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈 原文：https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CleanMyMac X]]></title>
    <url>%2F2019%2F04%2F17%2FCleanMyMac%20X%2F</url>
    <content type="text"><![CDATA[CleanMyMac X破解1.下载破解版下载地址 2.解压并打开dmg文件 双击上图红框位置 双击CleanMyMac X 4.3.0 [TNT].dmg 将程序拖入Application即可 3.破解双击Open Gatekeeper friendly 一路回车即可 4.错误提示 1.XXX文件已损坏，需要移到废纸篓。 解决方法一： 终端运行 sudo spctl --master-disable 重新运行程序 解决方法二： xattr -r -d com.apple.quarantine /Applications/CleanMyMac\ X.app /Applications/CleanMyMac\ X.app是CleanMyMac X 运行此命令，需要自己对应到程序的安装目录 2.提示文件不信任 解决方法一： Control+单击右键打开 解决方法二： 终端运行 sudo spctl --master-disable 更改为任何来源 3.CleanMyMac X 因出现问题而无法打开 解决方法一： 运行此命令 sudo codesign --force --deep --sign - /Applications/CleanMyMac\ X.app 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈 备注 2019年4月17日 亲测 macOS Mojave 10.14.4 可用]]></content>
      <categories>
        <category>软件</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好了歌注]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%A5%BD%E4%BA%86%E6%AD%8C%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[[宋] 曹雪芹 1234567891011121314151617陋室空堂，当年笏满床；衰草枯杨，曾为歌舞场。蛛丝儿结满雕梁，绿纱今又糊在蓬窗上。说什么脂正浓，粉正香，如何两鬓又成霜？昨日黄土陇头送白骨，今宵红灯帐底卧鸳鸯。金满箱，银满箱，展眼乞丐人皆谤。正叹他人命不长，那知自己归来丧！训有方，保不定日后作强梁。择膏粱，谁承望流落在烟花巷！因嫌纱帽小，致使锁枷杠，昨怜破袄寒，今嫌紫蟒长：乱烘烘你方唱罢我登场，反认他乡是故乡。甚荒唐，到头来都是为他人作嫁衣裳！ 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>诗词</category>
        <category>词</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悼允上人]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%82%BC%E5%85%81%E4%B8%8A%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[[宋] 释行海 白云寺里同听讲，卜得山斋竹树幽。 君已不来梅自发，世皆如梦水长流， 寒灯苦志归黄土，俗客轻人将白头。 万惜少年多是死，静思吾道转堪愁。 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>诗词</category>
        <category>诗</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EVP_DecryptFinal_ex:bad decrypt 和 出现Illegal Buffer Error这种的情况]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%88%E6%9D%83%E9%97%AE%E9%A2%981%2F</url>
    <content type="text"><![CDATA[看到这里 你的问题就不要担心了 大家的问题都是一样的。官网的实例是没问题的 当前 Bug 的表现 - 预期表现可以对encryptedData正常解密。 复现路径点击登录按钮后，小程序本地数据缓存冷启动后还还会有吗，微信小程序教程。小程序调用wx.login()，再将code、iv、encrypedData一起发往后端程序，后端程序调用微信api接口（api.weixin.qq.com/sns/jscode2session）希望获取openId，但经常会出现上图中的错误。 复现过程： 1、这个问题不是持续连续发生，而是在一段时间未操作小程序时，再次点击登录按钮触发登录操作的第一次时会发生，第二次及以后的登录操作则会成功。如果再过一段时间未操作小程序，当第一次登录的时候还是会出现这个现象——第一次登录不成功，后续登录操作可以成功。 2、问题的关键在于解密程序报错。将上述的ecryptedData、iv、session_key放入官方文档（貌似其中还有包括使用wx.getUserInfo()的描述，是否也要更新一下）中提供的demo.js程序运行，也会出现报错。 下面是我的解决 ： 一定要保证 新code的获取 在 getUserInfo或getPhoneNumber 之前 而且 每一次解密授权所用的code 都不是一样的 onload里先进行wx.login 获取code，再通过按钮开始授权 获取iv和encryptedData 之后就不会报错了 O(∩_∩)O哈哈~ 这可能也是 小程序考虑授权先后出现的错误问题 才把全部授权按钮使用主动触发的方式的 解决方案的出处：https://developers.weixin.qq.com/community/develop/doc/000808d32c06101b39d6032c956000 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>小程序授权问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客 NexT主题从v5更新到v6的记录及总结.md]]></title>
    <url>%2F2018%2F12%2F03%2F2018-12-03-Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E4%BB%8Ev5-x-x%E6%9B%B4%E6%96%B0%E5%88%B0v6-x-x%E7%9A%84%E8%AE%B0%E5%BD%95%E5%8F%8A%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Hexo博客 NexT主题从v5更新到v6的记录及总结今天索性升级一下我的主题 自定义配置样式还是很多的 需要详细修改配置https://sevencho.github.io/archives/14534beb.html #丰富插件和功能 参考博客https://zhuanlan.zhihu.com/p/26625249 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>Hexo</category>
        <category>NexT</category>
      </categories>
      <tags>
        <tag>NexT</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6之var let 和 const终极PK]]></title>
    <url>%2F2018%2F08%2F02%2Fes6%E4%B9%8Bvar-let-%E5%92%8C-const%E7%BB%88%E6%9E%81PK%2F</url>
    <content type="text"><![CDATA[直接上猛料 let 取代 varES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。 &apos;use strict&apos;; if (true) { let x = &apos;hello&apos;; } for (let i = 0; i &lt; 10; i++) { console.log(i); } 上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。 var命令存在变量提升效用，let命令没有这个问题。 &apos;use strict&apos;; if(true) { console.log(x); // ReferenceError let x = &apos;hello&apos;; } 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。 所以，建议不再使用var命令，而是使用let命令取代。 在let和const之间，建议优先使用const尤其是在全局环境，不应该设置变量，只应设置常量。 const优于let有几个原因。 一个是const可以提醒阅读程序的人，这个变量不应该改变； 另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算； 最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。 // bad var a = 1, b = 2, c = 3; // good const a = 1; const b = 2; const c = 3; // best const [a, b, c] = [1, 2, 3]; const 声明常量还有两个好处， 阅读代码的人立刻会意识到不应该修改这个值， 防止了无意间修改变量值所导致的错误。 所有的函数都应该设置为常量。 感想：长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 这里有var、let、const 区别？详尽对比和分析 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6之顶层对象的属性]]></title>
    <url>%2F2018%2F06%2F24%2Fes6%E4%B9%8B%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[顶层对象的属性顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。 window.a = 1; a // 1 a = 2; window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 var a = 1; // 如果在Node的REPL环境，可以写成global.a // 或者采用通用方法，写成this.a window.a // 1 let b = 1; window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。Node 里面，顶层对象是global，但其他环境都不支持。同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 // 方法一 (typeof window !== &apos;undefined&apos; ? window : (typeof process === &apos;object&apos; &amp;&amp; typeof require === &apos;function&apos; &amp;&amp; typeof global === &apos;object&apos;) ? global : this); // 方法二 var getGlobal = function () { if (typeof self !== &apos;undefined&apos;) { return self; } if (typeof window !== &apos;undefined&apos;) { return window; } if (typeof global !== &apos;undefined&apos;) { return global; } throw new Error(&apos;unable to locate global object&apos;); }; 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。 垫片库system.global模拟了这个提案，可以在所有环境拿到global。 // CommonJS的写法 require(&apos;system.global/shim&apos;)(); // ES6模块的写法 import shim from &apos;system.global/shim&apos;; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 // CommonJS的写法 var global = require(&apos;system.global&apos;)(); // ES6模块的写法 import getGlobal from &apos;system.global&apos;; const global = getGlobal(); 上面代码将顶层对象放入变量global。 感想：存在即合理 只是一个说辞 我们需要做的是不断的完善它，让它真的合理。毕竟罗马不是一日建成的！ 这里有var、let、const 区别？详尽对比和分析，希望可以帮你更好的理解。 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6之let 和 const]]></title>
    <url>%2F2018%2F06%2F22%2Fes6%E4%B9%8Blet-%E5%92%8C-const%2F</url>
    <content type="text"><![CDATA[let 命令##let特性： ###1.只在let命令所在的代码块内有效。 a. { let a = 10; var b = 1; } a // ReferenceError: a is not defined. b // 1 b. （let 与 for循环的用法） 要求必须 等let声明语句执行完之后，变量才能使用，不然会报Uncaught ReferenceError错误。 var a = []; for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 如同for 循环里产生了10次i的循环并没有被更新 a[2](); // 2 a[4](); // 4 a[7](); // 7 a[0](); // 0 #2.不存在变量提升 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; ###3.暂时性死区 console.log(aicoder); // 错误：Uncaught ReferenceError ... let aicoder = &apos;aicoder.com&apos;; // 这里就可以安全使用aicoder 有些“死区”比较隐蔽，不太容易发现。 function bar(x = y, y = 2) { return [x, y]; } bar(); // 报错 //因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 ###4.let变量不能重复声明 let a = 0; let a = &apos;sss&apos;; // Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared ######**ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。 ######总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 #2. 块级作用域 为什么需要块级作用域？ 第一：内层变量可能会覆盖外层变量。 var tmp = new Date(); function f() { console.log(tmp); if (false) { var tmp = &quot;hello world&quot;; } } f(); // undefined 第二：用来计数的循环变量泄露为全局变量。 var s = &apos;hello&apos;; for (var i = 0; i &lt; s.length; i++) { console.log(s[i]); } console.log(i); // 5 块级作用域特点： 1.ES6允许块级作用域的任意嵌套。 {{{{{let insane = 'Hello World'}}}}}; 2.允许在块级作用域之中声明函数。 // ES6严格模式 &apos;use strict&apos;; if (true) { function f() {} } // 不报错 ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 特别注意： ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 // 不报错 &apos;use strict&apos;; if (true) { function f() {} } // 报错 &apos;use strict&apos;; if (true) function f() {} #const命令 1.const声明一个只读的常量。一旦声明，常量的值就不能改变。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. 2.const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 const foo; // SyntaxError: Missing initializer in const declaration 3.const的作用域与let命令相同：只在声明所在的块级作用域内有效。 if (true) { const MAX = 5; } MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 if (true) { console.log(MAX); // ReferenceError const MAX = 5;} const声明的常量，也与let一样不可重复声明。 var message = “Hello!”;let age = 25; // 以下两行都会报错const message = “Goodbye!”;const age = 30; 6.对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 const foo = {};foo.prop = 123; foo.prop// 123 foo = {}; // TypeError: “foo” is read-only 下面是另一个例子（可以为其添加新属性。） const a = [];a.push(‘Hello’); // 可执行a.length = 0; // 可执行a = [‘Dave’]; // 报错 ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。 感想：明白了前辈们对javascript的不断的优化的心情，感谢他们的贡献我将好好细读文档。不服厚爱！ 这里有var、let、const 区别？详尽对比和分析 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6之变量的解构赋值]]></title>
    <url>%2F2018%2F06%2F20%2Fes6%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[ES6 变量的解构赋值数组的解构赋值基本用法ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 123var a = 1;var b = 2;var c = 3; ES6允许写成下面这样。 1var [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 1234567891011121314151617181920[foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = [&apos;a&apos;];x // &quot;a&quot;y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。123var [foo] = [];var [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。 解构赋值不仅适用于var命令，也适用于let和const命令。 123var [v1, v2, ..., vN ] = array;let [v1, v2, ..., vN ] = array;const [v1, v2, ..., vN ] = array; 对于Set结构，也可以使用数组的解构赋值。 12let [x, y, z] = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);x // &quot;a&quot; 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。 1234567891011function* fibs() &#123; var a = 0; var b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;var [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 上面代码中，fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。 默认值解构赋值允许指定默认值。123456var [foo = true] = [];foo // true[x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;[x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos; 注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 123456var [x = 1] = [undefined];x // 1var [x = 1] = [null];x // null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() &#123; console.log(&apos;aaa&apos;);&#125;let [x = f()] = [1]; 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。 123456let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。 对象的解构赋值解构不仅可以用于数组，还可以用于对象。1234var &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot; 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。1234567var &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;var &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。 如果变量名与属性名不一致，必须写成下面这样。12345678var &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;baz // &quot;aaa&quot;let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;let &#123; first: f, last: l &#125; = obj;f // &apos;hello&apos;l // &apos;world&apos; 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。 123456var &#123; foo: foo, bar: bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。var &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // &quot;aaa&quot;foo // error: foo is not defined 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。123456let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration &quot;foo&quot;let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration &quot;baz&quot; 上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。123456let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功 上面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。 和数组一样，解构也可以用于嵌套结构的对象。1234567891011var obj = &#123; p: [ &apos;Hello&apos;, &#123; y: &apos;World&apos; &#125; ]&#125;;var &#123; p: [x, &#123; y &#125;] &#125; = obj;x // &quot;Hello&quot;y // &quot;World&quot; 注意，这时p是模式，不是变量，因此不会被赋值。1234567891011121314var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // error: loc is undefinedstart // error: start is undefined 上面代码中，只有line是变量，loc和start都是模式，不会被赋值。 下面是嵌套赋值的例子。12345678let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true] 对象的解构也可以指定默认值。12345678910111213141516var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = &apos;Something went wrong&apos; &#125; = &#123;&#125;;msg // &quot;Something went wrong&quot; 默认值生效的条件是，对象的属性值严格等于undefined。123456var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。 如果解构失败，变量的值等于undefined。123var &#123;foo&#125; = &#123;bar: &apos;baz&apos;&#125;;foo // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 12// 报错var &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &apos;baz&apos;&#125;; 上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。123var _tmp = &#123;baz: &apos;baz&apos;&#125;;_tmp.foo.bar // 报错 如果要将一个已经声明的变量用于解构赋值，必须非常小心。12345// 错误的写法var x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。 12// 正确的写法(&#123;x&#125; = &#123;x: 1&#125;); 上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。 解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 123(&#123;&#125; = [true, false]);(&#123;&#125; = &apos;abc&apos;);(&#123;&#125; = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 let { log, sin, cos } = Math; 上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234var arr = [1, 2, 3];var &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。1234567const [a, b, c, d, e] = &apos;hello&apos;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。123let &#123;length : len&#125; = &apos;hello&apos;;len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。123456let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。123let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值。123456function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 下面是另一个例子。123[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值。123456789function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 注意，下面的写法会得到不一样的结果。123456789function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 undefined就会触发函数参数的默认值。123[1, undefined, 3].map((x = &apos;yes&apos;) =&gt; x);// [ 1, &apos;yes&apos;, 3 ] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况以下三种解构赋值不得使用圆括号。 （1）变量声明语句中，不能带有圆括号。12345678910// 全部报错var [(a)] = [1];var &#123;x: (c)&#125; = &#123;&#125;;var (&#123;x: c&#125;) = &#123;&#125;;var &#123;(x: c)&#125; = &#123;&#125;;var &#123;(x): c&#125; = &#123;&#125;;var &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。 （2）函数参数中，模式不能带有圆括号。 函数参数也属于变量声明，因此不能带有圆括号。123// 报错function f([(z)]) &#123; return z; &#125; （3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。 123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 12// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 上面代码将嵌套模式的一层，放在圆括号之中，导致报错。 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。1234[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途变量的解构赋值用途很多。 （1）交换变量的值 1[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = example(); （3）函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取JSON数据 解构赋值对提取JSON对象中的数据，尤其有用。1234567891011var jsonData = &#123; id: 42, status: &quot;OK&quot;, data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 上面代码可以快速提取JSON数据的值。 （5）函数参数的默认值 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。 （6）遍历Map结构 任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。12345678910var map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) &#123; console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。12345678910// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; （7）输入模块的指定方法 加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。 `const { SourceMapConsumer, SourceNode } = require(“source-map”); 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6之编码规范]]></title>
    <url>%2F2018%2F06%2F18%2Fes6%E4%B9%8B%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[let 命令##let特性： ###1.只在let命令所在的代码块内有效。 a. { let a = 10; var b = 1; } a // ReferenceError: a is not defined. b // 1 b. （let 与 for循环的用法） 要求必须 等let声明语句执行完之后，变量才能使用，不然会报Uncaught ReferenceError错误。 var a = []; for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 如同for 循环里产生了10次i的循环并没有被更新 a[2](); // 2 a[4](); // 4 a[7](); // 7 a[0](); // 0 #2.不存在变量提升 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; ###3.暂时性死区 console.log(aicoder); // 错误：Uncaught ReferenceError ... let aicoder = &apos;aicoder.com&apos;; // 这里就可以安全使用aicoder 有些“死区”比较隐蔽，不太容易发现。 function bar(x = y, y = 2) { return [x, y]; } bar(); // 报错 //因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 ###4.let变量不能重复声明 let a = 0; let a = &apos;sss&apos;; // Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared ######**ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。 ######总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 #2. 块级作用域 为什么需要块级作用域？ 第一：内层变量可能会覆盖外层变量。 var tmp = new Date(); function f() { console.log(tmp); if (false) { var tmp = &quot;hello world&quot;; } } f(); // undefined 第二：用来计数的循环变量泄露为全局变量。 var s = &apos;hello&apos;; for (var i = 0; i &lt; s.length; i++) { console.log(s[i]); } console.log(i); // 5 块级作用域特点： 1.ES6允许块级作用域的任意嵌套。 {{{{{let insane = 'Hello World'}}}}}; 2.允许在块级作用域之中声明函数。 // ES6严格模式 &apos;use strict&apos;; if (true) { function f() {} } // 不报错 ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 特别注意： ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 // 不报错 &apos;use strict&apos;; if (true) { function f() {} } // 报错 &apos;use strict&apos;; if (true) function f() {} #const命令 1.const声明一个只读的常量。一旦声明，常量的值就不能改变。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. 2.const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 const foo; // SyntaxError: Missing initializer in const declaration 3.const的作用域与let命令相同：只在声明所在的块级作用域内有效。 if (true) { const MAX = 5; } MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 if (true) { console.log(MAX); // ReferenceError const MAX = 5;} const声明的常量，也与let一样不可重复声明。 var message = “Hello!”;let age = 25; // 以下两行都会报错const message = “Goodbye!”;const age = 30; 6.对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 const foo = {};foo.prop = 123; foo.prop// 123 foo = {}; // TypeError: “foo” is read-only 下面是另一个例子（可以为其添加新属性。） const a = [];a.push(‘Hello’); // 可执行a.length = 0; // 可执行a = [‘Dave’]; // 报错 ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。 感想：明白了前辈们对javascript的不断的优化的心情，感谢他们的贡献我将好好细读文档。不服厚爱！ 这里有var、let、const 区别？详尽对比和分析 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改默认浏览器滚动条]]></title>
    <url>%2F2017%2F10%2F08%2F2017-10-8-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BB%9A%E5%8A%A8%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[修改默认浏览器滚动条::-webkit-scrollbar{ width:3px; height:0px;} /* 滚动条的大小 */ ::-webkit-scrollbar-track {background-color: #6d7277;} /* 滚动条的滑轨背景颜色 */ ::-webkit-scrollbar-thumb {background-color:#4b4d50; border-radius:0px;} /* 滑块颜色 */ /*::-webkit-scrollbar-button {background-color: #7c2929;} /* 滑轨两头的监听按钮颜色 ::-webkit-scrollbar-corner {background-color: black;} /* 横向滚动条和纵向滚动条相交处尖角的颜色 */ 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular控制器间的通讯]]></title>
    <url>%2F2017%2F07%2F20%2Fangular%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[ng笔记broadcast&amp;&amp;on&amp;&amp;emit&lt;script&gt; varmyapp=angular.module(&apos;TestApp&apos;,[&apos;ng&apos;]); myapp.controller(&apos;ParentCtrl&apos;,function($scope){ $scope.$on(&apos;to-child&apos;,function(e,d){ console.log(&apos;[ParentCtrl]to-child&apos;); }); $scope.$on(&apos;to-parent&apos;,function(e,d){ console.log(&apos;[ParentCtrl]to-parent&apos;); });}) myapp.controller(&apos;SelfCtrl&apos;,function($scope){ $scope.click=function(){ $scope.$broadcast(&apos;to-child&apos;,&apos;haha&apos;); $scope.$emit(&apos;to-parent&apos;,&apos;hehe&apos;);}}) myapp.controller(&apos;ChildCtrl&apos;,function($scope){ $scope.$on(&apos;to-child&apos;,function(e,d){ console.log(&apos;[ChildCtrl]to-child&apos;); }); $scope.$on(&apos;to-parent&apos;,function(e,d){ console.log(&apos;[ChildCtrl]to-parent&apos;); }); }) myapp.controller(&apos;BroCtrl&apos;,function($scope){ $scope.$on(&apos;to-child&apos;,function(e,d){ console.log(&apos;[BroCtrl]to-child&apos;); }); $scope.$on(&apos;to-parent&apos;,function(e,d){ console.log(&apos;[BroCtrl]to-parent&apos;); }); }); &lt;/script&gt; &lt;div ng-controller=&quot;ParentCtrl&quot;&gt; &lt;div ng-controller=&quot;SelfCtrl&quot;&gt; &lt;a class=&quot;btn&quot;ng-click=&quot;click()&quot;&gt;clickme&lt;/a&gt; &lt;div ng-controller=&quot;ChildCtrl&quot;&gt; &lt;span&gt;{{great}}&lt;/span&gt; &lt;p&gt;参数：{{canshu}}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div ng-controller=&quot;BroCtrl&quot;&gt;{{text}}&lt;/div&gt; &lt;/div&gt; Notes上面的例子可以看到，事件和事件发生者的兄弟是没有关系的，怎样都收不到。 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工欲善其事之markdown教程篇]]></title>
    <url>%2F2017%2F05%2F23%2F%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E4%B9%8Bmarkdown%E6%95%99%E7%A8%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Markdown基本语法1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可4、需要记一些语法（当然，也是很简单的） 一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 示例： # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 效果： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来 示例： **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 效果如下： 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例： &gt;这是引用的内容 &gt;&gt;这是引用的内容 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： --- ---- *** ***** 效果如下：可以看到，显示效果是一样的。 五、图片语法：![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例：![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/ u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下： 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法：】 [超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 示例： [百度](http://baidu.com) 效果如下： 百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 示例： &lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt; 效果如下：百度 七、列表##无序列表 语法： 无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表语法： // 数字加点 1.列表内容 2.列表内容 3.列表内容 注意：序号跟内容之间要有空格 效果如下： 1.列表内容2.列表内容3.列表内容 列表嵌套这里语法有些不同如下： - 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容 1. 一级有序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 2. 一级有序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容 4. 二级有序列表内容 八、表格语法： 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 示例： | 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 效果如下： 左对齐 居中对齐 右对齐 单元格 单元格 单元格 单元格 单元格 单元格 九、代码 注：直接tab 缩进或四个空格 也可以实现代码块 语法： 单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 点点点 代码... 代码... 代码... 点点点 注：为了防止转译，前后三个反引号使用’点点点’，实际是没有的 3个`。这里只是用来演示。 示例： 单行代码 `create database hero;` 代码块 点点点 function fun(){ echo &quot;这是一句非常牛逼的代码&quot;; } fun(); 点点点 效果如下： 单行代码 create database hero; 代码块 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 感想：语法虽然很简单还是多使用才能得心应手 来源：简书作者：高鸿祥链接：https://www.jianshu.com/p/191d1e21f7ed 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习是一件逆人性的事]]></title>
    <url>%2F2016%2F12%2F02%2F%E5%AD%A6%E4%B9%A0%E6%98%AF%E4%B8%80%E4%BB%B6%E9%80%86%E4%BA%BA%E6%80%A7%E7%9A%84%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[投资自己的时间其实，时间就像金钱一样，你得学会投资时间，把时间投资在有价值有意义的地方，你就会有“更多的时间”。 1.花时间学习基础知识，花时间读文档。 我发现，很多程序员都把时间都浪费在了查错上。究其根本原因就是基础知识不完整，没有好好地把技术相关的用户文档读完就仓促上手做事情了。其实只要把基础打扎实，认真读一下文档，你会省出很多很多的时间。系统地学习一门技术是非常关键的，所以这个时间是值得投资的。 2.花时间在解放自己生产力的事上。 在自动化、可配置、可重用、可扩展上要多花时间。对于软件开发来说，能自动化的事，就算多花点时间也要自动化，因为下次就不用花时间了。让自己的软件模块可以更灵活地配置和扩展，这样如果有需求变更或是有新需求的时候，可以不用改代码，或者就算要改代码也很容易。这里，可能很多人会说不要过度设计，对于这个观点，我既同意，也反对。的确，过度设计不好，但是只要是能在未来节省时间的，宁可这个项目延期，我也会做的。花时间在解放自己的事上是最有意义的了。 3.花时间在让自己成长的事上。注意，晋升并不代表成长，成长不应该只看在一个公司内，而是要看在行业内，在行业内的成长才是真正的成长。所以，把时间花在能让自己成长，能让自己有更强的竞争力，能让自己有更大的视野，能让自己有更多可能性的事情上。这样的时间投资才是有价值的。 4.花时间在建立高效的环境上。我相信你和我会有一样的一个习惯，那就“工欲善其事，必先利其器”。我们程序员在做事之前都喜欢把自己的工作环境整理到自己喜欢的状态下。比如使用趁手的开发工具，使用趁手的设备。这里，我想把这个事扩大一下，花些时间在影响你身边的人上，比如你的同事，你的产品经理，你的老板，去影响他们，让他们理解你，让他们配合你来建立更好的流程和管理方法。在这个方向上花时间也是很值得的。 规划自己的时间定义好优先级。无论你写不写出来，你一定都会有一个自己的 to-do list。有 to-do list 并不是什么高深的事。更重要的是，你要知道什么事是重要的，什么事是紧急的，什么事重要但不紧急，什么事又重要又紧急。这有利于你划分优先级。 最短作业优先。对于相同优先级的事，我个人喜欢的是“最短作业优先”的调度算法。理由是，先把可以快速做完的事做完，看到 to-do list 上划掉一个任务，看到任何的数据在减少，对于自己也好，对于老板也好。老板可以看到你的工作进度飞快，一方面有利于为后面复杂的工作争取更多的时间（老板只有在你有 Deliver 的时候才愿意给你更多的时间），另一方面，看到任务列表的减少会让你的心态更为积极。 而反过来，你花太多的时间在长作业上，长作业通常很容易出现“意外情况”让你花更多的时间，但此时你发现还有很多别的事没有做，这会让你产生焦虑感，产生更多的压力，进而导致更慢的生产效率。 想清楚再做。我发现很多时候，我们没有想清楚就开干了，边干边想，这样的工作方式其实很糟糕。你会发现，如果你没有想清楚，你总是要对已完成的工作进行返工，返工好几次，其实是非常浪费时间的。 所以，对于一些没想清楚的事，或是自己不太有信心的事，还是先看看有没有已有的成熟解决方案，或是找更牛的人来给你把把关，帮你出出主意，看看有没有更好、更简单的方式。 关注长期利益规划。要多关注长远可以节省多少时间，而不是当前会花费多少时间。长期成本会比短期成本大得多。所以，宁可在短期延期，也不要透支未来。这里的逻辑是，工作上的事你永远也做不完的，长痛不如短痛。 我一年要做 10 个项目，我宁可第 1 或第 2 个项目被老板骂，但是我可以赢得后面 8 个项目，从后面 8 个项目上把之前失去的找回来。而如果反过来的话，我虽然一开始得到了老板的信任，但是后面越来越玩不动，最终搬起一块大石头砸了自己的脚。而且，不关注长远利益的人，基本上来说也是很难有成长的。 也就是说，你要学会规划自己的行动计划，不是短期的，而是一个中长期的。我个人建议是按季度来规划，这个季度做什么，达到什么目标，一年往前走四步，而不是只考虑眼下。 用好自己的时间将军赶路不追小兔。这个世界有太多的东西会让我们分心和跑偏。能专注地把时间投入到一个有价值的事上是非常重要的。确定自己的目标，专注达到这个目标，而不是分心。将军的目标是要攻城，而不是追兔子。所以，你要学会过滤掉与自己目标无关的事，不要让那些无关的事控制自己。 比如，不要让别人来影响自己的心情，心情被影响了，你一下就会什么都不想干了。做自己心情的主人，不要让别人 hack 了你的心情。再比如，知道哪些是自己可以控制的事，哪些是自己控制不了的事，在自己能控制的地方花时间。 再比如，知道哪些是更有效的路径，是花时间改变别人，还是花时间去寻找志同道合的人。不与不如自己的人争论，也不要尝试花时间去叫醒那些装睡的人，这些都是非常浪费时间的事。多花时间在有产出的事上，少花时间在说服别人的事上。 形成习惯。再好的方法，如果没有形成习惯，不能在实际的工作和生活中解决实际问题，都将成为空谈。如果你是个追求上进的人，我相信一定看过很多时间管理方法的文章和书籍，并且看的时候还会有些振奋，内心有时还会不自觉地想，“嗯，嗯！这个方法不错，正是我需要的，可以解决我的问题……”但很多时候都坚持不了几天就抛之脑后了。 所以，在讲述完如何争取时间，及如何使用时间之后，我想分享一下如何将这些时间管理方法形成习惯，因为我坚信：“做”比“做好”更重要。养成一个好习惯通常需要 30 天左右的时间，尤其在最初的几天就更为重要了。这时，不妨将文章中提到的方法和几个要点，写在某本书或者笔记本的扉页上，方便查看，时刻提醒自己。 而且，你可以结合自己的实际情况，适当做出调整。我的方法是我根据自己的情况总结的，不一定完全适合你，你完全可以基于我说的几个原则，发掘其他更适合自己的方法，这样才能更有利于形成习惯，对你更有帮助。 形成正反馈。在前面的文章中，我提到过，要有正反馈，也就是成就感，有助于完成一些看似难以完成的事儿。比如，我们说过，学习是逆人性的事儿，但如果在学习过程中不断地有正反馈，就更利于我们坚持下去。要让自己有正反馈，那就需要把时间花在有价值的地方，比如，解决自己和他人的痛点，这样你会收获别人的赞扬和鼓励。 反思和举一反三。可以尝试每周末花上点时间思考一下，本周做了哪些事儿？时间安排是否合理？还有哪些可以优化提高的地方？有点儿类似于我们常说的“复盘”。然后思考一下，下周的主要任务是什么？并根据优先级规划一下完成这些任务的顺序，也就是做一些下周的工作规划。 这样每周都能及时得到自己做时间管理之后的反馈，并有助于持续优化。通常坚持做时间管理一段时间以后，你都能在每次复盘时得到正反馈，这是有利于我们形成时间管理习惯的。但我这里也想强调一点，我们也要允许偶尔的“负反馈”，因为人的状态总是会有高潮和低谷的，控制好一个合理的度就可以了。 人最宝贵的财富就是时间，把时间用在刀刃上，必将让你的人生有更多收获。 如有侵权行为，请点击这里联系我删除 如发现疑问或者错误点击反馈]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F05%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[就在这里写一些，搭建成功的心情吧。 首先，有点小喜悦。搭建成功，也是经历9981难的。 其次，需要抽些时间把我的学习成长的路径，我的每一步脚印从我的笔记里，搬出来。整理在这里，供”未来人” 借鉴，交流和学习。 最后，感谢全世界这么多的开源项目的开发者的大力贡献。 The peace of the world Hello worldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
